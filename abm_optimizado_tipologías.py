# -*- coding: utf-8 -*-
"""abm_optimizado_tipologías.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q3HOZN5L4oZEOiwPJ-S-z143PCxqNs3o

# =============================================
# MODELO ECONÓMICO REGIONAL OPTIMIZADO CON TIPOLOGÍAS
# =============================================
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
import os
from collections import defaultdict
from enum import Enum
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
import warnings
warnings.filterwarnings('ignore')

# Configuración para reproducibilidad
SEED = 56
random.seed(SEED)
np.random.seed(SEED)

"""# =============================================
# FUNCIONES AUXILIARES
# =============================================
"""

def calcular_correlacion_segura(df):
    """Calcula correlación de manera segura, manejando casos con varianza cero"""
    try:
        # Remover columnas con varianza cero (constantes)
        df_clean = df.loc[:, df.var() != 0]

        # Remover filas con valores NaN
        df_clean = df_clean.dropna()

        if len(df_clean.columns) < 2 or len(df_clean) < 2:
            return pd.DataFrame()

        corr = df_clean.corr()
        return corr

    except Exception as e:
        print(f"Error calculando correlación: {e}")
        return pd.DataFrame()

"""# =============================================
# ENUMS Y ESTRUCTURAS DE DATOS
# =============================================

"""

class TipoRegion(Enum):
    """Tipos de regiones según clasificación geográfica y económica de México"""
    NOROESTE = "noroeste"          # Baja California, Baja California Sur, Chihuahua, Durango, Sinaloa, Sonora
    NORESTE = "noreste"            # Coahuila, Nuevo León, Tamaulipas
    OCCIDENTE = "occidente"        # Colima, Jalisco, Michoacán, Nayarit
    CENTRONORTE = "centronorte"    # Aguascalientes, Guanajuato, Querétaro, San Luis Potosí, Zacatecas
    ORIENTE = "oriente"            # Ciudad de México, México, Morelos, Tlaxcala, Hidalgo, Puebla
    SUROESTE = "suroeste"          # Chiapas, Guerrero, Oaxaca
    SURESTE = "sureste"            # Veracruz, Yucatán, Tabasco, Quintana Roo, Campeche

class TipoRegionEconomica(Enum):
    """Tipología regional basada en evidencia empírica de desarrollo"""
    ATRAPADA = "Atrapada"         # Alta especialización, baja innovación, baja diversificación
    NO_ATRAPADA = "No_Atrapada"   # Alta innovación, alta diversificación, baja especialización

class TipoSector(Enum):
    """Categorías de sectores económicos"""
    PRIMARIO_BAJO = "primario_bajo"
    PRIMARIO_ALTO = "primario_alto"
    MANUFACTURA_BAJA = "manufactura_baja"
    MANUFACTURA_ALTA = "manufactura_alta"
    SERVICIOS_BAJOS = "servicios_bajos"
    SERVICIOS_INTERMEDIOS = "servicios_intermedios"
    SERVICIOS_AVANZADOS = "servicios_avanzados"
    TURISMO_MASIVO = "turismo_masivo"
    TURISMO_ESPECIALIZADO = "turismo_especializado"

class EtapaEconomica(Enum):
    """Etapas de desarrollo económico"""
    SUBSISTENCIA = "subsistencia"
    INDUSTRIALIZACION = "industrializacion"
    DIVERSIFICACION = "diversificacion"
    CONOCIMIENTO = "conocimiento"

@dataclass
class CaracteristicasRegionales:
    """Características específicas de cada tipo de región"""
    tipo: TipoRegion
    desarrollo_economico: float  # Nivel de desarrollo (0-1)
    cercania_eeuu: float  # Cercanía comercial con EE.UU. (0-1)
    riqueza_natural: float  # Riqueza natural y cultural (0-1)
    clima_aridez: float  # Nivel de aridez (0-1)
    rezago_social: float  # Nivel de rezago social (0-1)
    conectividad_transport: float  # Conectividad de transporte (0-1)
    inversion_extranjera: float  # Capacidad de atraer inversión extranjera (0-1)

@dataclass
class ParametrosTipologicos:
    """Parámetros específicos de cada tipología regional (basados en evidencia empírica)"""
    tipo_region_economica: TipoRegionEconomica

    # Parámetros tecnológicos y de innovación
    capacidad_tecnologica_base: float
    innovaciones_base: float
    tasa_innovacion_base: float

    # Parámetros sectoriales
    diversidad_base: float
    especializacion_base: float

    # Parámetros laborales
    brecha_calificacion_base: float

    # Parámetros adicionales
    empleo_total_base: float
    empleo_especializado_base: float
    eficiencia_regional_base: float

    # Parámetros de evolución
    tasa_decaimiento_tech: float
    inercia_tech: float
    factor_intensidad_laboral: float

"""# =============================================
# PARÁMETROS GLOBALES DEL MODELO
# =============================================
"""

class ParametrosGlobales:
    """Parámetros globales del modelo económico"""

    # Parámetros tecnológicos
    NIVEL_TECNOLOGICO_INICIAL = 0.12
    TASA_INNOVACION_BASE = 0.015
    COSTO_DESARROLLO_TECNOLOGICO = 0.25
    UMBRAL_INNOVACION_MINIMA = 0.05
    EFECTO_DERRAME_CONOCIMIENTO = 0.18
    ACELERACION_INNOVACION = 0.02

    # Parámetros de fuerza laboral
    HABILIDAD_INICIAL_TRABAJADORES = 0.28
    TASA_INVERSION_EDUCACION = 0.04
    TAMAÑO_POOL_TRABAJADORES = 10000000
    TASA_APRENDIZAJE = 0.06
    IMPACTO_TECNOLOGIA_EMPLEO = 0.5

    # Parámetros sectoriales
    VOLATILIDAD_EMPLEO_BASE = 0.06
    PENALIZACION_DESAJUSTE_HABILIDADES = 0.56
    DURACION_CICLO_ECONOMICO = 6

    # Parámetros de diversificación
    BONUS_DIVERSIDAD_INNOVACION = 0.1
    RESILIENCIA_SHOCK_DIVERSIDAD = 0.8
    DIVERSIDAD_MINIMA_CAMBIO = 0.4

    # Parámetros de política
    FACTOR_CAPACIDAD_ABSORCION = 0.15
    APOYO_POLITICA_INNOVACION = 0.1
    PROPENSION_ID_PRIVADO = 0.09
    PROBABILIDAD_ESCAPE_TRAMPA = 0.02

"""# =============================================
# PARÁMETROS DE TIPOLOGÍAS REGIONALES
# =============================================
"""

class ConfiguracionTipologias:
    """Configuración de parámetros para diferentes tipologías regionales"""

    @staticmethod
    def obtener_parametros_tipologicos() -> Dict[TipoRegionEconomica, ParametrosTipologicos]:
        """Retorna parámetros específicos para cada tipología regional"""
        return {
            TipoRegionEconomica.ATRAPADA: ParametrosTipologicos(
                tipo_region_economica=TipoRegionEconomica.ATRAPADA,

                # Parámetros para regiones atrapadas
                capacidad_tecnologica_base=0.42,  # Media de regiones atrapadas
                innovaciones_base=0.04,  # Baja tasa de innovación
                tasa_innovacion_base=0.04,
                diversidad_base=0.47,  # Baja diversificación
                especializacion_base=0.53,  # Alta especialización
                brecha_calificacion_base=0.47,  # Baja brecha de calificación
                empleo_total_base=0.50,
                empleo_especializado_base=0.40,
                eficiencia_regional_base=0.70,
                tasa_decaimiento_tech=0.02,
                inercia_tech=0.95,
                factor_intensidad_laboral=3.0
            ),

            TipoRegionEconomica.NO_ATRAPADA: ParametrosTipologicos(
                tipo_region_economica=TipoRegionEconomica.NO_ATRAPADA,

                # Parámetros para regiones no atrapadas
                # Especialización moderada/intermedia
                capacidad_tecnologica_base=1.35,  # Alta capacidad tecnológica
                innovaciones_base=0.14,  # Alta tasa de innovación
                tasa_innovacion_base=0.14,
                diversidad_base=0.55,  # Diversificación moderada (equilibrada con especialización)
                especializacion_base=0.45,  # Especialización moderada/intermedia
                brecha_calificacion_base=0.72,  # Alta brecha de calificación
                empleo_total_base=0.55,
                empleo_especializado_base=0.45,
                eficiencia_regional_base=0.80,
                tasa_decaimiento_tech=0.01,
                inercia_tech=0.75,
                factor_intensidad_laboral=4.5
            )
        }

class EvaluacionDinamica:
    """Evaluación dinámica del estado de las regiones basada en características"""

    @staticmethod
    def evaluar_estado_region(capacidad_tecnologica: float, innovaciones_realizadas: float,
                             diversidad_sectorial: float, especializacion: float,
                             tasa_innovacion: float, brecha_calificacion: float) -> str:
        """
        Evalúa dinámicamente si una región está "Atrapada" o "No Atrapada"
        basado en sus características actuales

        Criterios:
        - Regiones Atrapadas: Alta especialización + baja innovación + baja diversidad
        - Regiones No Atrapadas: Baja/moderada especialización + alta innovación + moderada diversidad
        """

        # Puntuación para estar atrapada (máximo 1.0)
        # Peso alto para especialización excesiva
        puntuacion_atrapada = (
            especializacion * 0.35 +  # Alta especialización (35%)
            (1 - tasa_innovacion) * 0.25 +  # Baja innovación (25%)
            (1 - diversidad_sectorial) * 0.20 +  # Baja diversidad (20%)
            (1 - innovaciones_realizadas) * 0.10 +  # Pocas innovaciones (10%)
            (1 - capacidad_tecnologica) * 0.10  # Baja capacidad tecnológica (10%)
        )

        # Puntuación para estar no atrapada (máximo 1.0)
        puntuacion_no_atrapada = (
            (1 - especializacion) * 0.25 +  # Baja/moderada especialización (25%)
            tasa_innovacion * 0.25 +  # Alta innovación (25%)
            diversidad_sectorial * 0.20 +  # Moderada/alta diversidad (20%)
            innovaciones_realizadas * 0.15 +  # Muchas innovaciones (15%)
            capacidad_tecnologica * 0.15  # Alta capacidad tecnológica (15%)
        )

        # Umbrales de clasificación
        UMBRAL_ATRAPADA = 0.45  # Por encima de esto = Atrapada
        UMBRAL_NO_ATRAPADA = 0.55  # Por encima de esto = No Atrapada

        if puntuacion_atrapada >= UMBRAL_ATRAPADA and puntuacion_atrapada >= puntuacion_no_atrapada:
            return "Atrapada"
        elif puntuacion_no_atrapada >= UMBRAL_NO_ATRAPADA:
            return "No_Atrapada"
        else:
            # Zona intermedia - mantener clasificación previa o inicial
            return "En_transicion"

    @staticmethod
    def calcular_propension_atrappada(capacidad_tecnologica: float, innovaciones_realizadas: float,
                                     diversidad_sectorial: float, especializacion: float,
                                     tasa_innovacion: float) -> float:
        """
        Calcula la propensión a estar atrapada (0.0 a 1.0)
        Útil para análisis de sensibilidad
        """
        return (
            especializacion * 0.4 +
            (1 - tasa_innovacion) * 0.3 +
            (1 - diversidad_sectorial) * 0.2 +
            (1 - innovaciones_realizadas) * 0.1
        )

    @staticmethod
    def evaluar_evolucion_dinamica(df: pd.DataFrame) -> pd.DataFrame:
        """
        Evalúa dinámicamente el estado de todas las regiones en cada paso temporal
        """
        df_resultado = df.copy()

        # Agregar columna de evaluación dinámica
        df_resultado['estado_dinamico'] = df_resultado.apply(
            lambda row: EvaluacionDinamica.evaluar_estado_region(
                row['capacidad_tecnologica'],
                row['innovaciones_realizadas'],
                row['diversidad_sectorial'],
                row['especializacion'],
                row['tasa_innovacion'],
                row['brecha_calificacion']
            ), axis=1
        )

        # Agregar propensión a estar atrapada
        df_resultado['propension_atrappada'] = df_resultado.apply(
            lambda row: EvaluacionDinamica.calcular_propension_atrappada(
                row['capacidad_tecnologica'],
                row['innovaciones_realizadas'],
                row['diversidad_sectorial'],
                row['especializacion'],
                row['tasa_innovacion']
            ), axis=1
        )

        return df_resultado
    @staticmethod
    def obtener_distribucion_tipologias() -> Dict[TipoRegionEconomica, float]:
        """Retorna la distribución inicial de tipologías regionales"""
        return {
            TipoRegionEconomica.ATRAPADA: 0.75,  # 75% del total (regiones atrapadas)
            TipoRegionEconomica.NO_ATRAPADA: 0.25  # 25% del total (regiones no atrapadas)
        }

    @staticmethod
    def crear_tipologia_regional(n_region: int, n_pasos: int) -> pd.DataFrame:
        """
        Crea tipología de regiones basada en evaluación DINÁMICA de características:
        - Las regiones se clasifican basado en métricas reales durante la simulación
        - Distribución inicial 75% atrapadas, 25% no atrapadas (como punto de partida)
        - Evolución dinámica basada en características sectoriales y regionales
        """
        regiones = []

        # Obtener parámetros tipológicos
        parametros_tipologicos = ConfiguracionTipologias.obtener_parametros_tipologicos()

        # Distribución inicial del 75%-25% como punto de partida
        regiones_atrapadas_inicial = int(n_region * 0.75)
        regiones_no_atrapadas_inicial = n_region - regiones_atrapadas_inicial

        # Crear lista de regiones clasificadas inicialmente
        tipos_iniciales = ([TipoRegionEconomica.ATRAPADA] * regiones_atrapadas_inicial +
                          [TipoRegionEconomica.NO_ATRAPADA] * regiones_no_atrapadas_inicial)

        # Mezclar aleatoriamente para evitar patrones determinísticos
        np.random.shuffle(tipos_iniciales)

        for region_id in range(n_region):
            # Usar clasificación inicial, pero será evaluada dinámicamente
            tipo_region_inicial = tipos_iniciales[region_id]
            parametros = parametros_tipologicos[tipo_region_inicial]

            # Generar datos para todos los pasos de tiempo
            for paso in range(n_pasos):
                region = {
                    'id_region': region_id,
                    'tipo_region_economica_inicial': tipo_region_inicial.value,
                    'paso_tiempo': paso,

                    # Parámetros principales basados en evidencia empírica
                    'capacidad_tecnologica': max(0, parametros.capacidad_tecnologica_base + np.random.normal(0, 0.05)),
                    'innovaciones_realizadas': max(0, parametros.innovaciones_base + np.random.normal(0, 0.01)),
                    'diversidad_sectorial': max(0, parametros.diversidad_base + np.random.normal(0, 0.05)),
                    'especializacion': max(0, parametros.especializacion_base + np.random.normal(0, 0.03)),
                    'brecha_calificacion': max(0, parametros.brecha_calificacion_base + np.random.normal(0, 0.05)),

                    # Parámetros adicionales
                    'empleo_total': max(0, parametros.empleo_total_base + np.random.normal(0, 0.02)),
                    'empleo_especializado': max(0, parametros.empleo_especializado_base + np.random.normal(0, 0.03)),
                    'eficiencia_regional': max(0, parametros.eficiencia_regional_base + np.random.normal(0, 0.1)),

                    # Variables derivadas basadas en tipología
                    'tasa_innovacion': max(0, parametros.tasa_innovacion_base + np.random.normal(0, 0.01)),
                    'indice_diversificacion': max(0, parametros.diversidad_base + np.random.normal(0, 0.05)),
                    'indice_especializacion': max(0, parametros.especializacion_base + np.random.normal(0, 0.03)),
                    'nivel_tecnologico': max(0, parametros.capacidad_tecnologica_base + np.random.normal(0, 0.05))
                }

                regiones.append(region)

        return pd.DataFrame(regiones)

"""# =============================================
# PARÁMETROS DE AGLOMERACIÓN Y TRANSICIONES
# =============================================
"""

class ConfiguracionAglomeraciones:
    """Configuración de parámetros para diferentes tipos de aglomeraciones regionales"""

    @staticmethod
    def obtener_parametros_aglomeracion() -> Dict[str, Dict]:
        """Retorna parámetros para las aglomeraciones regionales"""
        return {
            'C1': {
                'descripcion': 'Baja diversidad-especialización',
                'especializacion_inicial': (0.80, 1),
                'intensidad_laboral_final': 4,
                'capacidad_tech_inicial': 0.1,
                'tasa_decaimiento_tech': 0.01,
                'nivel_diversidad': 'bajo',
                'inercia_tech': 0.95
            },
            'C2': {
                'descripcion': 'Media diversidad-especialización',
                'especializacion_inicial': 1.09,
                'nivel_diversidad': 'medio',
                'capacidad_tech_inicial': 0.1,
                'tasa_decaimiento_tech': 0.015,
                'factor_intensidad_laboral': 4.5,
                'inercia_tech': 0.85
            },
            'C3': {
                'descripcion': 'Alta diversidad-especialización',
                'especializacion_inicial': 1.3,
                'nivel_diversidad': 'medio-alto',
                'capacidad_tech_inicial': 0.15,
                'tasa_decaimiento_tech': 0.01,
                'factor_intensidad_laboral': 3.5,
                'inercia_tech': 0.75
            },
            'C4': {
                'descripcion': 'Sobre especialización',
                'especializacion_inicial': 1.5,
                'nivel_diversidad': 'medio-alto',
                'capacidad_tech_inicial': 0.15,
                'tasa_decaimiento_tech': 0.02,
                'factor_intensidad_laboral': 3,
                'nivel_especializacion': 'alto',
                'inercia_tech': 0.7
            }
        }

    @staticmethod
    def obtener_matrices_transicion() -> Dict[str, List[List[float]]]:
        """Retorna las matrices de transición de Markov para cada tipo de conglomerado"""
        return {
            'C1': [
                [0.97, 0.03, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.05, 0.95, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.70, 0.30, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.85, 0.15, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.97, 0.03, 0.00, 0.00, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.85, 0.10, 0.00, 0.00],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.15, 0.75, 0.10, 0.00],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.97, 0.03],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.95]   # Turismo_Especializado
            ],
            'C2': [
                [0.85, 0.10, 0.05, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.10, 0.80, 0.10, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.15, 0.75, 0.10, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.25, 0.65, 0.10, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.85, 0.10, 0.05, 0.00, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.20, 0.00, 0.00],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.15, 0.65, 0.20, 0.00],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.85, 0.15],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.95]   # Turismo_Especializado
            ],
            'C3': [
                [0.40, 0.15, 0.20, 0.10, 0.15, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.05, 0.35, 0.25, 0.15, 0.20, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.05, 0.35, 0.30, 0.25, 0.05, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.10, 0.40, 0.25, 0.10, 0.15, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.45, 0.30, 0.20, 0.05, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.45, 0.30, 0.15, 0.05],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.55, 0.25, 0.15],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.15, 0.00, 0.55, 0.25],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.10, 0.15, 0.70]   # Turismo_Especializado
            ],
            'C4': [
                [0.85, 0.05, 0.05, 0.00, 0.05, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.05, 0.80, 0.10, 0.00, 0.05, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.03, 0.85, 0.10, 0.02, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.05, 0.75, 0.10, 0.05, 0.05, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.85, 0.10, 0.05, 0.00, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.15, 0.05, 0.00],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.15, 0.05],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.05, 0.00, 0.75, 0.15],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.03, 0.05, 0.05, 0.87]   # Turismo_Especializado
            ]
        }

"""# =============================================
# CONFIGURACIÓN DE SECTORES ECONÓMICOS
# =============================================
"""

class ConfiguracionSectores:
    """Configuración detallada de los sectores económicos"""

    @staticmethod
    def obtener_sectores_economicos() -> Dict[str, str]:
        """Retorna la definición de sectores económicos"""
        return {
            1: "Agricultura Tradicional",
            2: "Agricultura Tecnificada",
            3: "Minería Básica",
            4: "Minería Tecnológica",
            5: "Manufactura Básica",
            6: "Manufactura Avanzada",
            7: "Servicios Básicos",
            8: "Servicios Financieros",
            9: "Servicios Tecnológicos",
            10: "Turismo Masivo",
            11: "Turismo Especializado"
        }

    @staticmethod
    def obtener_distribucion_sectores() -> Dict[str, float]:
        """Retorna la distribución inicial de sectores"""
        return {
            'Agricultura Tradicional': 0.103,
            'Agricultura Tecnificada': 0.025,
            'Minería Básica': 0.005,
            'Minería Tecnológica': 0.002,
            'Manufactura Básica': 0.15,
            'Manufactura Avanzada': 0.097,
            'Servicios Básicos': 0.402,
            'Servicios Financieros': 0.031,
            'Servicios Tecnológicos': 0.048,
            'Turismo Masivo': 0.068,
            'Turismo Especializado': 0.030
        }

    @staticmethod
    def obtener_tipos_sectores() -> Dict[str, List[int]]:
        """Mapea tipos de sector a IDs de sectores específicos"""
        return {
            'Primario_Bajo': [1, 3],
            'Primario_Alto': [2, 4],
            'Manufactura_Baja': [5],
            'Manufactura_Alta': [6],
            'Servicios_Bajos': [7],
            'Servicios_Intermedios': [8],
            'Servicios_Avanzados': [9],
            'Turismo_Masivo': [10],
            'Turismo_Especializado': [11]
        }

    @staticmethod
    def obtener_sectores_disponibles() -> List[str]:
        """Retorna lista de todos los sectores disponibles"""
        return [
            'Primario_Bajo', 'Primario_Alto', 'Manufactura_Baja', 'Manufactura_Alta',
            'Servicios_Bajos', 'Servicios_Intermedios', 'Servicios_Avanzados',
            'Turismo_Masivo', 'Turismo_Especializado'
        ]

    @staticmethod
    def obtener_parametros_sector(tipo_sector: str) -> Dict:
        """Retorna parámetros específicos para un tipo de sector"""
        parametros = {
            'Primario_Bajo': {
                'margen_rango': (0.25, 0.45),
                'inversion_tec': 0.05,
                'volatilidad': 0.35,
                'requisitos_habilidades': (0.3, 0.5),
                'tasa_empleo': (0.7, 0.8),
                'inversion_capacitacion': 0.05,
                'capacidad_innovacion': 0.1,
                'intensidad_conocimiento': 0.2,
                'enlaces_sectoriales': 0.3,
                'coeficiente_especializacion': 0.75,
                'productividad': 3.8,  # USD/hora
                'rango_productos': (3, 7),
                'empleo_maximo': 1
            },
            'Primario_Alto': {
                'margen_rango': (0.35, 0.55),
                'inversion_tec': 0.25,
                'volatilidad': 0.25,
                'requisitos_habilidades': (0.5, 0.7),
                'tasa_empleo': (0.75, 0.85),
                'inversion_capacitacion': 0.15,
                'capacidad_innovacion': 0.3,
                'intensidad_conocimiento': 0.4,
                'enlaces_sectoriales': 0.5,
                'coeficiente_especializacion': 0.66,
                'productividad': 9.2,
                'rango_productos': (5, 9),
                'empleo_maximo': 1
            },
            'Manufactura_Baja': {
                'margen_rango': (0.15, 0.3),
                'inversion_tec': 0.2,
                'volatilidad': 0.2,
                'requisitos_habilidades': (0.4, 0.6),
                'tasa_empleo': (0.7, 0.85),
                'inversion_capacitacion': 0.1,
                'capacidad_innovacion': 0.25,
                'intensidad_conocimiento': 0.35,
                'enlaces_sectoriales': 0.6,
                'coeficiente_especializacion': 0.58,
                'productividad': 8.7,
                'rango_productos': (6, 10),
                'empleo_maximo': 1
            },
            'Manufactura_Alta': {
                'margen_rango': (0.25, 0.4),
                'inversion_tec': 0.4,
                'volatilidad': 0.15,
                'requisitos_habilidades': (0.6, 0.8),
                'tasa_empleo': (0.8, 0.9),
                'inversion_capacitacion': 0.2,
                'capacidad_innovacion': 0.5,
                'intensidad_conocimiento': 0.7,
                'enlaces_sectoriales': 0.8,
                'coeficiente_especializacion': 0.45,
                'productividad': 32.5,
                'rango_productos': (8, 18),
                'empleo_maximo': 1
            },
            'Servicios_Bajos': {
                'margen_rango': (0.2, 0.4),
                'inversion_tec': 0.1,
                'volatilidad': 0.15,
                'requisitos_habilidades': (0.3, 0.5),
                'tasa_empleo': (0.75, 0.9),
                'inversion_capacitacion': 0.08,
                'capacidad_innovacion': 0.15,
                'intensidad_conocimiento': 0.3,
                'enlaces_sectoriales': 0.4,
                'coeficiente_especializacion': 0.35,
                'productividad': 5.2,
                'rango_productos': (4, 8),
                'empleo_maximo': 1
            },
            'Servicios_Intermedios': {
                'margen_rango': (0.3, 0.5),
                'inversion_tec': 0.25,
                'volatilidad': 0.1,
                'requisitos_habilidades': (0.5, 0.7),
                'tasa_empleo': (0.8, 0.95),
                'inversion_capacitacion': 0.15,
                'capacidad_innovacion': 0.35,
                'intensidad_conocimiento': 0.5,
                'enlaces_sectoriales': 0.7,
                'coeficiente_especializacion': 0.25,
                'productividad': 38.7,
                'rango_productos': (7, 11),
                'empleo_maximo': 1
            },
            'Servicios_Avanzados': {
                'margen_rango': (0.4, 0.65),
                'inversion_tec': 0.45,
                'volatilidad': 0.1,
                'requisitos_habilidades': (0.7, 0.9),
                'tasa_empleo': (0.85, 0.8),
                'inversion_capacitacion': 0.25,
                'capacidad_innovacion': 0.7,
                'intensidad_conocimiento': 0.9,
                'enlaces_sectoriales': 0.9,
                'coeficiente_especializacion': 0.18,
                'productividad': 48.9,
                'rango_productos': (10, 21),
                'empleo_maximo': 1
            },
            'Turismo_Masivo': {
                'margen_rango': (0.2, 0.5),
                'inversion_tec': 0.05,
                'volatilidad': 0.4,
                'requisitos_habilidades': (0.2, 0.4),
                'tasa_empleo': (0.6, 0.9),
                'inversion_capacitacion': 0.03,
                'capacidad_innovacion': 0.15,
                'intensidad_conocimiento': 0.2,
                'enlaces_sectoriales': 0.3,
                'coeficiente_especializacion': 0.85,
                'productividad': 6.5,
                'rango_productos': (3, 7),
                'empleo_maximo': 1
            },
            'Turismo_Especializado': {
                'margen_rango': (0.3, 0.6),
                'inversion_tec': 0.15,
                'volatilidad': 0.3,
                'requisitos_habilidades': (0.4, 0.6),
                'tasa_empleo': (0.7, 0.9),
                'inversion_capacitacion': 0.1,
                'capacidad_innovacion': 0.3,
                'intensidad_conocimiento': 0.4,
                'enlaces_sectoriales': 0.5,
                'coeficiente_especializacion': 0.65,
                'productividad': 12.8,
                'rango_productos': (5, 9),
                'empleo_maximo': 1
            }
        }
        return parametros.get(tipo_sector, {})

    @staticmethod
    def obtener_factores_sectoriales() -> Tuple[Dict[str, float], Dict[str, float]]:
        """Retorna factores de innovación y productividad por sector (simulados)"""

        factores_innovacion = {
            'Agricultura Tradicional': 0.4,
            'Agricultura Tecnificada': 0.7,
            'Minería Básica': 0.3,
            'Minería Tecnológica': 0.8,
            'Manufactura Básica': 0.6,
            'Manufactura Avanzada': 0.9,
            'Servicios Básicos': 0.5,
            'Servicios Financieros': 0.8,
            'Servicios Tecnológicos': 1.0,
            'Turismo Masivo': 0.4,
            'Turismo Especializado': 0.6
        }

        factores_productividad = {
            'Agricultura Tradicional': 0.5,
            'Agricultura Tecnificada': 0.8,
            'Minería Básica': 0.4,
            'Minería Tecnológica': 0.9,
            'Manufactura Básica': 0.7,
            'Manufactura Avanzada': 1.0,
            'Servicios Básicos': 0.6,
            'Servicios Financieros': 0.9,
            'Servicios Tecnológicos': 1.1,
            'Turismo Masivo': 0.5,
            'Turismo Especializado': 0.7
        }

        return factores_innovacion, factores_productividad

"""# =============================================
# CLASES DE AGENTES DEL MODELO
# =============================================
"""

class Producto:
    """Representa un producto o servicio generado en una región"""

    def __init__(self, tipo_sector: str, id_producto: int):
        self.id = id_producto
        self.tipo_sector = tipo_sector
        parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)

        self.ingresos = np.random.uniform(*parametros['rango_productos'])
        self.costos = np.random.uniform(0.4, 0.8) * self.ingresos
        self.produccion = np.random.uniform(3, 16)
        self.intensidad_tecnologica = np.random.uniform(0.1, parametros['intensidad_conocimiento'])
        self.habilidad_requerida = np.random.uniform(*parametros['requisitos_habilidades'])
        self.id_sector = np.random.choice(ConfiguracionSectores.obtener_tipos_sectores()[tipo_sector])

    def calcular_margen(self) -> float:
        """Calcula el margen de ganancia del producto"""
        return (self.ingresos - self.costos) / self.ingresos

class Trabajador:
    """Representa un trabajador con habilidades específicas"""

    def __init__(self, tipo_sector: Optional[str] = None):
        if tipo_sector:
            parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
            rango_requisitos = parametros['requisitos_habilidades']
            self.habilidad = np.random.uniform(
                max(0.1, rango_requisitos[0] - 0.2),
                min(1.0, rango_requisitos[1] + 0.1)
            )
            self.habilidad_especializada = random.uniform(0.5, 1.1)
        else:
            self.habilidad = np.random.uniform(0.1, 0.6)
            self.habilidad_especializada = 0.0

        self.empleado = False
        self.id_region = None
        self.region = None
        self.tipo_sector = tipo_sector
        self.experiencia = 0
        self.salario = 0.0
        self.productividad = 0.0

    def mejorar_habilidades(self, inversion_capacitacion: float, exposicion_tecnologica: float):
        """Mejora las habilidades del trabajador a través de capacitación y exposición tecnológica"""
        efecto_capacitacion = 0.4 * (1 - np.exp(-1.5 * inversion_capacitacion))
        efecto_tecnologia = 0.5 * (1 - np.exp(-1.0 * exposicion_tecnologica))
        factor_individual = np.random.uniform(0.7, 1.0)
        factor_experiencia = 1 + np.log1p(self.experiencia) * 0.05

        ganancia_habilidad = (efecto_capacitacion + efecto_tecnologia) * factor_individual * factor_experiencia * ParametrosGlobales.TASA_APRENDIZAJE * 0.66
        self.habilidad = np.clip(self.habilidad + ganancia_habilidad, 0.1, 1.0)

        # Penalización por cambios tecnológicos rápidos
        if hasattr(self, 'region') and self.region is not None:
            if hasattr(self.region, 'capacidad_tecnologica') and hasattr(self.region, 'historial_capacidad_tecnologica'):
                if len(self.region.historial_capacidad_tecnologica) > 1:
                    tasa_cambio_tec = abs(self.region.capacidad_tecnologica - self.region.historial_capacidad_tecnologica[-2])
                    if tasa_cambio_tec > 0.02:
                        self.habilidad = max(0.1, self.habilidad * 0.98)

class FuerzaLaboral:
    """Representa la fuerza laboral de una región en un sector específico"""

    def __init__(self, tipo_sector: str, id_region: int):
        self.parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
        self.trabajadores = []
        self.tipo_sector = tipo_sector
        self.id_region = id_region
        self.region = None
        self.inversion_capacitacion = self.parametros['inversion_capacitacion'] * 0.7
        self.requisitos_habilidades = np.random.uniform(*self.parametros['requisitos_habilidades'])
        self.habilidad_especializada_minima = 0.6
        self.habilidad_promedio = 0.0
        self.habilidad_especializada_promedio = 0.0
        self.brecha_calificacion = self.requisitos_habilidades
        self.decadencia_experiencia = 0.01

    def actualizar_metricas(self):
        """Actualiza las métricas de la fuerza laboral"""
        capacidad_tecnologica = 0.12
        if hasattr(self, 'region') and self.region is not None:
            capacidad_tecnologica = getattr(self.region, 'capacidad_tecnologica', capacidad_tecnologica)
        factor_tec = 1 + capacidad_tecnologica

        # Los requisitos crecen con la capacidad tecnológica, pero con saturación
        requisito_base = np.random.uniform(*self.parametros['requisitos_habilidades'])
        self.requisitos_habilidades = np.clip(
            requisito_base * (1 + 0.75 * capacidad_tecnologica),
            self.parametros['requisitos_habilidades'][0],
            self.parametros['requisitos_habilidades'][1] * 1.5
        )

        if self.trabajadores:
            self.habilidad_promedio = np.mean([t.habilidad for t in self.trabajadores])
            self.habilidad_especializada_promedio = np.mean([t.habilidad_especializada for t in self.trabajadores])
            brecha = max(0, self.requisitos_habilidades - self.habilidad_promedio)
            # Brecha amplificada por baja absorción
            self.brecha_calificacion = brecha * (1 + 0.4 * np.random.uniform(-0.5, 0.5) * self.parametros['volatilidad'])
        else:
            self.habilidad_promedio = 0.0
            self.habilidad_especializada_promedio = 0.0
            self.brecha_calificacion = self.requisitos_habilidades

    def contratar_trabajadores(self, numero_trabajadores: int, pool_trabajadores: List[Trabajador]) -> int:
        """Contrata trabajadores del pool disponible"""
        if numero_trabajadores <= 0:
            return 0

        contratados = 0
        trabajadores_disponibles = [t for t in pool_trabajadores if not t.empleado]

        # Priorizar especializados, pero con costo de adaptación
        trabajadores_especializados = [t for t in trabajadores_disponibles if t.tipo_sector == self.tipo_sector]
        for trabajador in trabajadores_especializados[:min(numero_trabajadores - contratados, len(trabajadores_especializados))]:
            trabajador.empleado = True
            trabajador.id_region = self.id_region
            trabajador.region = self.region
            trabajador.habilidad = max(trabajador.habilidad * 0.9, trabajador.habilidad - 0.05)  # Pérdida en transición
            self.trabajadores.append(trabajador)
            contratados += 1

        # Contratar trabajadores generales si es necesario
        restantes = numero_trabajadores - contratados
        if restantes > 0:
            trabajadores_generales = [t for t in trabajadores_disponibles if t not in trabajadores_especializados]
            for trabajador in trabajadores_generales[:min(restantes, len(trabajadores_generales))]:
                trabajador.empleado = True
                trabajador.id_region = self.id_region
                trabajador.region = self.region
                trabajador.tipo_sector = self.tipo_sector
                trabajador.habilidad = max(0.1, trabajador.habilidad * 0.7)  # Reset parcial de habilidad
                self.trabajadores.append(trabajador)
                contratados += 1

        self.actualizar_metricas()
        return contratados

    def despedir_trabajadores(self, numero_trabajadores: int) -> int:
        """Despide trabajadores (los de menor habilidad primero)"""
        if not self.trabajadores or numero_trabajadores <= 0:
            return 0

        self.trabajadores.sort(key=lambda t: t.habilidad + t.habilidad_especializada)
        despedidos = 0
        for _ in range(min(numero_trabajadores, len(self.trabajadores))):
            trabajador = self.trabajadores.pop(0)
            trabajador.empleado = False
            trabajador.id_region = None
            trabajador.region = None
            despedidos += 1

        self.actualizar_metricas()
        return despedidos

    def ajustar_fuerza_laboral(self, trabajadores_requeridos: int, pool_trabajadores: List[Trabajador]):
        """Ajusta el tamaño de la fuerza laboral"""
        actual = len(self.trabajadores)
        if actual < trabajadores_requeridos:
            self.contratar_trabajadores(trabajadores_requeridos - actual, pool_trabajadores)
        elif actual > trabajadores_requeridos:
            self.despedir_trabajadores(actual - trabajadores_requeridos)

    def evaluar_trabajadores(self) -> int:
        """Evalúar y despedir trabajadores con habilidades muy por debajo del promedio"""
        umbral = self.requisitos_habilidades * 0.65
        a_despedir = [t for t in self.trabajadores if t.habilidad < umbral]
        for trabajador in a_despedir:
            self.trabajadores.remove(trabajador)
            trabajador.empleado = False
            trabajador.id_region = None
            trabajador.region = None
        self.actualizar_metricas()
        return len(a_despedir)

class Corporacion:
    """Representa una corporación con capacidad productiva y tecnológica"""

    def __init__(self, id_corporacion: int, tipo_sector: str, id_region: int):
        self.id = id_corporacion
        self.tipo_sector = tipo_sector
        self.id_region = id_region
        self.region = None

        # Parámetros específicos del sector (primero)
        self.parametros_sector = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
        self.inversion_tecnologia_objetivo = self.parametros_sector['inversion_tec']

        # Capacidades tecnológicas
        self.capacidad_tecnologica = ParametrosGlobales.NIVEL_TECNOLOGICO_INICIAL
        self.inversion_id = 0.0
        self.productos = []
        self.capacidad_produccion = np.random.uniform(50, 200)
        self.utilidades = 0.0
        self.margen_beneficio = 0.0
        self.volatilidad_mercado = self._obtener_volatilidad_sector()

    def _obtener_volatilidad_sector(self) -> float:
        """Obtiene la volatilidad específica del sector"""
        return self.parametros_sector['volatilidad']

    def producir(self, demanda_mercado: float = 1.0) -> Dict[str, float]:
        """Ejecuta el proceso de producción"""
        # Calcular nivel de producción basado en capacidad y demanda
        factor_demanda = min(1.0, demanda_mercado / self.capacidad_produccion)
        produccion_real = self.capacidad_produccion * factor_demanda

        # Calcular productividad basada en tecnología y trabajadores
        if self.region and hasattr(self.region, 'fuerzas_laborales'):
            fuerza_laboral = self.region.fuerzas_laborales.get(self.tipo_sector)
            if fuerza_laboral:
                productividad_trabajadores = fuerza_laboral.habilidad_promedio
            else:
                productividad_trabajadores = 0.5
        else:
            productividad_trabajadores = 0.5

        factor_tecnologico = 1 + self.capacidad_tecnologica * 0.3
        factor_productividad = productividad_trabajadores * 0.6 + factor_tecnologico * 0.4

        produccion_ajustada = produccion_real * factor_productividad

        # Calcular ingresos y costos
        precio_unitario = self.parametros_sector['productividad'] / 10  # Simplificación
        ingresos_totales = produccion_ajustada * precio_unitario
        costos_operativos = produccion_ajustada * precio_unitario * 0.6  # 40% margen

        self.utilidades = ingresos_totales - costos_operativos
        self.margen_beneficio = (ingresos_totales - costos_operativos) / ingresos_totales if ingresos_totales > 0 else 0

        return {
            'produccion': produccion_ajustada,
            'ingresos': ingresos_totales,
            'costos': costos_operativos,
            'utilidades': self.utilidades,
            'margen': self.margen_beneficio
        }

    def innovar(self, conocimiento_externo: float = 0.0) -> bool:
        """Ejecuta proceso de innovación"""
        # Capacidad de innovación base del sector
        capacidad_base = self.parametros_sector['capacidad_innovacion']

        # Aplicar factores tipológicos si están disponibles
        factor_tipologico = 1.0
        if hasattr(self, 'region') and self.region and hasattr(self.region, 'parametros_tipologicos'):
            if self.region.parametros_tipologicos.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
                factor_tipologico = 0.6  # Regiones atrapadas tienen menor capacidad de innovación
            elif self.region.parametros_tipologicos.tipo_region_economica == TipoRegionEconomica.NO_ATRAPADA:
                factor_tipologico = 1.4  # Regiones no atrapadas tienen mayor capacidad de innovación

        # Factores que afectan la innovación
        factor_utilidades = max(0, self.utilidades / 1000)  # Normalizar
        factor_conocimiento = conocimiento_externo * ParametrosGlobales.FACTOR_CAPACIDAD_ABSORCION
        factor_educacion = getattr(self.region, 'inversion_educacion', 0.1) if self.region else 0.1

        # Probabilidad de innovación
        probabilidad_innovacion = (
            ParametrosGlobales.TASA_INNOVACION_BASE *
            capacidad_base *
            factor_tipologico *  # Aplicar factor tipológico
            (1 + factor_utilidades) *
            (1 + factor_conocimiento) *
            (1 + factor_educacion)
        )

        # Ejecutar innovación
        if random.random() < probabilidad_innovacion:
            # Mejora tecnológica
            mejora_tecnologica = np.random.uniform(0.01, 0.05) * capacidad_base * factor_tipologico
            self.capacidad_tecnologica = min(1.0, self.capacidad_tecnologica + mejora_tecnologica)

            # Crear nuevo producto
            nuevo_producto = Producto(self.tipo_sector, len(self.productos))
            self.productos.append(nuevo_producto)

            return True
        return False

class Region:
    """Representa una región económica con características geográficas específicas Y tipología económica"""

    def __init__(self, id_region: int, tipo_region: TipoRegion):
        self.id = id_region
        self.tipo_region = tipo_region
        self.caracteristicas = self._configurar_caracteristicas_regionales()

        self.tipo_region_economica = self._asignar_tipologia_economica()
        self.parametros_tipologicos = ConfiguracionTipologias.obtener_parametros_tipologicos()[self.tipo_region_economica]

        # Estado económico
        self.capacidad_tecnologica = self.parametros_tipologicos.capacidad_tecnologica_base
        self.historial_capacidad_tecnologica = [self.capacidad_tecnologica]
        self.etapa_economica = EtapaEconomica.SUBSISTENCIA
        self.diversidad_sectorial = self.parametros_tipologicos.diversidad_base
        self.productividad_promedio = 0.0

        # Estructura económica
        self.fuerzas_laborales: Dict[str, FuerzaLaboral] = {}
        self.corporaciones: List[Corporacion] = []
        self.sectores_activos = []
        self.pool_trabajadores = []

        # Métricas de coordinación
        self.coordinacion_inter_sectorial = 0.5
        self.flujos_comerciales = 0.0
        self.inversion_extranjera_recibida = 0.0

        # Parámetros de aglomeración y transición
        self.tipo_aglomeracion = self._determinar_tipo_aglomeracion()
        self.parametros_aglomeracion = ConfiguracionAglomeraciones.obtener_parametros_aglomeracion()[self.tipo_aglomeracion]
        self.matriz_transicion = ConfiguracionAglomeraciones.obtener_matrices_transicion()[self.tipo_aglomeracion]
        self.factores_innovacion, self.factores_productividad = ConfiguracionSectores.obtener_factores_sectoriales()

        # Inicializar estructura económica
        self._inicializar_estructura_economica()

    def _asignar_tipologia_economica(self) -> TipoRegionEconomica:
        """
        Asigna tipología económica
        75% regiones atrapadas (alta especialización), 25% regiones no atrapadas (especialización moderada/intermedia)
        """
        # Distribución 75-25
        if self.id % 4 == 0 or self.id % 4 == 1 or self.id % 4 == 2:
            return TipoRegionEconomica.ATRAPADA
        else:
            return TipoRegionEconomica.NO_ATRAPADA

    def _configurar_caracteristicas_regionales(self) -> CaracteristicasRegionales:
        """Configura las características específicas según el tipo de región"""
        if self.tipo_region == TipoRegion.NORESTE:
            # Noreste: Mejor economía por Nuevo León, industrializado
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.85,  # Alto por Nuevo León
                cercania_eeuu=0.95,        # Muy alto (frontera)
                riqueza_natural=0.4,
                clima_aridez=0.6,
                rezago_social=0.15,        # Muy bajo
                conectividad_transport=0.85, # Alto
                inversion_extranjera=0.8   # Alto
            )
        elif self.tipo_region == TipoRegion.NOROESTE:
            # Noroeste: Fronterizo, clima árido, mejor economía regional
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.7,
                cercania_eeuu=0.9,
                riqueza_natural=0.3,
                clima_aridez=0.8,
                rezago_social=0.25,
                conectividad_transport=0.75,
                inversion_extranjera=0.75
            )
        elif self.tipo_region == TipoRegion.OCCIDENTE:
            # Occidente: Mejor por Jalisco, variada
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.7,   # Mejorado por Jalisco
                cercania_eeuu=0.6,
                riqueza_natural=0.7,       # Rica en recursos
                clima_aridez=0.4,
                rezago_social=0.4,         # Moderado
                conectividad_transport=0.75,
                inversion_extranjera=0.7
            )
        elif self.tipo_region == TipoRegion.CENTRONORTE:
            # Centronorte: Intermedio, agricola, manufactura básica
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.65,
                cercania_eeuu=0.7,
                riqueza_natural=0.5,
                clima_aridez=0.5,
                rezago_social=0.45,
                conectividad_transport=0.7,
                inversion_extranjera=0.65
            )
        elif self.tipo_region == TipoRegion.ORIENTE:
            # Oriente: CDMX incluida, mix urbano-rural
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.8,   # Alto por CDMX
                cercania_eeuu=0.65,
                riqueza_natural=0.4,
                clima_aridez=0.3,
                rezago_social=0.35,         # Menor por CDMX
                conectividad_transport=0.9, # Muy alto
                inversion_extranjera=0.75
            )
        elif self.tipo_region == TipoRegion.SURESTE:
            # Sureste: Rica en recursos pero bajo desarrollo
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.35,  # Bajo pero mejor que suroeste
                cercania_eeuu=0.4,
                riqueza_natural=0.85,      # Muy rica
                clima_aridez=0.2,
                rezago_social=0.75,        # Alto
                conectividad_transport=0.4, # Bajo
                inversion_extranjera=0.25  # Bajo
            )
        else:  # SUROESTE
            # Suroeste: Mayor rezago social
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.2,   # Muy bajo
                cercania_eeuu=0.25,
                riqueza_natural=0.8,
                clima_aridez=0.1,
                rezago_social=0.9,         # Muy alto
                conectividad_transport=0.25, # Muy bajo
                inversion_extranjera=0.15  # Muy bajo
            )

    def _determinar_tipo_aglomeracion(self) -> str:
        """Determina el tipo de aglomeración regional basado en características"""
        # Clasificar por nivel de desarrollo y diversidad sectorial
        desarrollo = self.caracteristicas.desarrollo_economico
        diversidad_esperada = self.parametros_tipologicos.diversidad_base

        if desarrollo < 0.4:
            return 'C1'  # Baja diversidad-especialización
        elif desarrollo < 0.65:
            return 'C2'  # Media diversidad-especialización
        elif desarrollo < 0.8:
            return 'C3'  # Alta diversidad-especialización
        else:
            return 'C4'  # Sobre especialización

    def aplicar_transicion_sectorial(self, tipo_sector_actual: str, paso_tiempo: int):
        """Aplica la transición de Markov a los sectores según el tipo de aglomeración"""
        # Mapear tipo de sector a índice en la matriz
        sectores_orden = ['Primario_Bajo', 'Primario_Alto', 'Manufactura_Baja',
                         'Manufactura_Alta', 'Servicios_Bajos', 'Servicios_Intermedios',
                         'Servicios_Avanzados', 'Turismo_Masivo', 'Turismo_Especializado']

        if tipo_sector_actual not in sectores_orden:
            return tipo_sector_actual

        idx_actual = sectores_orden.index(tipo_sector_actual)
        probabilidades = self.matriz_transicion[idx_actual]

        # Seleccionar nuevo sector basado en probabilidades
        nuevo_idx = np.random.choice(len(probabilidades), p=probabilidades)
        nuevo_sector = sectores_orden[nuevo_idx]

        return nuevo_sector

    def aplicar_factores_sectoriales(self, tipo_sector: str, valor_base: float, tipo_factor: str = 'innovacion'):
        """Aplica factores de innovación o productividad específicos del sector"""
        factores = self.factores_innovacion if tipo_factor == 'innovacion' else self.factores_productividad

        # Mapear el tipo de sector al nombre completo en el diccionario
        sectores_mapping = {
            'Primario_Bajo': 'Agricultura Tradicional',
            'Primario_Alto': 'Agricultura Tecnificada',
            'Manufactura_Baja': 'Manufactura Básica',
            'Manufactura_Alta': 'Manufactura Avanzada',
            'Servicios_Bajos': 'Servicios Básicos',
            'Servicios_Intermedios': 'Servicios Financieros',
            'Servicios_Avanzados': 'Servicios Tecnológicos',
            'Turismo_Masivo': 'Turismo Masivo',
            'Turismo_Especializado': 'Turismo Especializado'
        }

        nombre_sector = sectores_mapping.get(tipo_sector, 'Servicios Básicos')
        factor = factores.get(nombre_sector, 0.5)

        return valor_base * factor

    def _inicializar_estructura_economica(self):
        """Inicializa la estructura económica de la región"""
        # Seleccionar sectores basados en características regionales
        sectores_recomendados = self._seleccionar_sectores_regionales()

        for tipo_sector in sectores_recomendados:
            # Crear fuerza laboral
            fuerza_laboral = FuerzaLaboral(tipo_sector, self.id)
            fuerza_laboral.region = self
            self.fuerzas_laborales[tipo_sector] = fuerza_laboral

            # Crear corporaciones
            num_corporaciones = np.random.randint(2, 6)
            for _ in range(num_corporaciones):
                corporacion = Corporacion(len(self.corporaciones), tipo_sector, self.id)
                corporacion.region = self
                self.corporaciones.append(corporacion)

            self.sectores_activos.append(tipo_sector)

        # Crear pool de trabajadores inicial
        self._crear_pool_trabajadores()

    def _seleccionar_sectores_regionales(self) -> List[str]:
        """Selecciona sectores apropiados según las características regionales"""
        sectores_disponibles = ConfiguracionSectores.obtener_sectores_disponibles()
        sectores_seleccionados = []

        # Lógica de selección basada en características regionales actualizadas
        if self.tipo_region == TipoRegion.NORESTE:
            # Noreste: Alta tecnología, manufactura avanzada (Nuevo León)
            sectores_preferidos = ['Manufactura_Alta', 'Servicios_Avanzados', 'Servicios_Intermedios']
        elif self.tipo_region == TipoRegion.NOROESTE:
            # Noroeste: Manufactura fronteriza, tecnología, servicios
            sectores_preferidos = ['Manufactura_Alta', 'Primario_Alto', 'Servicios_Intermedios']
        elif self.tipo_region == TipoRegion.OCCIDENTE:
            # Occidente: Manufactura, turismo, agroindustria (influencia de Jalisco)
            sectores_preferidos = ['Manufactura_Baja', 'Turismo_Especializado', 'Primario_Alto']
        elif self.tipo_region == TipoRegion.CENTRONORTE:
            # Centronorte: Manufactura, servicios, agroindustria
            sectores_preferidos = ['Manufactura_Baja', 'Primario_Alto', 'Servicios_Intermedios']
        elif self.tipo_region == TipoRegion.ORIENTE:
            # Oriente: Servicios, manufactura, turismo (CDMX)
            sectores_preferidos = ['Servicios_Avanzados', 'Servicios_Intermedios', 'Turismo_Especializado']
        elif self.tipo_region == TipoRegion.SURESTE:
            # Sureste: Primario, turismo masivo, algunos servicios
            sectores_preferidos = ['Primario_Alto', 'Turismo_Masivo', 'Servicios_Bajos']
        else:  # SUROESTE
            # Suroeste: Principalmente primario, poco diversificado
            sectores_preferidos = ['Primario_Bajo', 'Primario_Alto', 'Turismo_Masivo']

        # Ajustar selección según tipología económica
        if self.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
            # Regiones atrapadas: más especialización, menos diversificación
            sectores_preferidos = sectores_preferidos[:2] + [sectores_preferidos[0]]  # Duplicar el principal
        elif self.tipo_region_economica == TipoRegionEconomica.NO_ATRAPADA:
            # Regiones no atrapadas: más diversificación
            sectores_adicionales = ['Servicios_Avanzados', 'Manufactura_Alta'] if 'Servicios_Avanzados' not in sectores_preferidos else []
            sectores_preferidos.extend(sectores_adicionales)

        # Seleccionar sectores preferidos que existan
        for sector in sectores_preferidos:
            if sector in sectores_disponibles:
                sectores_seleccionados.append(sector)

        # Asegurar al menos 3 sectores
        while len(sectores_seleccionados) < 3 and sectores_disponibles:
            sector = random.choice(sectores_disponibles)
            if sector not in sectores_seleccionados:
                sectores_seleccionados.append(sector)

        return sectores_seleccionados[:5]  # Máximo 5 sectores por región

    def _crear_pool_trabajadores(self):
        """Crea el pool inicial de trabajadores para la región"""
        total_trabajadores = int(ParametrosGlobales.TAMAÑO_POOL_TRABAJADORES / 32)  # Distribución proporcional
        self.pool_trabajadores = []

        for _ in range(total_trabajadores):
            if self.sectores_activos:
                sector_aleatorio = random.choice(self.sectores_activos)
                trabajador = Trabajador(sector_aleatorio)
            else:
                trabajador = Trabajador()
            self.pool_trabajadores.append(trabajador)

    def calcular_productividad_regional(self) -> float:
        """Calcula la productividad promedio de la región"""
        if not self.corporaciones:
            return 0.0

        productividades = []
        for corporacion in self.corporaciones:
            if hasattr(corporacion, 'parametros_sector'):
                prod_base = corporacion.parametros_sector['productividad']
                factor_tec = 1 + self.capacidad_tecnologica * 0.2
                productividad = prod_base * factor_tec
                productividades.append(productividad)

        return np.mean(productividades) if productividades else 0.0

    def calcular_coordinacion_economica(self) -> float:
        """Calcula el índice de coordinación económica"""
        # Base de coordinación
        coordinacion_base = 0.5

        # Ajustar por tipología económica
        if self.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
            factor_ajuste = 0.8  # Menor coordinación en regiones atrapadas
        else:  # NO_ATRAPADA
            factor_ajuste = 1.2  # Mayor coordinación en regiones no atrapadas

        # Factores adicionales
        factor_desarrollo = self.caracteristicas.desarrollo_economico
        factor_conectividad = self.caracteristicas.conectividad_transport

        coordinacion = coordinacion_base * factor_ajuste * (1 + factor_desarrollo + factor_conectividad) / 3
        return np.clip(coordinacion, 0.1, 1.0)

    def calcular_diversidad_sectorial(self) -> float:
        """Calcula el índice de diversidad sectorial"""
        # Ajustar diversidad según tipología
        if self.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
            # Regiones atrapadas: menor diversidad
            diversidad_base = self.parametros_tipologicos.diversidad_base * 0.8
        else:  # NO_ATRAPADA
            # Regiones no atrapadas: mayor diversidad
            diversidad_base = self.parametros_tipologicos.diversidad_base * 1.2

        # Factor de número de sectores activos
        factor_sectores = min(1.0, len(self.sectores_activos) / 5.0)

        # Factor de distribución (más equitativa = más diversa)
        factor_distribucion = 0.8 + 0.2 * len(set(self.sectores_activos)) / len(self.sectores_activos)

        diversidad = diversidad_base * factor_sectores * factor_distribucion
        return np.clip(diversidad, 0.1, 1.0)

    def esta_en_trampa_innovacion(self) -> bool:
        """Determina si la región está en trampa de innovación"""
        # Umbral basado en evidencia empírica
        umbral_innovacion = 0.08
        umbral_especializacion = 0.60
        umbral_diversidad = 0.50

        # Criterios para trampa de innovación (regiones atrapadas)
        baja_innovacion = self.capacidad_tecnologica < umbral_innovacion
        alta_especializacion = self.parametros_tipologicos.especializacion_base > umbral_especializacion
        baja_diversidad = self.diversidad_sectorial < umbral_diversidad

        # Aplicar lógica tipológica
        if self.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
            # Regiones atrapadas: presumiblemente en trampa
            return baja_innovacion or (alta_especializacion and baja_diversidad)
        else:  # NO_ATRAPADA
            # Regiones no atrapadas: raramente en trampa
            return baja_innovacion and alta_especializacion and baja_diversidad

    def ejecutar_paso_simulacion(self, paso_tiempo: int) -> Dict:
        """Ejecuta un paso de simulación para la región"""
        resultados = {
            'id_region': self.id,
            'tipo_region': self.tipo_region.value,
            'tipo_region_economica_inicial': self.tipo_region_economica.value,
            'paso_tiempo': paso_tiempo,
            'capacidad_tecnologica': self.capacidad_tecnologica,
            'diversidad_sectorial': self.diversidad_sectorial,
            'productividad_promedio': self.productividad_promedio,
            'coordinacion_promedio': self.coordinacion_inter_sectorial,
            'innovaciones_realizadas': 0,
            'flujos_internos': 0.0,
            'empleo_especializado': 0,
            'empleo_total': 0,
            'eficiencia_asignacion': 0.0,
            'atrapada': self.esta_en_trampa_innovacion(),
            # MÉTRICAS ADICIONALES SOLICITADAS
            'tasa_innovacion': 0.0,
            'especializacion': 0.0,
            'actualizacion_tecnologica': 0.0,
            'brecha_calificacion': 0.0,
            'empleo_total_region': 0,
            'empleo_especializado_region': 0,
            # CARACTERÍSTICAS GEOGRÁFICAS ESPECÍFICAS DE MÉXICO
            'desarrollo_economico_geo': self.caracteristicas.desarrollo_economico,
            'cercania_frontera_eeuu': self.caracteristicas.cercania_eeuu,
            'riqueza_natural_geo': self.caracteristicas.riqueza_natural,
            'factor_aridez': self.caracteristicas.clima_aridez,
            'rezago_social_geo': self.caracteristicas.rezago_social,
            'conectividad_transport': self.caracteristicas.conectividad_transport,
            'inversion_extranjera_geo': self.caracteristicas.inversion_extranjera
        }

        # Actualizar capacidad tecnológica según parámetros tipológicos
        self.capacidad_tecnologica = max(
            0.01,
            self.capacidad_tecnologica * (1 - self.parametros_tipologicos.tasa_decaimiento_tech) +
            self.parametros_tipologicos.inercia_tech * 0.001
        )
        self.historial_capacidad_tecnologica.append(self.capacidad_tecnologica)

        # Actualizar diversidad sectorial
        self.diversidad_sectorial = self.calcular_diversidad_sectorial()

        # Calcular especialización (inversa de diversidad)
        especializacion = 1 - self.diversidad_sectorial

        # Actualizar métricas de corporaciones
        innovaciones_totales = 0
        total_corporaciones = len(self.corporaciones)
        for corporacion in self.corporaciones:
            # Producción
            produccion = corporacion.producir()

            # Innovación con factor tipológico
            innovacion = corporacion.innovar()
            if innovacion:
                innovaciones_totales += 1

        # Calcular tasa de innovación
        tasa_innovacion = innovaciones_totales / max(1, total_corporaciones)

        # Calcular actualización tecnológica
        if len(self.historial_capacidad_tecnologica) > 1:
            actualizacion_tec = abs(self.capacidad_tecnologica - self.historial_capacidad_tecnologica[-2])
        else:
            actualizacion_tec = 0.0

        # Actualizar métricas laborales
        empleo_especializado = 0
        empleo_total = 0
        brecha_calificacion_promedio = 0.0
        for fuerza_laboral in self.fuerzas_laborales.values():
            empleo_especializado += len(fuerza_laboral.trabajadores)
            empleo_total += len(fuerza_laboral.trabajadores)
            brecha_calificacion_promedio += fuerza_laboral.brecha_calificacion

        # Promediar brecha de calificación
        if self.fuerzas_laborales:
            brecha_calificacion_promedio = brecha_calificacion_promedio / len(self.fuerzas_laborales)

        # Calcular productividad regional
        self.productividad_promedio = self.calcular_productividad_regional()

        # Calcular coordinación
        self.coordinacion_inter_sectorial = self.calcular_coordinacion_economica()

        # Actualizar resultados
        resultados.update({
            'innovaciones_realizadas': innovaciones_totales,
            'empleo_especializado': empleo_especializado,
            'empleo_total': empleo_total,
            'empleo_especializado_region': empleo_especializado,
            'empleo_total_region': empleo_total,
            'eficiencia_asignacion': min(1.0, empleo_especializado / max(1, empleo_total)),
            'flujos_internos': self.flujos_comerciales,
            # MÉTRICAS ADICIONALES
            'tasa_innovacion': tasa_innovacion,
            'especializacion': especializacion,
            'actualizacion_tecnologica': actualizacion_tec,
            'brecha_calificacion': brecha_calificacion_promedio
        })

        return resultados

"""# =============================================
# MODELO ECONÓMICO REGIONAL
# =============================================
"""

class ModeloEconomicoRegional:
    """Modelo económico regional basado en agentes con tipologías integradas"""

    def __init__(self, num_regiones: int = 32):
        self.num_regiones = num_regiones
        self.regiones: List[Region] = []
        self.resultados_simulacion: List[Dict] = []
        self.parametros_tipologicos = ConfiguracionTipologias.obtener_parametros_tipologicos()

        # Inicializar regiones
        self._inicializar_regiones()

    def _inicializar_regiones(self):
        """Inicializa las regiones del modelo"""
        tipos_region = list(TipoRegion)

        for i in range(self.num_regiones):
            tipo_region = tipos_region[i % len(tipos_region)]
            region = Region(i, tipo_region)
            self.regiones.append(region)

    def ejecutar_simulacion(self, num_pasos: int = 60) -> pd.DataFrame:
        """Ejecuta la simulación completa"""
        print(f"Iniciando simulación con {len(self.regiones)} regiones por {num_pasos} pasos...")

        for paso in range(num_pasos):
            if paso % 10 == 0:
                print(f"Ejecutando paso {paso}/{num_pasos}")

            for region in self.regiones:
                resultado = region.ejecutar_paso_simulacion(paso)
                self.resultados_simulacion.append(resultado)

        # Convertir a DataFrame
        df_resultados = pd.DataFrame(self.resultados_simulacion)
        print(f"Simulación completada. {len(df_resultados)} registros generados.")

        return df_resultados

    def analizar_politicas_cyt_regional(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas C&T a nivel regional con tipologías"""
        analisis = {}

        for tipo_region in resultados['tipo_region'].unique():
            datos_region = resultados[resultados['tipo_region'] == tipo_region]

            # Obtener tipología económica predominante
            tipologias = datos_region['tipo_region_economica_inicial'].value_counts()
            tipologia_predominante = tipologias.index[0] if len(tipologias) > 0 else 'Desconocida'

            analisis[tipo_region] = {
                'metricas_cyt': {
                    'capacidad_tecnologica_promedio': datos_region['capacidad_tecnologica'].mean(),
                    'innovaciones_total': datos_region['innovaciones_realizadas'].sum(),
                    'innovaciones_promedio': datos_region['innovaciones_realizadas'].mean(),
                    'tasa_innovacion_promedio': datos_region['tasa_innovacion'].mean(),
                    'actualizacion_tecnologica_promedio': datos_region['actualizacion_tecnologica'].mean(),
                    'coordinacion_economica': datos_region['coordinacion_promedio'].mean(),
                    'flujos_conocimiento_interno': datos_region['flujos_internos'].mean(),
                    'eficiencia_asignacion': datos_region['eficiencia_asignacion'].mean(),
                    'porcentaje_atrapadas': datos_region['atrapada'].mean() * 100
                },
                'metricas_especializacion_diversificacion': {
                    'diversidad_sectorial_promedio': datos_region['diversidad_sectorial'].mean(),
                    'especializacion_promedio': datos_region['especializacion'].mean(),
                    'diversidad_sectorial_std': datos_region['diversidad_sectorial'].std(),
                    'especializacion_std': datos_region['especializacion'].std()
                },
                'metricas_empleo': {
                    'empleo_total_promedio': datos_region['empleo_total'].mean(),
                    'empleo_especializado_promedio': datos_region['empleo_especializado'].mean(),
                    'empleo_especializado_total_promedio': datos_region['empleo_especializado_region'].mean(),
                    'empleo_total_region_promedio': datos_region['empleo_total_region'].mean(),
                    'ratio_especializado_total': (datos_region['empleo_especializado'].mean() /
                                                max(1, datos_region['empleo_total'].mean()))
                },
                'metricas_productividad': {
                    'productividad_promedio': datos_region['productividad_promedio'].mean(),
                    'productividad_std': datos_region['productividad_promedio'].std(),
                    'productividad_min': datos_region['productividad_promedio'].min(),
                    'productividad_max': datos_region['productividad_promedio'].max(),
                    'productividad_por_innovacion': (datos_region['tasa_innovacion'].mean() /
                                                   max(0.01, datos_region['productividad_promedio'].mean())),
                    'productividad_tecnologica': (datos_region['productividad_promedio'].mean() /
                                                max(0.01, datos_region['capacidad_tecnologica'].mean())),
                    'eficiencia_empleo_productivo': (datos_region['productividad_promedio'].mean() /
                                                    max(0.01, datos_region['empleo_especializado'].mean())),
                    'indice_productividad_regional': datos_region['productividad_promedio'].mean() / datos_region['productividad_promedio'].std()
                },
                'metricas_calificacion': {
                    'brecha_calificacion_promedio': datos_region['brecha_calificacion'].mean(),
                    'brecha_calificacion_std': datos_region['brecha_calificacion'].std(),
                    'brecha_calificacion_min': datos_region['brecha_calificacion'].min(),
                    'brecha_calificacion_max': datos_region['brecha_calificacion'].max()
                },
                'condiciones_entorno': {
                    'carencias_educativas': 1 - datos_region['coordinacion_promedio'].mean(),
                    'nivel_diversificacion': datos_region['diversidad_sectorial'].mean(),
                    'nivel_especializacion': 1 - datos_region['diversidad_sectorial'].mean(),
                    'capacidad_absorcion': datos_region['coordinacion_promedio'].mean() * 0.8,
                    'efectividad_sistema_innovacion': datos_region['innovaciones_realizadas'].mean() / max(0.01, datos_region['capacidad_tecnologica'].mean())
                },
                'tipologia_economica': tipologia_predominante,
                'politicas_recomendadas': self._generar_politicas_regionales(tipologia_predominante, datos_region)
            }

        return analisis

    def analizar_politicas_cyt_sectorial(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas C&T a nivel sectorial"""
        # Simulación de análisis sectorial basado en los datos disponibles
        sectores_simulados = ['Manufactura_Alta', 'Servicios_Avanzados', 'Primario_Alto', 'Servicios_Intermedios', 'Turismo_Especializado']
        analisis = {}

        for sector in sectores_simulados:
            # Simular datos sectoriales
            datos_sector = resultados.sample(min(50, len(resultados)//2))  # Simular presencia sectorial

            analisis[sector] = {
                'metricas_cyt': {
                    'regiones_con_sector': len(datos_sector),
                    'innovaciones_promedio': datos_sector['innovaciones_realizadas'].mean(),
                    'tasa_innovacion_promedio': datos_sector['tasa_innovacion'].mean(),
                    'actualizacion_tecnologica_promedio': datos_sector['actualizacion_tecnologica'].mean(),
                    'productividad_promedio': datos_sector['productividad_promedio'].mean(),
                    'coordinacion_interregional': datos_sector['coordinacion_promedio'].mean(),
                    'capacidad_tecnologica': datos_sector['capacidad_tecnologica'].mean()
                },
                'especializacion_diversificacion': {
                    'grado_especializacion': np.random.uniform(0.3, 0.8),
                    'grado_diversificacion': datos_sector['diversidad_sectorial'].mean(),
                    'concentracion_geografica': np.random.uniform(0.2, 0.7),
                    'difusion_tecnologica': np.random.uniform(0.4, 0.9),
                    'especializacion_sectorial': datos_sector['especializacion'].mean()
                },
                'empleo_sectorial': {
                    'empleo_total_promedio': datos_sector['empleo_total'].mean(),
                    'empleo_especializado_promedio': datos_sector['empleo_especializado'].mean(),
                    'ratio_especializado_total': (datos_sector['empleo_especializado'].mean() /
                                                max(1, datos_sector['empleo_total'].mean()))
                },
                'metricas_productividad': {
                    'productividad_regional_promedio': datos_sector['productividad_promedio'].mean(),
                    'productividad_regional_std': datos_sector['productividad_promedio'].std(),
                    'productividad_por_empleado': (datos_sector['productividad_promedio'].mean() /
                                                 max(0.01, datos_sector['empleo_especializado'].mean())),
                    'productividad_por_innovacion': (datos_sector['productividad_promedio'].mean() /
                                                    max(0.01, datos_sector['tasa_innovacion'].mean())),
                    'productividad_tecnologica': (datos_sector['productividad_promedio'].mean() /
                                                max(0.01, datos_sector['capacidad_tecnologica'].mean())),
                    'eficiencia_productiva_sectorial': datos_sector['productividad_promedio'].mean() / datos_sector['coordinacion_promedio'].mean(),
                    'indice_competitividad_sectorial': (datos_sector['productividad_promedio'].mean() *
                                                      datos_sector['tasa_innovacion'].mean()) / max(0.01, datos_sector['brecha_calificacion'].mean())
                },
                'calificacion_trabajo': {
                    'brecha_calificacion_promedio': datos_sector['brecha_calificacion'].mean(),
                    'brecha_calificacion_std': datos_sector['brecha_calificacion'].std(),
                    'eficiencia_asignacion': datos_sector['eficiencia_asignacion'].mean()
                },
                'regiones_predominantes': dict(zip(
                    resultados['tipo_region'].unique()[:3],
                    np.random.uniform(0.1, 0.5, 3)
                ))
            }

        return analisis

    def analizar_politicas_cyt_corporativo(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas C&T a nivel corporativo"""
        analisis = {
            'por_tamaño_corporativo': {},
            'por_tecnologia': {},
            'por_especializacion': {},
            'por_calificacion': {}
        }

        # Análisis por tamaño corporativo simulado
        for tipo_region in resultados['tipo_region'].unique()[:4]:  # Top 4 regiones
            datos_region = resultados[resultados['tipo_region'] == tipo_region]
            analisis['por_tamaño_corporativo'][tipo_region] = {
                'corporaciones_grandes': np.random.randint(15, 40),
                'corporaciones_pequeñas': np.random.randint(50, 120),
                'ratio_grandes_pequenas': np.random.uniform(0.2, 0.5),
                'capacidades_promedio_grandes': np.random.uniform(0.6, 0.9),
                'capacidades_promedio_pequeñas': np.random.uniform(0.3, 0.7),
                'innovaciones_grandes': np.random.uniform(2, 15),
                'innovaciones_pequeñas': np.random.uniform(0.5, 5),
                'empleo_total_regional': datos_region['empleo_total'].mean(),
                'empleo_especializado_regional': datos_region['empleo_especializado'].mean(),
                'productividad_grandes': np.random.uniform(0.6, 0.9),
                'productividad_pequeñas': np.random.uniform(0.3, 0.7),
                'metricas_productividad': {
                    'productividad_regional_promedio': datos_region['productividad_promedio'].mean(),
                    'productividad_por_empleado_grande': np.random.uniform(0.6, 0.9) / max(0.01, datos_region['empleo_especializado'].mean()),
                    'productividad_por_empleado_pequena': np.random.uniform(0.3, 0.7) / max(0.01, datos_region['empleo_total'].mean()),
                    'eficiencia_productiva_grandes': np.random.uniform(0.6, 0.9) / datos_region['brecha_calificacion'].mean(),
                    'eficiencia_productiva_pequenas': np.random.uniform(0.3, 0.7) / datos_region['brecha_calificacion'].mean(),
                    'productividad_innovativa_grandes': np.random.uniform(0.6, 0.9) / max(0.01, datos_region['tasa_innovacion'].mean()),
                    'productividad_innovativa_pequenas': np.random.uniform(0.3, 0.7) / max(0.01, datos_region['tasa_innovacion'].mean()),
                    'indice_competitividad_corporativo': (datos_region['productividad_promedio'].mean() *
                                                        datos_region['tasa_innovacion'].mean()) / max(0.01, datos_region['brecha_calificacion'].mean())
                }
            }

        # Análisis por nivel tecnológico simulado
        niveles_tech = ['Alta_Tecnologia', 'Media_Tecnologia', 'Baja_Tecnologia']
        for nivel in niveles_tech:
            datos_simulados = resultados.sample(min(30, len(resultados)//3))
            analisis['por_tecnologia'][nivel] = {
                'regiones_con_tecnologia': np.random.randint(8, 20),
                'innovaciones_promedio': np.random.uniform(2, 15),
                'tasa_innovacion_promedio': datos_simulados['tasa_innovacion'].mean(),
                'actualizacion_tecnologica_promedio': datos_simulados['actualizacion_tecnologica'].mean(),
                'coordinacion_promedio': np.random.uniform(0.4, 0.8),
                'productividad_promedio': np.random.uniform(0.3, 0.9),
                'tasa_atrapamiento': np.random.uniform(10, 60),
                'empleo_total': datos_simulados['empleo_total'].mean(),
                'empleo_especializado': datos_simulados['empleo_especializado'].mean(),
                'ratio_especializado': (datos_simulados['empleo_especializado'].mean() /
                                       max(1, datos_simulados['empleo_total'].mean())),
                'metricas_productividad': {
                    'productividad_regional_promedio': datos_simulados['productividad_promedio'].mean(),
                    'productividad_por_empleo_especializado': (datos_simulados['productividad_promedio'].mean() /
                                                              max(0.01, datos_simulados['empleo_especializado'].mean())),
                    'productividad_por_innovacion': (datos_simulados['productividad_promedio'].mean() /
                                                   max(0.01, datos_simulados['tasa_innovacion'].mean())),
                    'productividad_tecnologica': (datos_simulados['productividad_promedio'].mean() /
                                                max(0.01, datos_simulados['capacidad_tecnologica'].mean())),
                    'eficiencia_productiva': datos_simulados['productividad_promedio'].mean() / datos_simulados['brecha_calificacion'].mean(),
                    'indice_conversion_innovacion': (datos_simulados['tasa_innovacion'].mean() *
                                                   datos_simulados['productividad_promedio'].mean()) / max(0.01, datos_simulados['actualizacion_tecnologica'].mean()),
                    'productividad_ajustada_tecnologia': np.random.uniform(0.3, 0.9) * (1 + datos_simulados['actualizacion_tecnologica'].mean())
                }
            }

        # Análisis por nivel de especialización
        analisis['por_especializacion'] = {
            'Alta_Especializacion': {
                'regiones_con_alta_esp': len(resultados[resultados['especializacion'] > 0.7]),
                'diversidad_promedio': resultados[resultados['especializacion'] > 0.7]['diversidad_sectorial'].mean(),
                'innovaciones_promedio': resultados[resultados['especializacion'] > 0.7]['innovaciones_realizadas'].mean(),
                'productividad_promedio': resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean(),
                'empleo_especializado_ratio': (resultados[resultados['especializacion'] > 0.7]['empleo_especializado'].mean() /
                                              max(1, resultados[resultados['especializacion'] > 0.7]['empleo_total'].mean())),
                'metricas_productividad': {
                    'productividad_regional_promedio': resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean(),
                    'productividad_por_empleo': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() /
                                                max(0.01, resultados[resultados['especializacion'] > 0.7]['empleo_especializado'].mean())),
                    'productividad_especializada': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() *
                                                  resultados[resultados['especializacion'] > 0.7]['especializacion'].mean()),
                    'eficiencia_especializacion_productiva': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() /
                                                             max(0.01, resultados[resultados['especializacion'] > 0.7]['brecha_calificacion'].mean())),
                    'productividad_innovacion_especializada': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() /
                                                             max(0.01, resultados[resultados['especializacion'] > 0.7]['tasa_innovacion'].mean())),
                    'indice_ventaja_competitiva': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() *
                                                  resultados[resultados['especializacion'] > 0.7]['especializacion'].mean()) / max(0.01, resultados[resultados['especializacion'] > 0.7]['diversidad_sectorial'].mean())
                }
            },
            'Baja_Especializacion': {
                'regiones_con_baja_esp': len(resultados[resultados['especializacion'] < 0.3]),
                'diversidad_promedio': resultados[resultados['especializacion'] < 0.3]['diversidad_sectorial'].mean(),
                'innovaciones_promedio': resultados[resultados['especializacion'] < 0.3]['innovaciones_realizadas'].mean(),
                'productividad_promedio': resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean(),
                'empleo_especializado_ratio': (resultados[resultados['especializacion'] < 0.3]['empleo_especializado'].mean() /
                                              max(1, resultados[resultados['especializacion'] < 0.3]['empleo_total'].mean())),
                'metricas_productividad': {
                    'productividad_regional_promedio': resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean(),
                    'productividad_por_empleo': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() /
                                                max(0.01, resultados[resultados['especializacion'] < 0.3]['empleo_especializado'].mean())),
                    'productividad_diversificada': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() *
                                                  resultados[resultados['especializacion'] < 0.3]['diversidad_sectorial'].mean()),
                    'eficiencia_diversificacion_productiva': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() /
                                                             max(0.01, resultados[resultados['especializacion'] < 0.3]['brecha_calificacion'].mean())),
                    'productividad_innovacion_diversificada': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() /
                                                             max(0.01, resultados[resultados['especializacion'] < 0.3]['tasa_innovacion'].mean())),
                    'indice_flexibilidad_productiva': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() *
                                                     resultados[resultados['especializacion'] < 0.3]['diversidad_sectorial'].mean()) / max(0.01, resultados[resultados['especializacion'] < 0.3]['especializacion'].mean())
                }
            }
        }

        # Análisis por brecha de calificación
        analisis['por_calificacion'] = {
            'Baja_Brecha_Calificacion': {
                'regiones_con_baja_brecha': len(resultados[resultados['brecha_calificacion'] < 0.5]),
                'brecha_calificacion_promedio': resultados[resultados['brecha_calificacion'] < 0.5]['brecha_calificacion'].mean(),
                'innovaciones_promedio': resultados[resultados['brecha_calificacion'] < 0.5]['innovaciones_realizadas'].mean(),
                'productividad_promedio': resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean(),
                'eficiencia_asignacion': resultados[resultados['brecha_calificacion'] < 0.5]['eficiencia_asignacion'].mean(),
                'metricas_productividad': {
                    'productividad_regional_promedio': resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean(),
                    'productividad_ajustada_capacidades': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() /
                                                          max(0.01, resultados[resultados['brecha_calificacion'] < 0.5]['brecha_calificacion'].mean())),
                    'eficiencia_capital_humano': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() *
                                                (1 - resultados[resultados['brecha_calificacion'] < 0.5]['brecha_calificacion'].mean())),
                    'productividad_innovacion_capacidades': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() /
                                                           max(0.01, resultados[resultados['brecha_calificacion'] < 0.5]['tasa_innovacion'].mean())),
                    'indice_efectividad_capital_humano': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() *
                                                        (1 - resultados[resultados['brecha_calificacion'] < 0.5]['brecha_calificacion'].mean()) *
                                                        resultados[resultados['brecha_calificacion'] < 0.5]['eficiencia_asignacion'].mean()),
                    'productividad_tecnologica_capacitada': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() *
                                                           (1 + resultados[resultados['brecha_calificacion'] < 0.5]['capacidad_tecnologica'].mean()))
                }
            },
            'Alta_Brecha_Calificacion': {
                'regiones_con_alta_brecha': len(resultados[resultados['brecha_calificacion'] > 0.7]),
                'brecha_calificacion_promedio': resultados[resultados['brecha_calificacion'] > 0.7]['brecha_calificacion'].mean(),
                'innovaciones_promedio': resultados[resultados['brecha_calificacion'] > 0.7]['innovaciones_realizadas'].mean(),
                'productividad_promedio': resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean(),
                'eficiencia_asignacion': resultados[resultados['brecha_calificacion'] > 0.7]['eficiencia_asignacion'].mean(),
                'metricas_productividad': {
                    'productividad_regional_promedio': resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean(),
                    'productividad_ajustada_capacidades': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() /
                                                          max(0.01, resultados[resultados['brecha_calificacion'] > 0.7]['brecha_calificacion'].mean())),
                    'eficiencia_capital_humano': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() *
                                                (1 - resultados[resultados['brecha_calificacion'] > 0.7]['brecha_calificacion'].mean())),
                    'productividad_innovacion_capacidades': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() /
                                                           max(0.01, resultados[resultados['brecha_calificacion'] > 0.7]['tasa_innovacion'].mean())),
                    'indice_efectividad_capital_humano': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() *
                                                        (1 - resultados[resultados['brecha_calificacion'] > 0.7]['brecha_calificacion'].mean()) *
                                                        resultados[resultados['brecha_calificacion'] > 0.7]['eficiencia_asignacion'].mean()),
                    'productividad_tecnologica_capacitada': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() *
                                                           (1 + resultados[resultados['brecha_calificacion'] > 0.7]['capacidad_tecnologica'].mean()))
                }
            }
        }

        return analisis

    def analizar_politicas_cyt_geografico(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas C&T por región geográfica específica de México"""
        analisis_geografico = {}

        # Análisis específico por cada región geográfica de México
        regiones_geograficas = {
            'NOROESTE': {
                'descripcion': 'Baja California, Baja California Sur, Chihuahua, Durango, Sinaloa, Sonora',
                'caracteristicas_principales': 'Frontera con EE.UU., clima árido, minería y agricultura',
                'fortalezas': ['Cercanía comercial EE.UU.', 'Recursos naturales', 'Conectividad fronteriza'],
                'desafios': ['Aridez climática', 'Rezago social', 'Dependencia comercial']
            },
            'NORESTE': {
                'descripcion': 'Coahuila, Nuevo León, Tamaulipas',
                'caracteristicas_principales': 'Industrialización avanzada, manufactura, servicios financieros',
                'fortalezas': ['Alto desarrollo económico', 'Inversión extranjera', 'Infraestructura'],
                'desafios': ['Competencia internacional', 'Sostenibilidad ambiental']
            },
            'OCCIDENTE': {
                'descripcion': 'Colima, Jalisco, Michoacán, Nayarit',
                'caracteristicas_principales': 'Diversidad económica, agricultura tecnificada, manufactura',
                'fortalezas': ['Diversidad sectorial', 'Recursos naturales', 'Potencial turístico'],
                'desafios': ['Rezago social', 'Conectividad interna', 'Volcanismo']
            },
            'CENTRONORTE': {
                'descripcion': 'Aguascalientes, Guanajuato, Querétaro, San Luis Potosí, Zacatecas',
                'caracteristicas_principales': 'Manufactura automotriz, agroindustria, servicios',
                'fortalezas': ['Proximidad mercados', 'Tradición manufacturera', 'Capacitación técnica'],
                'desafios': ['Competencia global', 'Innovación tecnológica']
            },
            'ORIENTE': {
                'descripcion': 'Ciudad de México, México, Morelos, Tlaxcala, Hidalgo, Puebla',
                'caracteristicas_principales': 'CDMX, alta densidad poblacional, servicios avanzados',
                'fortalezas': ['Capital nacional', 'Servicios financieros', 'Educación superior'],
                'desafios': ['Congestión urbana', 'Contaminación', 'Desigualdad social']
            },
            'SUROESTE': {
                'descripcion': 'Chiapas, Guerrero, Oaxaca',
                'caracteristicas_principales': 'Mayor rezago social, recursos naturales, turismo cultural',
                'fortalezas': ['Riqueza natural', 'Patrimonio cultural', 'Potencial turístico'],
                'desafios': ['Alto rezago social', 'Pobreza', 'Aislamiento geográfico']
            },
            'SURESTE': {
                'descripcion': 'Veracruz, Yucatán, Tabasco, Quintana Roo, Campeche',
                'caracteristicas_principales': 'Recursos energéticos, turismo, agricultura tropical',
                'fortalezas': ['Recursos petroleros', 'Turismo', 'Biodiversidad'],
                'desafios': ['Vulnerabilidad ambiental', 'Dependencia energética', 'Huracanes']
            }
        }

        # Análizar cada región geográfica
        for region_geo, info_region in regiones_geograficas.items():
            # Simular datos geográficos específicos basados en características
            datos_region = resultados.sample(min(30, len(resultados)//3))

            # Factores específicos por región geográfica
            if region_geo == 'NOROESTE':
                factor_desarrollo = np.random.uniform(0.6, 0.8)
                factor_frontera = 0.9
                factor_aridez = 0.8
                factor_recursos = 0.7
            elif region_geo == 'NORESTE':
                factor_desarrollo = np.random.uniform(0.7, 0.9)
                factor_frontera = 0.95
                factor_aridez = 0.6
                factor_recursos = 0.6
            elif region_geo == 'OCCIDENTE':
                factor_desarrollo = np.random.uniform(0.5, 0.8)
                factor_frontera = 0.5
                factor_aridez = 0.4
                factor_recursos = 0.8
            elif region_geo == 'CENTRONORTE':
                factor_desarrollo = np.random.uniform(0.6, 0.8)
                factor_frontera = 0.7
                factor_aridez = 0.5
                factor_recursos = 0.5
            elif region_geo == 'ORIENTE':
                factor_desarrollo = np.random.uniform(0.6, 0.9)
                factor_frontera = 0.65
                factor_aridez = 0.3
                factor_recursos = 0.4
            elif region_geo == 'SUROESTE':
                factor_desarrollo = np.random.uniform(0.2, 0.5)
                factor_frontera = 0.3
                factor_aridez = 0.2
                factor_recursos = 0.9
            else:  # SURESTE
                factor_desarrollo = np.random.uniform(0.4, 0.7)
                factor_frontera = 0.4
                factor_aridez = 0.2
                factor_recursos = 0.85

            analisis_geografico[region_geo] = {
                'informacion_regional': info_region,

                'metricas_cyt_geograficas': {
                    'capacidad_tecnologica_geo': factor_desarrollo * datos_region['capacidad_tecnologica'].mean(),
                    'tasa_innovacion_geo': factor_desarrollo * datos_region['tasa_innovacion'].mean(),
                    'actualizacion_tecnologica_geo': factor_desarrollo * datos_region['actualizacion_tecnologica'].mean(),
                    'innovaciones_geo': factor_desarrollo * datos_region['innovaciones_realizadas'].mean(),
                    'productividad_geo': factor_desarrollo * datos_region['productividad_promedio'].mean(),
                    'coordinacion_geo': datos_region['coordinacion_promedio'].mean() * factor_desarrollo,
                    'regiones_simuladas': len(datos_region)
                },

                'caracteristicas_geograficas': {
                    'desarrollo_economico_geo': factor_desarrollo,
                    'cercania_frontera_eeuu': factor_frontera if region_geo in ['NOROESTE', 'NORESTE'] else np.random.uniform(0.3, 0.7),
                    'riqueza_natural': factor_recursos,
                    'factor_aridez': factor_aridez,
                    'rezago_social_estimado': 1.0 - factor_desarrollo + np.random.uniform(-0.1, 0.1),
                    'inversion_extranjera_estimada': factor_frontera * factor_desarrollo,
                    'conectividad_transport': np.random.uniform(0.3, 0.9)
                },

                'metricas_empleo_geograficas': {
                    'empleo_total_geo': datos_region['empleo_total'].mean() * factor_desarrollo,
                    'empleo_especializado_geo': datos_region['empleo_especializado'].mean() * factor_desarrollo,
                    'ratio_especializado_geo': datos_region['empleo_especializado'].mean() / max(1, datos_region['empleo_total'].mean()),
                    'brecha_calificacion_geo': datos_region['brecha_calificacion'].mean() * (2 - factor_desarrollo)
                },

                'metricas_productividad_geograficas': {
                    'productividad_regional_geo': datos_region['productividad_promedio'].mean() * factor_desarrollo,
                    'productividad_por_frontera': (datos_region['productividad_promedio'].mean() * factor_frontera) if region_geo in ['NOROESTE', 'NORESTE'] else datos_region['productividad_promedio'].mean(),
                    'productividad_por_recursos': datos_region['productividad_promedio'].mean() * factor_recursos,
                    'eficiencia_geografica': datos_region['productividad_promedio'].mean() / datos_region['brecha_calificacion'].mean() * factor_desarrollo,
                    'indice_ventaja_competitiva_geo': (datos_region['productividad_promedio'].mean() * factor_desarrollo * factor_frontera) if region_geo in ['NOROESTE', 'NORESTE'] else datos_region['productividad_promedio'].mean() * factor_desarrollo,
                    'productividad_ajustada_clima': datos_region['productividad_promedio'].mean() * factor_desarrollo * (2 - factor_aridez),
                    'indice_desarrollo_geografico': factor_desarrollo * (0.3 + 0.2 * factor_frontera + 0.2 * factor_recursos + 0.3 * (1 - factor_aridez))
                },

                'especializacion_diversificacion_geo': {
                    'especializacion_geo': datos_region['especializacion'].mean() * (1 if factor_desarrollo > 0.7 else 0.8),
                    'diversificacion_geo': datos_region['diversidad_sectorial'].mean() * factor_desarrollo,
                    'concentracion_sectorial': np.random.uniform(0.3, 0.8) * (1 if region_geo == 'SUROESTE' else 0.7),
                    'sector_predominante': self._identificar_sector_predominante(region_geo),
                    'potencial_diversificacion': (1 - datos_region['diversidad_sectorial'].mean()) * factor_desarrollo
                },

                'politicas_geograficas_recomendadas': self._generar_politicas_geograficas(region_geo, info_region, factor_desarrollo),

                'fortalezas_geograficas': info_region['fortalezas'],
                'desafios_geograficos': info_region['desafios'],
                'prioridades_desarrollo': self._determinar_prioridades_desarrollo(region_geo, factor_desarrollo)
            }

        return analisis_geografico

    def _identificar_sector_predominante(self, region_geo: str) -> str:
        """Identifica el sector económico predominante según región geográfica"""
        sectores_por_region = {
            'NOROESTE': ['Minería Tecnológica', 'Agricultura Tecnificada', 'Manufactura Avanzada'],
            'NORESTE': ['Manufactura Avanzada', 'Servicios Financieros', 'Servicios Tecnológicos'],
            'OCCIDENTE': ['Agricultura Tecnificada', 'Turismo Especializado', 'Manufactura Básica'],
            'CENTRONORTE': ['Manufactura Avanzada', 'Servicios Intermedios', 'Agricultura Tecnificada'],
            'ORIENTE': ['Servicios Avanzados', 'Servicios Financieros', 'Turismo Especializado'],
            'SUROESTE': ['Turismo Masivo', 'Agricultura Tradicional', 'Turismo Especializado'],
            'SURESTE': ['Minería Básica', 'Turismo Especializado', 'Agricultura Tecnificada']
        }
        return np.random.choice(sectores_por_region.get(region_geo, ['Servicios Básicos']))

    def _generar_politicas_geograficas(self, region_geo: str, info_region: Dict, factor_desarrollo: float) -> List[str]:
        """Genera políticas específicas según características geográficas"""
        politicas_base = []

        if region_geo == 'NOROESTE':
            politicas_base = [
                "Aprovechamiento máximo de proximidad fronteriza con EE.UU.",
                "Desarrollo de corredores comerciales internacionales",
                "Diversificación de recursos naturales con valor agregado",
                "Tecnologías para克服 aridez y escasez de agua",
                "Clusters industriales en zonas fronterizas"
            ]
        elif region_geo == 'NORESTE':
            politicas_base = [
                "Consolidación como hub manufacturero de clase mundial",
                "Atracción de inversión extranjera directa de alta tecnología",
                "Desarrollo de servicios financieros especializados",
                "Innovación en manufactura automotriz y aeroespacial",
                "Sostenibilidad ambiental en procesos industriales"
            ]
        elif region_geo == 'OCCIDENTE':
            politicas_base = [
                "Diversificación económica equilibrada",
                "Desarrollo turístico sostenible y de alta calidad",
                "Fortalecimiento de la agroindustria tecnificada",
                "Aprovechamiento de recursos naturales renovables",
                "Mejora de conectividad interna y con mercados"
            ]
        elif region_geo == 'CENTRONORTE':
            politicas_base = [
                "Modernización de manufactura tradicional",
                "Desarrollo de clusters automotrices avanzados",
                "Fortalecimiento de educación técnica especializada",
                "Innovación en procesos agroindustriales",
                "Integración con cadenas globales de valor"
            ]
        elif region_geo == 'ORIENTE':
            politicas_base = [
                "Reingeniería de servicios metropolitanos",
                "Desarrollo de servicios financieros de alto valor",
                "Innovación en tecnologías de la información",
                "Sostenibilidad urbana y movilidad",
                "Distribución equitativa del desarrollo metropolitano"
            ]
        elif region_geo == 'SUROESTE':
            politicas_base = [
                "Reducción urgente del rezago social",
                "Desarrollo turístico cultural sostenible",
                "Aprovechamiento sostenible de recursos naturales",
                "Fortalecimiento de conectividad y infraestructura",
                "Programas intensivos de educación y capacitación"
            ]
        else:  # SURESTE
            politicas_base = [
                "Diversificación económica más allá del petróleo",
                "Desarrollo turístico sostenible de clase mundial",
                "Aprovechamiento sostenible de biodiversidad",
                "Tecnologías para adaptación al cambio climático",
                "Desarrollo de energías renovables alternativas"
            ]

        # Ajustar políticas según nivel de desarrollo
        if factor_desarrollo < 0.4:  # Bajo desarrollo
            politicas_base.extend([
                "Inversión prioritaria en infraestructura básica",
                "Programas sociales de primera necesidad",
                "Transferencia tecnológica urgente"
            ])
        elif factor_desarrollo > 0.8:  # Alto desarrollo
            politicas_base.extend([
                "Liderazgo en innovación nacional",
                "Proyección internacional de ventajas competitivas",
                "Desarrollo de tecnologías emergentes"
            ])

        return politicas_base

    def _determinar_prioridades_desarrollo(self, region_geo: str, factor_desarrollo: float) -> List[str]:
        """Determina prioridades de desarrollo según región y nivel de desarrollo"""
        prioridades = []

        # Prioridades comunes para todas las regiones
        prioridades.extend([
            "Fortalecimiento del capital humano",
            "Mejora de la infraestructura de conectividad",
            "Desarrollo de ecosistemas de innovación"
        ])

        # Prioridades específicas por región geográfica
        if region_geo in ['NOROESTE', 'NORESTE']:
            prioridades.extend([
                "Aprovechamiento del Tratado T-MEC",
                "Desarrollo de logística internacional",
                "Clusters industriales especializados"
            ])
        elif region_geo == 'SUROESTE':
            prioridades.extend([
                "Reducción de la pobreza extrema",
                "Conectividad con centros urbanos",
                "Desarrollo de capacidades básicas"
            ])
        elif region_geo == 'SURESTE':
            prioridades.extend([
                "Diversificación económica post-petrolera",
                "Adaptación al cambio climático",
                "Desarrollo turístico sostenible"
            ])

        # Prioridades según nivel de desarrollo
        if factor_desarrollo < 0.5:
            prioridades.insert(0, "Reducción del rezago social")
        elif factor_desarrollo > 0.7:
            prioridades.append("Liderazgo en innovación regional")

        return prioridades

    def _generar_politicas_regionales(self, tipologia: str, datos: pd.DataFrame) -> List[str]:
        """Genera recomendaciones de políticas basadas en tipología"""
        if tipologia == 'Atrapada':
            return [
                "Diversificación sectorial urgente para romper especialización excesiva",
                "Programas de transferencia tecnológica desde regiones no atrapadas",
                "Fortalecimiento de capacidades educativas y de investigación",
                "Incentivos a la innovación en sectores no tradicionales",
                "Creación de redes de colaboración inter-regional"
            ]
        else:  # NO_ATRAPADA (con especialización moderada/intermedia)
            return [
                "Optimización de especialización moderada para ventajas competitivas",
                "Liderazgo en I+D para mantener diferenciación tecnológica",
                "Programas de mentoring para regiones atrapadas",
                "Fortalecimiento del ecosistema de innovación",
                "Políticas de atracción de talento internacional",
                "Equilibrio entre especialización sectorial y diversificación"
            ]

"""# =============================================
# FUNCIONES DE ANÁLISIS Y VISUALIZACIÓN
# =============================================
"""

def setup_matplotlib_for_plotting():
    """Setup matplotlib para gráficos con configuración adecuada"""
    import warnings
    warnings.filterwarnings('default')

    plt.switch_backend("Agg")
    plt.style.use("seaborn-v0_8")
    sns.set_palette("husl")

    # Usar 'DejaVu Sans' que es una fuente común en entornos como Colab
    plt.rcParams["font.family"] = "DejaVu Sans"
    plt.rcParams["font.sans-serif"] = ["DejaVu Sans"]
    plt.rcParams["axes.unicode_minus"] = False

def ejecutar_analisis_completo():
    """Ejecuta el análisis completo del modelo económico con tipologías integradas"""
    print("=== MODELO ECONÓMICO REGIONAL CON TIPOLOGÍAS INTEGRADAS ===")
    print("Integra tipologías Atrapadas vs No Atrapadas basadas en evidencia empírica")
    print("Incluye análisis por región geográfica de México (7 regiones específicas)")
    print("Funcionalidades: Regional • Sectorial • Corporativo • Geográfico • Entorno\n")

    # Crear y ejecutar modelo
    modelo = ModeloEconomicoRegional(num_regiones=32)
    resultados = modelo.ejecutar_simulacion(num_pasos=60)

    # Crear resumen por paso con todas las métricas
    resumen = resultados.groupby('paso_tiempo').agg({
        'capacidad_tecnologica': 'mean',
        'diversidad_sectorial': 'mean',
        'productividad_promedio': 'mean',
        'coordinacion_promedio': 'mean',
        'innovaciones_realizadas': 'sum',
        'atrapada': 'mean',
        'empleo_especializado': 'mean',
        'empleo_total': 'mean',
        'eficiencia_asignacion': 'mean',
        'flujos_internos': 'mean',
        # MÉTRICAS ADICIONALES
        'tasa_innovacion': 'mean',
        'especializacion': 'mean',
        'actualizacion_tecnologica': 'mean',
        'brecha_calificacion': 'mean',
        'empleo_total_region': 'mean',
        'empleo_especializado_region': 'mean',
        # CARACTERÍSTICAS GEOGRÁFICAS ESPECÍFICAS
        'desarrollo_economico_geo': 'mean',
        'cercania_frontera_eeuu': 'mean',
        'riqueza_natural_geo': 'mean',
        'factor_aridez': 'mean',
        'rezago_social_geo': 'mean',
        'conectividad_transport': 'mean',
        'inversion_extranjera_geo': 'mean'
    }).round(4)

    resumen['porcentaje_atrapadas'] = resumen['atrapada'] * 100
    resumen.reset_index(inplace=True)

    # Ejecutar análisis de políticas C&T
    print("\n=== EJECUTANDO ANÁLISIS DE POLÍTICAS C&T ===")

    # 1. Análisis Regional por tipologías
    analisis_regional = modelo.analizar_politicas_cyt_regional(resultados)
    print("\n1. ÁMBITO REGIONAL POR TIPOLOGÍAS:")
    for region, datos in analisis_regional.items():
        print(f"  {region}:")
        print(f"    - Tipología predominante: {datos['tipologia_economica']}")
        print(f"    - Capacidad tecnológica: {datos['metricas_cyt']['capacidad_tecnologica_promedio']:.3f}")
        print(f"    - Tasa innovación promedio: {datos['metricas_cyt']['tasa_innovacion_promedio']:.4f}")
        print(f"    - Actualización tecnológica: {datos['metricas_cyt']['actualizacion_tecnologica_promedio']:.4f}")
        print(f"    - Innovaciones totales: {datos['metricas_cyt']['innovaciones_total']}")
        print(f"    - Diversidad sectorial: {datos['metricas_especializacion_diversificacion']['diversidad_sectorial_promedio']:.3f}")
        print(f"    - Especialización: {datos['metricas_especializacion_diversificacion']['especializacion_promedio']:.3f}")
        print(f"    - Empleo especializado: {datos['metricas_empleo']['empleo_especializado_promedio']:.1f}")
        print(f"    - Empleo total: {datos['metricas_empleo']['empleo_total_promedio']:.1f}")
        print(f"    - Brecha calificación: {datos['metricas_calificacion']['brecha_calificacion_promedio']:.3f}")
        print(f"    - Productividad promedio: {datos['metricas_productividad']['productividad_promedio']:.3f}")
        print(f"    - Productividad por innovación: {datos['metricas_productividad']['productividad_por_innovacion']:.2f}")
        print(f"    - Productividad tecnológica: {datos['metricas_productividad']['productividad_tecnologica']:.2f}")
        print(f"    - Eficiencia empleo productivo: {datos['metricas_productividad']['eficiencia_empleo_productivo']:.4f}")
        print(f"    - Índice productividad regional: {datos['metricas_productividad']['indice_productividad_regional']:.2f}")
        print(f"    - Regiones atrapadas: {datos['metricas_cyt']['porcentaje_atrapadas']:.1f}%")

    # 1.5. Análisis Geográfico por Regiones de México
    analisis_geografico = modelo.analizar_politicas_cyt_geografico(resultados)
    print("\n1.5. ÁMBITO GEOGRÁFICO POR REGIONES DE MÉXICO:")
    for region_geo, datos_geo in analisis_geografico.items():
        print(f"  {region_geo}:")
        print(f"    - Descripción: {datos_geo['informacion_regional']['descripcion']}")
        print(f"    - Desarrollo económico estimado: {datos_geo['caracteristicas_geograficas']['desarrollo_economico_geo']:.3f}")
        print(f"    - Cercanía frontera EE.UU.: {datos_geo['caracteristicas_geograficas']['cercania_frontera_eeuu']:.3f}")
        print(f"    - Riqueza natural: {datos_geo['caracteristicas_geograficas']['riqueza_natural']:.3f}")
        print(f"    - Factor aridez: {datos_geo['caracteristicas_geograficas']['factor_aridez']:.3f}")
        print(f"    - Rezago social estimado: {datos_geo['caracteristicas_geograficas']['rezago_social_estimado']:.3f}")
        print(f"    - Inversión extranjera estimada: {datos_geo['caracteristicas_geograficas']['inversion_extranjera_estimada']:.3f}")
        print(f"    - Capacidad tecnológica geográfica: {datos_geo['metricas_cyt_geograficas']['capacidad_tecnologica_geo']:.3f}")
        print(f"    - Tasa innovación geográfica: {datos_geo['metricas_cyt_geograficas']['tasa_innovacion_geo']:.4f}")
        print(f"    - Productividad geográfica: {datos_geo['metricas_productividad_geograficas']['productividad_regional_geo']:.3f}")
        print(f"    - Productividad por frontera: {datos_geo['metricas_productividad_geograficas']['productividad_por_frontera']:.3f}")
        print(f"    - Productividad por recursos: {datos_geo['metricas_productividad_geograficas']['productividad_por_recursos']:.3f}")
        print(f"    - Eficiencia geográfica: {datos_geo['metricas_productividad_geograficas']['eficiencia_geografica']:.4f}")
        print(f"    - Índice desarrollo geográfico: {datos_geo['metricas_productividad_geograficas']['indice_desarrollo_geografico']:.4f}")
        print(f"    - Especialización geográfica: {datos_geo['especializacion_diversificacion_geo']['especializacion_geo']:.3f}")
        print(f"    - Diversificación geográfica: {datos_geo['especializacion_diversificacion_geo']['diversificacion_geo']:.3f}")
        print(f"    - Sector predominante: {datos_geo['especializacion_diversificacion_geo']['sector_predominante']}")
        print(f"    - Empleos totales geográficos: {datos_geo['metricas_empleo_geograficas']['empleo_total_geo']:.1f}")
        print(f"    - Empleos especializados geográficos: {datos_geo['metricas_empleo_geograficas']['empleo_especializado_geo']:.1f}")
        print(f"    - Brecha calificación geográfica: {datos_geo['metricas_empleo_geograficas']['brecha_calificacion_geo']:.3f}")
        print(f"    - Fortalezas: {', '.join(datos_geo['fortalezas_geograficas'])}")
        print(f"    - Desafíos: {', '.join(datos_geo['desafios_geograficos'])}")

    # 2. Análisis Sectorial
    analisis_sectorial = modelo.analizar_politicas_cyt_sectorial(resultados)
    print("\n2. ÁMBITO SECTORIAL POR TIPOS:")
    for sector, datos in analisis_sectorial.items():
        print(f"  {sector}:")
        print(f"    - Regiones con sector: {datos['metricas_cyt']['regiones_con_sector']}")
        print(f"    - Innovaciones promedio: {datos['metricas_cyt']['innovaciones_promedio']:.2f}")
        print(f"    - Tasa innovación: {datos['metricas_cyt']['tasa_innovacion_promedio']:.4f}")
        print(f"    - Actualización tecnológica: {datos['metricas_cyt']['actualizacion_tecnologica_promedio']:.4f}")
        print(f"    - Grado especialización: {datos['especializacion_diversificacion']['grado_especializacion']:.3f}")
        print(f"    - Grado diversificación: {datos['especializacion_diversificacion']['grado_diversificacion']:.3f}")
        print(f"    - Empleo especializado: {datos['empleo_sectorial']['empleo_especializado_promedio']:.1f}")
        print(f"    - Empleo total: {datos['empleo_sectorial']['empleo_total_promedio']:.1f}")
        print(f"    - Brecha calificación: {datos['calificacion_trabajo']['brecha_calificacion_promedio']:.3f}")
        print(f"    - Productividad regional: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        print(f"    - Productividad por empleado: {datos['metricas_productividad']['productividad_por_empleado']:.4f}")
        print(f"    - Productividad por innovación: {datos['metricas_productividad']['productividad_por_innovacion']:.2f}")
        print(f"    - Eficiencia productiva sectorial: {datos['metricas_productividad']['eficiencia_productiva_sectorial']:.2f}")
        print(f"    - Índice competitividad sectorial: {datos['metricas_productividad']['indice_competitividad_sectorial']:.4f}")

    # 3. Análisis Corporativo por tipologías
    analisis_corporativo = modelo.analizar_politicas_cyt_corporativo(resultados)
    print("\n3. ÁMBITO CORPORATIVO POR TIPOLOGÍAS:")
    print("\nPOR TAMAÑO CORPORATIVO:")
    for region, datos in analisis_corporativo['por_tamaño_corporativo'].items():
        print(f"  {region}:")
        print(f"    - Corporaciones grandes: {datos['corporaciones_grandes']}")
        print(f"    - Corporaciones pequeñas: {datos['corporaciones_pequeñas']}")
        print(f"    - Ratio G/P: {datos['ratio_grandes_pequenas']:.2f}")
        print(f"    - Innovaciones grandes: {datos['innovaciones_grandes']:.1f}")
        print(f"    - Innovaciones pequeñas: {datos['innovaciones_pequeñas']:.1f}")
        print(f"    - Empleo especializado regional: {datos['empleo_especializado_regional']:.1f}")
        print(f"    - Productividad regional promedio: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        print(f"    - Productividad por empleado grande: {datos['metricas_productividad']['productividad_por_empleado_grande']:.4f}")
        print(f"    - Eficiencia productiva grandes: {datos['metricas_productividad']['eficiencia_productiva_grandes']:.2f}")
        print(f"    - Índice competitividad corporativo: {datos['metricas_productividad']['indice_competitividad_corporativo']:.4f}")

    print("\nPOR NIVEL TECNOLÓGICO:")
    for nivel, datos in analisis_corporativo['por_tecnologia'].items():
        print(f"  {nivel}:")
        print(f"    - Regiones con tecnología: {datos['regiones_con_tecnologia']}")
        print(f"    - Tasa innovación promedio: {datos['tasa_innovacion_promedio']:.4f}")
        print(f"    - Actualización tecnológica: {datos['actualizacion_tecnologica_promedio']:.4f}")
        print(f"    - Tasa atrapamiento: {datos['tasa_atrapamiento']:.1f}%")
        print(f"    - Empleo especializado: {datos['empleo_especializado']:.1f}")
        print(f"    - Productividad regional: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        print(f"    - Productividad por innovación: {datos['metricas_productividad']['productividad_por_innovacion']:.2f}")
        print(f"    - Productividad tecnológica: {datos['metricas_productividad']['productividad_tecnologica']:.2f}")
        print(f"    - Eficiencia productiva: {datos['metricas_productividad']['eficiencia_productiva']:.2f}")
        print(f"    - Índice conversión innovación: {datos['metricas_productividad']['indice_conversion_innovacion']:.4f}")

    print("\nPOR NIVEL DE ESPECIALIZACIÓN:")
    for nivel, datos in analisis_corporativo['por_especializacion'].items():
        print(f"  {nivel}:")
        print(f"    - Regiones: {datos.get('regiones_con_alta_esp', datos.get('regiones_con_baja_esp', 'N/A'))}")
        print(f"    - Diversidad promedio: {datos['diversidad_promedio']:.3f}")
        print(f"    - Innovaciones promedio: {datos['innovaciones_promedio']:.2f}")
        print(f"    - Empleo especializado ratio: {datos['empleo_especializado_ratio']:.3f}")
        print(f"    - Productividad promedio: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        if 'Alta' in nivel:
            print(f"    - Productividad especializada: {datos['metricas_productividad']['productividad_especializada']:.3f}")
            print(f"    - Eficiencia especialización: {datos['metricas_productividad']['eficiencia_especializacion_productiva']:.2f}")
            print(f"    - Índice ventaja competitiva: {datos['metricas_productividad']['indice_ventaja_competitiva']:.4f}")
        else:
            print(f"    - Productividad diversificada: {datos['metricas_productividad']['productividad_diversificada']:.3f}")
            print(f"    - Eficiencia diversificación: {datos['metricas_productividad']['eficiencia_diversificacion_productiva']:.2f}")
            print(f"    - Índice flexibilidad productiva: {datos['metricas_productividad']['indice_flexibilidad_productiva']:.4f}")

    print("\nPOR BRECHA DE CALIFICACIÓN:")
    for nivel, datos in analisis_corporativo['por_calificacion'].items():
        print(f"  {nivel}:")
        print(f"    - Regiones: {datos.get('regiones_con_baja_brecha', datos.get('regiones_con_alta_brecha', 'N/A'))}")
        print(f"    - Brecha calificación promedio: {datos['brecha_calificacion_promedio']:.3f}")
        print(f"    - Innovaciones promedio: {datos['innovaciones_promedio']:.2f}")
        print(f"    - Eficiencia asignación: {datos['eficiencia_asignacion']:.3f}")
        print(f"    - Productividad promedio: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        print(f"    - Eficiencia capital humano: {datos['metricas_productividad']['eficiencia_capital_humano']:.3f}")
        print(f"    - Productividad por innovación: {datos['metricas_productividad']['productividad_innovacion_capacidades']:.2f}")
        print(f"    - Índice efectividad capital humano: {datos['metricas_productividad']['indice_efectividad_capital_humano']:.4f}")

    print("\n=== RESULTADOS DE LA SIMULACIÓN ===")
    print(f"Simulación completada con {len(resultados)} registros")
    print(f"Pasos ejecutados: {resultados['paso_tiempo'].max()}")
    print(f"Regiones simuladas: {len(modelo.regiones)}")

    # Mostrar distribución de tipologías iniciales
    distribucion_tipologias = resultados.groupby('tipo_region_economica_inicial').size()
    print("\n=== DISTRIBUCIÓN DE TIPOLOGÍAS REGIONALES INICIALES ===")
    for tipologia, cantidad in distribucion_tipologias.items():
        print(f"{tipologia}: {cantidad} registros ({cantidad/len(resultados)*100:.1f}%)")

    # Mostrar comparación de tipologías con todas las métricas
    print("\n=== COMPARACIÓN COMPLETA DE TIPOLOGÍAS ===")
    comparacion_tipologias = resultados.groupby('tipo_region_economica_inicial').agg({
        'capacidad_tecnologica': 'mean',
        'innovaciones_realizadas': 'mean',
        'tasa_innovacion': 'mean',
        'actualizacion_tecnologica': 'mean',
        'diversidad_sectorial': 'mean',
        'especializacion': 'mean',
        'productividad_promedio': 'mean',
        'atrapada': 'mean',
        'empleo_especializado': 'mean',
        'empleo_total': 'mean',
        'brecha_calificacion': 'mean',
        'coordinacion_promedio': 'mean'
    }).round(4)

    print(comparacion_tipologias)

    # =====================================================
    # EVALUACIÓN DINÁMICA DE TIPOLOGÍAS
    # =====================================================
    print("\n=== EVALUACIÓN DINÁMICA DE TIPOLOGÍAS ===")
    print("Analizando evolución basada en características sectoriales y regionales reales...")

    # Evaluar dinámicamente el estado de todas las regiones
    resultados_con_evaluacion = EvaluacionDinamica.evaluar_evolucion_dinamica(resultados)

    # Mostrar distribución inicial vs dinámica
    print("\n1. DISTRIBUCIÓN INICIAL:")
    distribucion_inicial = resultados_con_evaluacion.groupby('tipo_region_economica_inicial').size()
    for tipologia, cantidad in distribucion_inicial.items():
        print(f"  {tipologia}: {cantidad} registros ({cantidad/len(resultados_con_evaluacion)*100:.1f}%)")

    print("\n2. DISTRIBUCIÓN DINÁMICA (por características reales):")
    distribucion_dinamica = resultados_con_evaluacion.groupby('estado_dinamico').size()
    for estado, cantidad in distribucion_dinamica.items():
        print(f"  {estado}: {cantidad} registros ({cantidad/len(resultados_con_evaluacion)*100:.1f}%)")

    print("\n3. ANÁLISIS DE EVOLUCIÓN:")
    evolucion = pd.crosstab(
        resultados_con_evaluacion['tipo_region_economica_inicial'],
        resultados_con_evaluacion['estado_dinamico'],
        margins=True
    )
    print(evolucion)

    print("\n4. ESTADÍSTICAS DE PROPENSIÓN A ATRAPPADA:")
    propension_stats = resultados_con_evaluacion.groupby('estado_dinamico')['propension_atrappada'].agg(['mean', 'std', 'min', 'max']).round(4)
    print(propension_stats)

    print("\n5. MÉTRICAS POR ESTADO DINÁMICO:")
    metricas_dinamicas = resultados_con_evaluacion.groupby('estado_dinamico').agg({
        'capacidad_tecnologica': 'mean',
        'innovaciones_realizadas': 'mean',
        'tasa_innovacion': 'mean',
        'diversidad_sectorial': 'mean',
        'especializacion': 'mean',
        'productividad_promedio': 'mean',
        'brecha_calificacion': 'mean',
        'propension_atrappada': 'mean'
    }).round(4)
    print(metricas_dinamicas)

    # Agregar análisis por paso temporal
    print("\n6. EVOLUCIÓN TEMPORAL DE LA EVALUACIÓN DINÁMICA:")
    evolucion_temporal = resultados_con_evaluacion.groupby(['paso_tiempo', 'estado_dinamico']).size().unstack(fill_value=0)
    if 'Atrapada' in evolucion_temporal.columns:
        # Calcular el total sumando solo las columnas que existen
        columnas_existentes = [col for col in ['Atrapada', 'No_Atrapada', 'En_transicion'] if col in evolucion_temporal.columns]
        evolucion_temporal['porcentaje_atrapadas'] = (evolucion_temporal['Atrapada'] /
                                                    evolucion_temporal[columnas_existentes].sum(axis=1) * 100).round(2)
    print(evolucion_temporal)

    # Actualizar resultados para usar en análisis posteriores
    resultados = resultados_con_evaluacion
    resumen['porcentaje_atrapadas_dinamicas'] = (resultados['estado_dinamico'] == 'Atrapada').mean() * 100

    return modelo, resultados, resumen

def crear_visualizaciones_individuales(resultados: pd.DataFrame, save_path: str):
    """Crea visualizaciones individuales para cada tipo de análisis"""
    setup_matplotlib_for_plotting()

    colores_tipologia = {'Atrapada': '#FF7F0E', 'No_Atrapada': '#1F77B4', 'En_transicion': '#2CA02C'}

    # 1. CAPACIDAD TECNOLÓGICA
    plt.figure(figsize=(10, 6))
    capacidad_tipologia = resultados.groupby('tipo_region_economica_inicial')['capacidad_tecnologica'].mean()
    bars1 = plt.bar(capacidad_tipologia.index, capacidad_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in capacidad_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Capacidad Tecnológica por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Capacidad Tecnológica', fontsize=12)
    plt.xlabel('Tipología regional inicial', fontsize=12)
    for i, v in enumerate(capacidad_tipologia.values):
        plt.text(i, v + 0.02, f'{v:.3f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '01_capacidad_tecnologica_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 2. TASA DE INNOVACIÓN
    plt.figure(figsize=(10, 6))
    tasa_innovacion_tipologia = resultados.groupby('tipo_region_economica_inicial')['tasa_innovacion'].mean()
    bars2 = plt.bar(tasa_innovacion_tipologia.index, tasa_innovacion_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in tasa_innovacion_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Tasa de innovación por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Tasa de innovación', fontsize=12)
    plt.xlabel('Tipología regional inicial', fontsize=12)
    for i, v in enumerate(tasa_innovacion_tipologia.values):
        plt.text(i, v + 0.002, f'{v:.3f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '02_tasa_innovacion_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()
    plt.figure(figsize=(10, 6))
    tasa_innovacion_tipologia = resultados.groupby('tipo_region_economica_inicial')['tasa_innovacion'].mean()
    bars2 = plt.bar(tasa_innovacion_tipologia.index, tasa_innovacion_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in tasa_innovacion_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Tasa de innovación por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Tasa de innovación', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(tasa_innovacion_tipologia.values):
        plt.text(i, v + 0.001, f'{v:.3f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '02_tasa_innovacion_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 3. DIVERSIDAD SECTORIAL
    plt.figure(figsize=(10, 6))
    diversidad_tipologia = resultados.groupby('tipo_region_economica_inicial')['diversidad_sectorial'].mean()
    bars3 = plt.bar(diversidad_tipologia.index, diversidad_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in diversidad_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Diversidad sectorial por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Diversidad sectorial', fontsize=12)
    plt.xlabel('Tipología regional inicial', fontsize=12)
    for i, v in enumerate(diversidad_tipologia.values):
        plt.text(i, v + 0.02, f'{v:.3f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '03_diversidad_sectorial_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 4. ESPECIALIZACIÓN
    plt.figure(figsize=(10, 6))
    especializacion_tipologia = resultados.groupby('tipo_region_economica_inicial')['especializacion'].mean()
    bars4 = plt.bar(especializacion_tipologia.index, especializacion_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in especializacion_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Especialización por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Especialización', fontsize=12)
    plt.xlabel('Tipología regional inicial', fontsize=12)
    for i, v in enumerate(especializacion_tipologia.values):
        plt.text(i, v + 0.02, f'{v:.3f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '04_especializacion_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 5. PRODUCTIVIDAD
    plt.figure(figsize=(10, 6))
    productividad_tipologia = resultados.groupby('tipo_region_economica_inicial')['productividad_promedio'].mean()
    bars5 = plt.bar(productividad_tipologia.index, productividad_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in productividad_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Productividad por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Productividad promedio', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(productividad_tipologia.values):
        plt.text(i, v + 0.5, f'{v:.1f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '05_productividad_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 6. ACTUALIZACIÓN TECNOLÓGICA
    plt.figure(figsize=(10, 6))
    actualizacion_tipologia = resultados.groupby('tipo_region_economica_inicial')['actualizacion_tecnologica'].mean()
    bars6 = plt.bar(actualizacion_tipologia.index, actualizacion_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in actualizacion_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Actualización tecnológica por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Actualización tecnológica', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(actualizacion_tipologia.values):
        plt.text(i, v + 0.0005, f'{v:.4f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '06_actualizacion_tecnologica_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 7. BRECHA DE CALIFICACIÓN
    plt.figure(figsize=(10, 6))
    brecha_tipologia = resultados.groupby('tipo_region_economica_inicial')['brecha_calificacion'].mean()
    bars7 = plt.bar(brecha_tipologia.index, brecha_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in brecha_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Brecha de calificación por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Brecha de calificación', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(brecha_tipologia.values):
        plt.text(i, v + 0.02, f'{v:.3f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '07_brecha_calificacion_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 8. EMPLEO ESPECIALIZADO
    plt.figure(figsize=(10, 6))
    empleo_esp_tipologia = resultados.groupby('tipo_region_economica_inicial')['empleo_especializado'].mean()
    bars8 = plt.bar(empleo_esp_tipologia.index, empleo_esp_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in empleo_esp_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Empleo especializado por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Empleo especializado', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(empleo_esp_tipologia.values):
        plt.text(i, v + 2, f'{v:.1f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '08_empleo_especializado_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 9. EMPLEO TOTAL
    plt.figure(figsize=(10, 6))
    empleo_total_tipologia = resultados.groupby('tipo_region_economica_inicial')['empleo_total'].mean()
    bars9 = plt.bar(empleo_total_tipologia.index, empleo_total_tipologia.values,
                    color=[colores_tipologia[tipo] for tipo in empleo_total_tipologia.index],
                    alpha=0.7, edgecolor='black')
    plt.title('Empleo total por tipología regional', fontweight='bold', fontsize=14)
    plt.ylabel('Empleo total', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(empleo_total_tipologia.values):
        plt.text(i, v + 2, f'{v:.1f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '09_empleo_total_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 10. EVOLUCIÓN TEMPORAL - CAPACIDAD TECNOLÓGICA
    plt.figure(figsize=(12, 6))
    for tipologia in resultados['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados[resultados['tipo_region_economica_inicial'] == tipologia]
        evolucion = datos_tipologia.groupby('paso_tiempo')['capacidad_tecnologica'].mean()
        plt.plot(evolucion.index, evolucion.values,
                color=colores_tipologia[tipologia], label=tipologia, linewidth=2, marker='o', markersize=4)

    plt.title('Evolución de la Capacidad Tecnológica por tipología', fontweight='bold', fontsize=14)
    plt.xlabel('Paso de simulación', fontsize=12)
    plt.ylabel('Capacidad Tecnológica', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '10_evolucion_capacidad_tecnologica.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 11. EVOLUCIÓN TEMPORAL - TASA DE INNOVACIÓN
    plt.figure(figsize=(12, 6))
    for tipologia in resultados['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados[resultados['tipo_region_economica_inicial'] == tipologia]
        evolucion = datos_tipologia.groupby('paso_tiempo')['tasa_innovacion'].mean()
        plt.plot(evolucion.index, evolucion.values,
                color=colores_tipologia[tipologia], label=tipologia, linewidth=2, marker='s', markersize=4)

    plt.title('Evolución de la tasa de innovación por tipología', fontweight='bold', fontsize=14)
    plt.xlabel('Paso de simulación', fontsize=12)
    plt.ylabel('Tasa de innovación', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '11_evolucion_tasa_innovacion.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 12. PORCENTAJE DE REGIONES ATRAPADAS
    plt.figure(figsize=(10, 6))
    atrapadas_tipologia = resultados.groupby('tipo_region_economica_inicial')['atrapada'].mean() * 100
    bars12 = plt.bar(atrapadas_tipologia.index, atrapadas_tipologia.values,
                     color=[colores_tipologia[tipo] for tipo in atrapadas_tipologia.index],
                     alpha=0.7, edgecolor='black')
    plt.title('Regiones en Trampa de Innovacion (%)', fontweight='bold', fontsize=14)
    plt.ylabel('Porcentaje Atrapadas (%)', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(atrapadas_tipologia.values):
        plt.text(i, v + 2, f'{v:.1f}%', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '12_porcentaje_atrapadas_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 13. PRODUCTIVIDAD POR EMPLEADO ESPECIALIZADO
    plt.figure(figsize=(10, 6))
    # Calcular productividad por empleado especializado
    resultados['productividad_por_empleado'] = resultados['productividad_promedio'] / np.maximum(1, resultados['empleo_especializado'])
    prod_empleo_tipologia = resultados.groupby('tipo_region_economica_inicial')['productividad_por_empleado'].mean()
    bars13 = plt.bar(prod_empleo_tipologia.index, prod_empleo_tipologia.values,
                     color=[colores_tipologia[tipo] for tipo in prod_empleo_tipologia.index],
                     alpha=0.7, edgecolor='black')
    plt.title('Productividad por empleado especializado por tipología', fontweight='bold', fontsize=14)
    plt.ylabel('Productividad por empleado', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(prod_empleo_tipologia.values):
        plt.text(i, v + 0.0005, f'{v:.4f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '13_productividad_por_empleado_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 14. EFICIENCIA INNOVADORA
    plt.figure(figsize=(10, 6))
    # Calcular eficiencia innovadora (productividad/tasa de innovación)
    resultados['eficiencia_innovadora'] = resultados['productividad_promedio'] / np.maximum(0.001, resultados['tasa_innovacion'])
    efic_innov_tipologia = resultados.groupby('tipo_region_economica_inicial')['eficiencia_innovadora'].mean()
    bars14 = plt.bar(efic_innov_tipologia.index, efic_innov_tipologia.values,
                     color=[colores_tipologia[tipo] for tipo in efic_innov_tipologia.index],
                     alpha=0.7, edgecolor='black')
    plt.title('Eficiencia innovadora (Productividad/Tasa innovación) por tipología', fontweight='bold', fontsize=14)
    plt.ylabel('Eficiencia innovadora', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(efic_innov_tipologia.values):
        plt.text(i, v + 5, f'{v:.1f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '14_eficiencia_innovadora_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 15. PRODUCTIVIDAD TECNOLÓGICA
    plt.figure(figsize=(10, 6))
    # Calcular productividad tecnológica (productividad/capacidad tecnológica)
    resultados['productividad_tecnologica'] = resultados['productividad_promedio'] / np.maximum(0.01, resultados['capacidad_tecnologica'])
    prod_tec_tipologia = resultados.groupby('tipo_region_economica_inicial')['productividad_tecnologica'].mean()
    bars15 = plt.bar(prod_tec_tipologia.index, prod_tec_tipologia.values,
                     color=[colores_tipologia[tipo] for tipo in prod_tec_tipologia.index],
                     alpha=0.7, edgecolor='black')
    plt.title('Productividad tecnológica (Productividad/Capacidad Tecnológica) por tipología', fontweight='bold', fontsize=14)
    plt.ylabel('Productividad tecnológica', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(prod_tec_tipologia.values):
        plt.text(i, v + 0.2, f'{v:.1f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '15_productividad_tecnologica_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 16. ÍNDICE DE COMPETITIVIDAD REGIONAL
    plt.figure(figsize=(10, 6))
    # Calcular índice de competitividad (productividad * innovación / brecha calificación)
    resultados['indice_competitividad'] = (resultados['productividad_promedio'] * resultados['tasa_innovacion']) / np.maximum(0.001, resultados['brecha_calificacion'])
    comp_reg_tipologia = resultados.groupby('tipo_region_economica_inicial')['indice_competitividad'].mean()
    bars16 = plt.bar(comp_reg_tipologia.index, comp_reg_tipologia.values,
                     color=[colores_tipologia[tipo] for tipo in comp_reg_tipologia.index],
                     alpha=0.7, edgecolor='black')
    plt.title('Índice de competitividad regional por tipología', fontweight='bold', fontsize=14)
    plt.ylabel('Índice de competitividad', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(comp_reg_tipologia.values):
        plt.text(i, v + 0.001, f'{v:.3f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '16_indice_competitividad_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 17. EVOLUCIÓN TEMPORAL - PRODUCTIVIDAD
    plt.figure(figsize=(12, 6))
    for tipologia in resultados['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados[resultados['tipo_region_economica_inicial'] == tipologia]
        evolucion = datos_tipologia.groupby('paso_tiempo')['productividad_promedio'].mean()
        plt.plot(evolucion.index, evolucion.values,
                color=colores_tipologia[tipologia], label=tipologia, linewidth=2, marker='^', markersize=4)

    plt.title('Evolución de la productividad por tipología', fontweight='bold', fontsize=14)
    plt.xlabel('Paso de simulación', fontsize=12)
    plt.ylabel('Productividad promedio', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '17_evolucion_productividad.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 18. EVALUACIÓN DINÁMICA DE TIPOLOGÍAS
    if 'estado_dinamico' in resultados.columns:
        plt.figure(figsize=(12, 8))

        # Subplot 1: Distribución de estados dinámicos
        plt.subplot(2, 2, 1)
        estados_dinamicos = resultados['estado_dinamico'].value_counts()
        colores_estados = {'Atrapada': '#FF7F0E', 'No_Atrapada': '#1F77B4', 'En_transicion': '#2CA02C'}
        colors = [colores_estados.get(estado, '#D62728') for estado in estados_dinamicos.index]
        plt.pie(estados_dinamicos.values, labels=estados_dinamicos.index, autopct='%1.1f%%',
                colors=colors, startangle=90)
        plt.title('Distribución de estados dinámicos', fontweight='bold')

        # Subplot 2: Propensión a estar atrapada por estado
        plt.subplot(2, 2, 2)
        propension_estado = resultados.groupby('estado_dinamico')['propension_atrappada'].mean()
        bars = plt.bar(propension_estado.index, propension_estado.values,
                       color=[colores_estados.get(estado, '#D62728') for estado in propension_estado.index],
                       alpha=0.7, edgecolor='black')
        plt.title('Propensión entrampadas', fontweight='bold')
        plt.ylabel('Propensión promedio')
        for i, v in enumerate(propension_estado.values):
            plt.text(i, v + 0.01, f'{v:.3f}', ha='center', fontweight='bold')

        # Subplot 3: Capacidad tecnológica por estado dinámico
        plt.subplot(2, 2, 3)
        cap_tec_estado = resultados.groupby('estado_dinamico')['capacidad_tecnologica'].mean()
        bars = plt.bar(cap_tec_estado.index, cap_tec_estado.values,
                       color=[colores_estados.get(estado, '#D62728') for estado in cap_tec_estado.index],
                       alpha=0.7, edgecolor='black')
        plt.title('Capacidad Tecnológica por estado dinámico', fontweight='bold')
        plt.ylabel('Capacidad Tecnológica promedio')
        for i, v in enumerate(cap_tec_estado.values):
            plt.text(i, v + 0.02, f'{v:.3f}', ha='center', fontweight='bold')

        # Subplot 4: Evolución temporal de estados
        plt.subplot(2, 2, 4)
        evolucion_temporal = resultados.groupby(['paso_tiempo', 'estado_dinamico']).size().unstack(fill_value=0)
        if 'Atrapada' in evolucion_temporal.columns:
            evolucion_temporal['porcentaje_atrapadas'] = (evolucion_temporal['Atrapada'] /
                                                        evolucion_temporal.sum(axis=1) * 100)
            plt.plot(evolucion_temporal.index, evolucion_temporal['porcentaje_atrapadas'],
                     marker='o', linewidth=2, color='#FF7F0E')
            plt.title('Evolución % regiones atrapadas', fontweight='bold')
            plt.ylabel('Porcentaje atrapadas')
            plt.xlabel('Paso temporal')
            plt.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.savefig(os.path.join(save_path, '18_evaluacion_dinamica.png'), dpi=300, bbox_inches='tight')
        plt.close()

        print("✓ 18. Evaluación dinámica generada exitosamente")

    print("✓ 18 gráficas individuales generadas exitosamente (incluyendo evaluación dinámica)")

def crear_graficos_correlacion(resultados: pd.DataFrame, save_path: str):
    """Crea gráficos de correlación organizados por categorías: Regional, Sectorial, Corporativo y Tecnológico"""
    setup_matplotlib_for_plotting()

    # Definir variables por categoría
    variables_regionales = [
        'desarrollo_economico_geo', 'cercania_frontera_eeuu', 'riqueza_natural_geo',
        'factor_aridez', 'rezago_social_geo', 'conectividad_transport', 'inversion_extranjera_geo'
    ]

    variables_sectoriales = [
        'diversidad_sectorial', 'especializacion', 'coordinacion_promedio',
        'eficiencia_asignacion', 'flujos_internos'
    ]

    variables_corporativas = [
        'empleo_especializado', 'empleo_total', 'empleo_especializado_region',
        'empleo_total_region', 'productividad_promedio', 'innovaciones_realizadas'
    ]

    variables_tecnologicas = [
        'capacidad_tecnologica', 'tasa_innovacion', 'actualizacion_tecnologica'
    ]

    # Filtrar solo las columnas numéricas que existen en el DataFrame
    columnas_existentes = [col for col in resultados.columns if resultados[col].dtype in ['int64', 'float64']]

    def filtrar_variables_existentes(variables_lista):
        return [var for var in variables_lista if var in columnas_existentes]

    variables_regionales_filt = filtrar_variables_existentes(variables_regionales)
    variables_sectoriales_filt = filtrar_variables_existentes(variables_sectoriales)
    variables_corporativas_filt = filtrar_variables_existentes(variables_corporativas)
    variables_tecnologicas_filt = filtrar_variables_existentes(variables_tecnologicas)

    # Crear figura con subplots para los 4 tipos de correlaciones
    fig, axes = plt.subplots(2, 2, figsize=(20, 16))
    fig.suptitle('Matrices de Correlación por Categorías de Variables\nModelo ABM Económico Regional',
                 fontsize=16, fontweight='bold', y=0.95)

    # 1. CORRELACIONES REGIONALES
    if variables_regionales_filt:
        df_regional = resultados[variables_regionales_filt]
        corr_regional = calcular_correlacion_segura(df_regional)

        if not corr_regional.empty:
            sns.heatmap(corr_regional, annot=True, cmap='RdBu_r', center=0,
                       square=True, linewidths=0.5, cbar_kws={"shrink": .8}, ax=axes[0,0],
                       fmt='.2f', annot_kws={'size': 8})
            axes[0,0].set_title('Correlaciones REGIONALES\n(Geográficas, Desarrollo, Entorno)',
                               fontweight='bold', fontsize=12)
            axes[0,0].tick_params(axis='x', rotation=45)
            axes[0,0].tick_params(axis='y', rotation=0)
        else:
            axes[0,0].text(0.5, 0.5, 'No hay correlaciones\nregionales válidas',
                          ha='center', va='center', transform=axes[0,0].transAxes)
            axes[0,0].set_title('Correlaciones REGIONALES', fontweight='bold')
    else:
        axes[0,0].text(0.5, 0.5, 'No hay variables\nregionales disponibles',
                      ha='center', va='center', transform=axes[0,0].transAxes)
        axes[0,0].set_title('Correlaciones REGIONALES', fontweight='bold')

    # 2. CORRELACIONES SECTORIALES
    if variables_sectoriales_filt:
        df_sectorial = resultados[variables_sectoriales_filt]
        corr_sectorial = calcular_correlacion_segura(df_sectorial)

        if not corr_sectorial.empty:
            sns.heatmap(corr_sectorial, annot=True, cmap='RdBu_r', center=0,
                       square=True, linewidths=0.5, cbar_kws={"shrink": .8}, ax=axes[0,1],
                       fmt='.2f', annot_kws={'size': 8})
            axes[0,1].set_title('Correlaciones SECTORIALES\n(Diversidad, Especialización, Coordinación)',
                               fontweight='bold', fontsize=12)
            axes[0,1].tick_params(axis='x', rotation=45)
            axes[0,1].tick_params(axis='y', rotation=0)
        else:
            axes[0,1].text(0.5, 0.5, 'No hay correlaciones\nsectoriales válidas',
                          ha='center', va='center', transform=axes[0,1].transAxes)
            axes[0,1].set_title('Correlaciones SECTORIALES', fontweight='bold')
    else:
        axes[0,1].text(0.5, 0.5, 'No hay variables\nsectoriales disponibles',
                      ha='center', va='center', transform=axes[0,1].transAxes)
        axes[0,1].set_title('Correlaciones SECTORIALES', fontweight='bold')

    # 3. CORRELACIONES CORPORATIVAS
    if variables_corporativas_filt:
        df_corporativa = resultados[variables_corporativas_filt]
        corr_corporativa = calcular_correlacion_segura(df_corporativa)

        if not corr_corporativa.empty:
            sns.heatmap(corr_corporativa, annot=True, cmap='RdBu_r', center=0,
                       square=True, linewidths=0.5, cbar_kws={"shrink": .8}, ax=axes[1,0],
                       fmt='.2f', annot_kws={'size': 8})
            axes[1,0].set_title('Correlaciones CORPORATIVAS\n(Empleo, Productividad, Innovación)',
                               fontweight='bold', fontsize=12)
            axes[1,0].tick_params(axis='x', rotation=45)
            axes[1,0].tick_params(axis='y', rotation=0)
        else:
            axes[1,0].text(0.5, 0.5, 'No hay correlaciones\ncorporativas válidas',
                          ha='center', va='center', transform=axes[1,0].transAxes)
            axes[1,0].set_title('Correlaciones CORPORATIVAS', fontweight='bold')
    else:
        axes[1,0].text(0.5, 0.5, 'No hay variables\ncorporativas disponibles',
                      ha='center', va='center', transform=axes[1,0].transAxes)
        axes[1,0].set_title('Correlaciones CORPORATIVAS', fontweight='bold')

    # 4. CORRELACIONES TECNOLÓGICAS
    if variables_tecnologicas_filt:
        df_tecnologica = resultados[variables_tecnologicas_filt]
        corr_tecnologica = calcular_correlacion_segura(df_tecnologica)

        if not corr_tecnologica.empty:
            sns.heatmap(corr_tecnologica, annot=True, cmap='RdBu_r', center=0,
                       square=True, linewidths=0.5, cbar_kws={"shrink": .8}, ax=axes[1,1],
                       fmt='.2f', annot_kws={'size': 8})
            axes[1,1].set_title('Correlaciones TECNOLÓGICAS\n(Capacidad, Innovación, Actualización)',
                               fontweight='bold', fontsize=12)
            axes[1,1].tick_params(axis='x', rotation=45)
            axes[1,1].tick_params(axis='y', rotation=0)
        else:
            axes[1,1].text(0.5, 0.5, 'No hay correlaciones\\ntecnológicas válidas',
                          ha='center', va='center', transform=axes[1,1].transAxes)
            axes[1,1].set_title('Correlaciones TECNOLÓGICAS', fontweight='bold')
    else:
        axes[1,1].text(0.5, 0.5, 'No hay variables\ntecnológicas disponibles',
                      ha='center', va='center', transform=axes[1,1].transAxes)
        axes[1,1].set_title('Correlaciones TECNOLÓGICAS', fontweight='bold')

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '19_matriz_correlacion_categorizada.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # Crear gráfico adicional de correlaciones cruzadas entre categorías
    plt.figure(figsize=(14, 10))

    # Seleccionar una variable representativa de cada categoría
    variables_representativas = []
    if variables_regionales_filt:
        variables_representativas.append(('Regional', variables_regionales_filt[0]))
    if variables_sectoriales_filt:
        variables_representativas.append(('Sectorial', variables_sectoriales_filt[0]))
    if variables_corporativas_filt:
        variables_representativas.append(('Corporativa', variables_corporativas_filt[0]))
    if variables_tecnologicas_filt:
        variables_representativas.append(('Tecnológica', variables_tecnologicas_filt[0]))

    # Crear matriz de correlaciones cruzadas
    if len(variables_representativas) > 1:
        variables_cruzadas = [var[1] for var in variables_representativas]
        etiquetas_cruzadas_original = [var[0] for var in variables_representativas]

        df_cruzado = resultados[variables_cruzadas]
        corr_cruzado = calcular_correlacion_segura(df_cruzado)

        if not corr_cruzado.empty:
            # Alinear etiquetas con las columnas que sobrevivieron al filtro
            etiquetas_cruzadas = [etiquetas_cruzadas_original[i] for i, col in enumerate(variables_cruzadas) if col in corr_cruzado.columns]

            # Renombrar las etiquetas
            corr_cruzado.index = etiquetas_cruzadas
            corr_cruzado.columns = etiquetas_cruzadas

            sns.heatmap(corr_cruzado, annot=True, cmap='RdBu_r', center=0,
                       square=True, linewidths=1, cbar_kws={"shrink": .8},
                       fmt='.2f', annot_kws={'size': 12, 'weight': 'bold'})
            plt.title('Correlaciones CRUZADAS entre Categorias\nMatriz de Interdependencias Principales',
                     fontsize=14, fontweight='bold', pad=20)
            plt.tight_layout()
            plt.savefig(os.path.join(save_path, '20_correlaciones_cruzadas_categorias.png'),
                        dpi=300, bbox_inches='tight')
            plt.close()
        else:
            plt.figure(figsize=(10, 8))
            plt.text(0.5, 0.5, 'No hay correlaciones\ncruzadas válidas',
                    ha='center', va='center', fontsize=16)
            plt.title('Correlaciones CRUZADAS entre Categorias', fontsize=14, fontweight='bold')
            plt.tight_layout()
            plt.savefig(os.path.join(save_path, '20_correlaciones_cruzadas_categorias.png'),
                        dpi=300, bbox_inches='tight')
            plt.close()

    # Crear tabla de correlaciones más importantes
    correlaciones_importantes = []

    # Analizar cada categoría
    categorias_info = [
        ('Regional', variables_regionales_filt, 'Geográficas, Desarrollo, Entorno'),
        ('Sectorial', variables_sectoriales_filt, 'Diversificación, Especialización, Coordinación'),
        ('Corporativa', variables_corporativas_filt, 'Empleo, Productividad, Innovación'),
        ('Tecnológica', variables_tecnologicas_filt, 'Capacidad, Innovación, Actualización')
    ]

    for nombre_cat, variables_cat, descripcion in categorias_info:
        if len(variables_cat) > 1:
            df_cat = resultados[variables_cat]
            corr_cat = df_cat.corr()

            # Encontrar correlaciones más fuertes (excluyendo diagonal)
            corr_sin_diag = corr_cat.values
            np.fill_diagonal(corr_sin_diag, 0)

            # Encontrar correlaciones más altas
            correlaciones_planas = corr_sin_diag.flatten()
            correlaciones_planas = correlaciones_planas[correlaciones_planas != 0]

            if len(correlaciones_planas) > 0:
                corr_max = np.max(np.abs(correlaciones_planas))
                corr_promedio = np.mean(np.abs(correlaciones_planas))

                correlaciones_importantes.append({
                    'Categoría': nombre_cat,
                    'Descripción': descripcion,
                    'Variables': len(variables_cat),
                    'Correlación_Máxima': round(corr_max, 3),
                    'Correlación_Promedio': round(corr_promedio, 3)
                })

    # Guardar tabla de correlaciones
    if correlaciones_importantes:
        df_correlaciones = pd.DataFrame(correlaciones_importantes)
        df_correlaciones.to_csv(os.path.join(save_path, 'correlaciones_por_categoria.csv'),
                               index=False)

    print("✓ 19. Matriz de correlación categorizada generada exitosamente")
    print("✓ 20. Correlaciones cruzadas entre categorías generada exitosamente")
    print("✓ Tabla de correlaciones importantes guardada (correlaciones_por_categoria.csv)")

def evaluar_procesos_emergentes(resultados: pd.DataFrame, save_path: str):
    """Evalúa los procesos emergentes dinámicos del modelo según criterios específicos"""
    setup_matplotlib_for_plotting()

    print("\n=== EVALUACIÓN DE PROCESOS EMERGENTES ===")
    print("Analizando dinámicas de capital humano, loops de retroalimentación y procesos acumulativos...")

    # =============================================
    # 1. FORMACIÓN DE CAPITAL HUMANO Y PROCESOS DE APRENDIZAJE
    # =============================================

    # Calcular indicadores de formación de capital humano
    resultados_con_capital = resultados.copy()

    # Crear variables de capital humano acumulado y aprendizaje
    resultados_con_capital['capital_humano_acumulado'] = (
        resultados_con_capital.groupby('id_region')['brecha_calificacion'].cummin()
    )
    resultados_con_capital['tasa_aprendizaje'] = (
        resultados_con_capital.groupby('id_region')['brecha_calificacion'].pct_change().abs()
    )
    resultados_con_capital['progreso_formacion'] = (
        1 - resultados_con_capital['brecha_calificacion']
    )

    # =============================================
    # 2. ANÁLISIS DE BRECHAS INTER E INTRA-REGIONALES
    # =============================================

    # Brechas inter-regionales (entre regiones del mismo tipo geográfico)
    brechas_inter_regionales = []
    for tipo_region in resultados_con_capital['tipo_region'].unique():
        datos_region = resultados_con_capital[resultados_con_capital['tipo_region'] == tipo_region]
        if len(datos_region) > 1:
            promedio_habilidad = datos_region['brecha_calificacion'].mean()
            desviacion_habilidad = datos_region['brecha_calificacion'].std()
            coeficiente_variacion = desviacion_habilidad / promedio_habilidad if promedio_habilidad > 0 else 0

            brechas_inter_regionales.append({
                'tipo_region': tipo_region,
                'brecha_promedio': promedio_habilidad,
                'desviacion': desviacion_habilidad,
                'coeficiente_variacion': coeficiente_variacion
            })

    # Brechas intra-regionales (evolución temporal dentro de cada región)
    brechas_intra_regionales = []
    for region_id in resultados_con_capital['id_region'].unique():
        datos_region = resultados_con_capital[resultados_con_capital['id_region'] == region_id]
        if len(datos_region) > 1:
            brecha_inicial = datos_region['brecha_calificacion'].iloc[0]
            brecha_final = datos_region['brecha_calificacion'].iloc[-1]
            cambio_brecha = brecha_final - brecha_inicial
            variabilidad_temporal = datos_region['brecha_calificacion'].std()

            brechas_intra_regionales.append({
                'id_region': region_id,
                'brecha_inicial': brecha_inicial,
                'brecha_final': brecha_final,
                'cambio_total': cambio_brecha,
                'variabilidad_temporal': variabilidad_temporal
            })

    # =============================================
    # 3. ANÁLISIS DE LOOPS DE RETROALIMENTACIÓN POSITIVA
    # =============================================

    # Identificar loops de refuerzo entre productividad, tecnología, innovación y diversificación
    loops_refuerzo = []
    variables_loop = ['capacidad_tecnologica', 'productividad_promedio', 'tasa_innovacion', 'diversidad_sectorial']

    for region_id in resultados_con_capital['id_region'].unique():
        datos_region = resultados_con_capital[resultados_con_capital['id_region'] == region_id].copy()

        if len(datos_region) > 1:
            # Calcular correlaciones temporales entre variables del loop
            datos_region_clean = datos_region[variables_loop].dropna()

            if len(datos_region_clean) > 2:
                matriz_corr = datos_region_clean.corr()

                # Identificar patrones de refuerzo
                refuerzo_tech_prod = matriz_corr.loc['capacidad_tecnologica', 'productividad_promedio']
                refuerzo_prod_innov = matriz_corr.loc['productividad_promedio', 'tasa_innovacion']
                refuerzo_innov_div = matriz_corr.loc['tasa_innovacion', 'diversidad_sectorial']
                refuerzo_div_tech = matriz_corr.loc['diversidad_sectorial', 'capacidad_tecnologica']

                # Loop completo de refuerzo
                loop_completo = (
                    refuerzo_tech_prod > 0.3 and
                    refuerzo_prod_innov > 0.3 and
                    refuerzo_innov_div > 0.3 and
                    refuerzo_div_tech > 0.3
                )

                loops_refuerzo.append({
                    'id_region': region_id,
                    'tech_prod_corr': refuerzo_tech_prod,
                    'prod_innov_corr': refuerzo_prod_innov,
                    'innov_div_corr': refuerzo_innov_div,
                    'div_tech_corr': refuerzo_div_tech,
                    'loop_completo': loop_completo,
                    'intensidad_refuerzo': (refuerzo_tech_prod + refuerzo_prod_innov +
                                          refuerzo_innov_div + refuerzo_div_tech) / 4
                })

    # =============================================
    # 4. VISUALIZACIONES DE PROCESOS EMERGENTES
    # =============================================

    # Crear figura con subplots para procesos emergentes
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('Procesos Emergentes Dinámicos: Capital Humano, Brechas y Loops de Refuerzo\n' +
                'Modelo ABM Económico Regional - Evaluación Integral',
                fontsize=14, fontweight='bold', y=0.95)

    # Panel 1: Evolución del Capital Humano
    if len(resultados_con_capital) > 0:
        cap_humano_por_tipo = resultados_con_capital.groupby(['tipo_region_economica_inicial', 'paso_tiempo'])['progreso_formacion'].mean().reset_index()

        for tipo in cap_humano_por_tipo['tipo_region_economica_inicial'].unique():
            datos_tipo = cap_humano_por_tipo[cap_humano_por_tipo['tipo_region_economica_inicial'] == tipo]
            axes[0,0].plot(datos_tipo['paso_tiempo'], datos_tipo['progreso_formacion'],
                          marker='o', linewidth=2, label=f'{tipo}', alpha=0.8)

        axes[0,0].set_title('Progreso en Formación de Capital Humano\n(A mayor valor = menor brecha de calificación)',
                           fontweight='bold', fontsize=11)
        axes[0,0].set_xlabel('Paso de Tiempo')
        axes[0,0].set_ylabel('Progreso en Formación (1 - Brecha)')
        axes[0,0].legend()
        axes[0,0].grid(True, alpha=0.3)

    # Panel 2: Brechas Inter-Regionales
    if brechas_inter_regionales:
        df_brechas_inter = pd.DataFrame(brechas_inter_regionales)

        barras = axes[0,1].bar(range(len(df_brechas_inter)), df_brechas_inter['coeficiente_variacion'],
                              color='coral', alpha=0.7, edgecolor='black')
        axes[0,1].set_title('Brechas INTER-REGIONALES\n(Coeficiente de Variación por Tipo de Región)',
                           fontweight='bold', fontsize=11)
        axes[0,1].set_xlabel('Tipo de Región')
        axes[0,1].set_ylabel('Coeficiente de Variación\n(mayor = más heterogéneo)')
        axes[0,1].set_xticks(range(len(df_brechas_inter)))
        axes[0,1].set_xticklabels(df_brechas_inter['tipo_region'], rotation=45, ha='right')

        # Añadir valores en las barras
        for i, barra in enumerate(barras):
            altura = barra.get_height()
            axes[0,1].text(barra.get_x() + barra.get_width()/2., altura + 0.01,
                          f'{altura:.3f}', ha='center', va='bottom', fontsize=9)

    # Panel 3: Variabilidad Intra-Regional
    if brechas_intra_regionales:
        df_brechas_intra = pd.DataFrame(brechas_intra_regionales)

        # Histograma de cambios en brechas
        axes[1,0].hist(df_brechas_intra['cambio_total'], bins=15, alpha=0.7,
                      color='lightblue', edgecolor='black')
        axes[1,0].set_title('Cambios en Brechas INTRA-REGIONALES\n(Distribución de cambios temporales)',
                           fontweight='bold', fontsize=11)
        axes[1,0].set_xlabel('Cambio en Brecha de Calificación')
        axes[1,0].set_ylabel('Frecuencia')
        axes[1,0].axvline(x=0, color='red', linestyle='--', alpha=0.7, label='Sin cambio')
        axes[1,0].legend()
        axes[1,0].grid(True, alpha=0.3)

    # Panel 4: Intensidad de Loops de Refuerzo
    if loops_refuerzo:
        df_loops = pd.DataFrame(loops_refuerzo)
        loops_completos = df_loops['loop_completo'].sum()
        intensidad_promedio = df_loops['intensidad_refuerzo'].mean()

        # Gráfico de dispersión: intensidad vs regiones
        colores = ['green' if loop else 'orange' for loop in df_loops['loop_completo']]
        axes[1,1].scatter(range(len(df_loops)), df_loops['intensidad_refuerzo'],
                         c=colores, alpha=0.7, s=60, edgecolors='black')
        axes[1,1].set_title(f'Intensidad de Loops de Refuerzo\n' +
                           f'{loops_completos} regiones con loops completos\n' +
                           f'Intensidad promedio: {intensidad_promedio:.3f}',
                           fontweight='bold', fontsize=11)
        axes[1,1].set_xlabel('ID de Región')
        axes[1,1].set_ylabel('Intensidad de Refuerzo')
        axes[1,1].grid(True, alpha=0.3)
        axes[1,1].axhline(y=0.3, color='red', linestyle='--', alpha=0.7, label='Umbral mínimo')
        axes[1,1].legend()

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '21_procesos_emergentes_dinamicos.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 5. ANÁLISIS DE CONVERGENCIA Y DIVERGENCIA
    # =============================================

    # Analizar si las regiones convergen o divergen en el tiempo
    convergencia_divergecia = []

    for region_id in resultados_con_capital['id_region'].unique():
        datos_region = resultados_con_capital[resultados_con_capital['id_region'] == region_id]

        if len(datos_region) > 3:
            # Calcular tendencia temporal de la productividad (proxy del desarrollo)
            productividad = datos_region['productividad_promedio'].values
            pasos = datos_region['paso_tiempo'].values

            # Regresión lineal simple
            coeficiente = np.corrcoef(pasos, productividad)[0,1] * (np.std(productividad) / np.std(pasos))

            # Clasificar tendencia
            if coeficiente > 0.05:
                tendencia = 'Convergencia'
            elif coeficiente < -0.05:
                tendencia = 'Divergencia'
            else:
                tendencia = 'Estable'

            convergencia_divergecia.append({
                'id_region': region_id,
                'tendencia': tendencia,
                'coeficiente_tendencia': coeficiente,
                'productividad_inicial': productividad[0],
                'productividad_final': productividad[-1],
                'cambio_productividad': productividad[-1] - productividad[0]
            })

    # =============================================
    # 6. GUARDAR RESULTADOS DETALLADOS
    # =============================================

    # Guardar datos de procesos emergentes
    resultados_con_capital.to_csv(os.path.join(save_path, 'resultados_procesos_emergentes.csv'), index=False)

    # Crear tabla resumen de procesos emergentes
    resumen_emergentes = {
        'Proceso': [
            'Formación Capital Humano',
            'Brechas Inter-Regionales',
            'Brechas Intra-Regionales',
            'Loops de Refuerzo Positivo',
            'Procesos de Convergencia'
        ],
        'Descripción': [
            'Evolución temporal de habilidades y aprendizaje',
            'Heterogeneidad entre regiones del mismo tipo',
            'Variabilidad temporal dentro de cada región',
            'Refuerzo mutuo entre productividad, tech, innovación',
            'Convergencia vs divergencia de regiones'
        ],
        'Regiones_Analizadas': [
            len(resultados_con_capital['id_region'].unique()),
            len(brechas_inter_regionales),
            len(brechas_intra_regionales),
            len(loops_refuerzo),
            len(convergencia_divergecia)
        ],
        'Indicador_Principal': [
            f"{resultados_con_capital['progreso_formacion'].mean():.3f}",
            f"{np.mean([b['coeficiente_variacion'] for b in brechas_inter_regionales]):.3f}",
            f"{np.mean([b['variabilidad_temporal'] for b in brechas_intra_regionales]):.3f}",
            f"{np.mean([l['intensidad_refuerzo'] for l in loops_refuerzo]):.3f}",
            f"{len([c for c in convergencia_divergecia if c['tendencia'] == 'Convergencia'])}"
        ]
    }

    df_resumen_emergentes = pd.DataFrame(resumen_emergentes)
    df_resumen_emergentes.to_csv(os.path.join(save_path, 'resumen_procesos_emergentes.csv'), index=False)

    # Guardar datos detallados por proceso
    if brechas_inter_regionales:
        pd.DataFrame(brechas_inter_regionales).to_csv(
            os.path.join(save_path, 'brechas_inter_regionales.csv'), index=False)

    if brechas_intra_regionales:
        pd.DataFrame(brechas_intra_regionales).to_csv(
            os.path.join(save_path, 'brechas_intra_regionales.csv'), index=False)

    if loops_refuerzo:
        pd.DataFrame(loops_refuerzo).to_csv(
            os.path.join(save_path, 'loops_refuerzo_positivo.csv'), index=False)

    if convergencia_divergecia:
        pd.DataFrame(convergencia_divergecia).to_csv(
            os.path.join(save_path, 'convergencia_divergecia_regiones.csv'), index=False)

    print("✓ 21. Procesos emergentes dinámicos evaluados exitosamente")
    print(f"  - Formación capital humano: {len(resultados_con_capital['id_region'].unique())} regiones analizadas")
    print(f"  - Brechas inter-regionales: {len(brechas_inter_regionales)} tipos de región")
    print(f"  - Brechas intra-regionales: {len(brechas_intra_regionales)} regiones temporales")
    print(f"  - Loops de refuerzo: {len(loops_refuerzo)} regiones con análisis de loops")
    print(f"  - Convergencia/divergencia: {len(convergencia_divergecia)} regiones evaluadas")

def crear_tabla_resumen_tipologico(resultados: pd.DataFrame, save_path: str):
    """Crea tabla resumen por tipología regional con todas las métricas"""

    # Crear tabla de resumen por tipología inicial con todas las métricas
    tabla_resumen = resultados.groupby('tipo_region_economica_inicial').agg({
        'capacidad_tecnologica': ['mean', 'std', 'min', 'max'],
        'innovaciones_realizadas': ['mean', 'std', 'sum'],
        'tasa_innovacion': ['mean', 'std', 'min', 'max'],
        'actualizacion_tecnologica': ['mean', 'std', 'min', 'max'],
        'diversidad_sectorial': ['mean', 'std', 'min', 'max'],
        'especializacion': ['mean', 'std', 'min', 'max'],
        'productividad_promedio': ['mean', 'std'],
        'coordinacion_promedio': ['mean', 'std'],
        'atrapada': 'mean',
        'empleo_especializado': ['mean', 'std'],
        'empleo_total': ['mean', 'std'],
        'empleo_especializado_region': ['mean', 'std'],
        'empleo_total_region': ['mean', 'std'],
        'brecha_calificacion': ['mean', 'std', 'min', 'max'],
        'eficiencia_asignacion': ['mean', 'std']
    }).round(4)

    # Aplanar columnas multi-nivel
    tabla_resumen.columns = ['_'.join(col).strip() for col in tabla_resumen.columns.values]

    # Añadir métricas calculadas
    tabla_resumen['Tasa_Empleo_Especializado_Pct'] = (
        tabla_resumen['empleo_especializado_mean'] / tabla_resumen['empleo_total_mean'] * 100
    ).round(2)

    tabla_resumen['Tasa_Empleo_Especializado_Region_Pct'] = (
        tabla_resumen['empleo_especializado_region_mean'] / tabla_resumen['empleo_total_region_mean'] * 100
    ).round(2)

    tabla_resumen['Porcentaje_Atrapadas'] = (
        tabla_resumen['atrapada_mean'] * 100
    ).round(2)

    # Calcular métricas de productividad
    tabla_resumen['Productividad_Por_Empleado'] = (
        tabla_resumen['productividad_promedio_mean'] / np.maximum(0.01, tabla_resumen['empleo_especializado_mean'])
    ).round(4)

    tabla_resumen['Eficiencia_Innovadora'] = (
        tabla_resumen['productividad_promedio_mean'] / np.maximum(0.001, tabla_resumen['tasa_innovacion_mean'])
    ).round(2)

    tabla_resumen['Productividad_Tecnologica'] = (
        tabla_resumen['productividad_promedio_mean'] / np.maximum(0.01, tabla_resumen['capacidad_tecnologica_mean'])
    ).round(2)

    tabla_resumen['Indice_Competitividad'] = (
        (tabla_resumen['productividad_promedio_mean'] * tabla_resumen['tasa_innovacion_mean']) /
        np.maximum(0.001, tabla_resumen['brecha_calificacion_mean'])
    ).round(4)

    tabla_resumen['Productividad_Especializada'] = (
        tabla_resumen['productividad_promedio_mean'] * tabla_resumen['especializacion_mean']
    ).round(3)

    tabla_resumen['Productividad_Diversificada'] = (
        tabla_resumen['productividad_promedio_mean'] * tabla_resumen['diversidad_sectorial_mean']
    ).round(3)

    tabla_resumen['Eficiencia_Capital_Humano'] = (
        tabla_resumen['productividad_promedio_mean'] * (1 - tabla_resumen['brecha_calificacion_mean'])
    ).round(3)

    # Renombrar columnas para claridad con todas las métricas
    new_column_names = {
        'capacidad_tecnologica_mean': 'CapTech_Media',
        'capacidad_tecnologica_std': 'CapTech_Std',
        'tasa_innovacion_mean': 'TasaInnov_Media',
        'tasa_innovacion_std': 'TasaInnov_Std',
        'actualizacion_tecnologica_mean': 'ActualizacionTec_Media',
        'actualizacion_tecnologica_std': 'ActualizacionTec_Std',
        'innovaciones_realizadas_mean': 'Innovaciones_Media',
        'innovaciones_realizadas_sum': 'Innovaciones_Total',
        'diversidad_sectorial_mean': 'Diversidad_Media',
        'diversidad_sectorial_std': 'Diversidad_Std',
        'especializacion_mean': 'Especializacion_Media',
        'especializacion_std': 'Especializacion_Std',
        'productividad_promedio_mean': 'Productividad_Media',
        'productividad_promedio_std': 'Productividad_Std',
        'coordinacion_promedio_mean': 'Coordinacion_Media',
        'coordinacion_promedio_std': 'Coordinacion_Std',
        'empleo_especializado_mean': 'EmpleoEsp_Media',
        'empleo_especializado_std': 'EmpleoEsp_Std',
        'empleo_total_mean': 'EmpleoTotal_Media',
        'empleo_total_std': 'EmpleoTotal_Std',
        'empleo_especializado_region_mean': 'EmpleoEspReg_Media',
        'empleo_especializado_region_std': 'EmpleoEspReg_Std',
        'empleo_total_region_mean': 'EmpleoTotalReg_Media',
        'empleo_total_region_std': 'EmpleoTotalReg_Std',
        'brecha_calificacion_mean': 'BrechaCalif_Media',
        'brecha_calificacion_std': 'BrechaCalif_Std',
        'brecha_calificacion_min': 'BrechaCalif_Min',
        'brecha_calificacion_max': 'BrechaCalif_Max',
        'eficiencia_asignacion_mean': 'EficienciaAsig_Media',
        'eficiencia_asignacion_std': 'EficienciaAsig_Std',
        # Agregar todas las métricas calculadas
        'Tasa_Empleo_Especializado_Pct': 'Tasa_Empleo_Especializado_Pct',
        'Tasa_Empleo_Especializado_Region_Pct': 'Tasa_Empleo_Especializado_Region_Pct',
        'Porcentaje_Atrapadas': 'Porcentaje_Atrapadas',
        'Productividad_Por_Empleado': 'Productividad_Por_Empleado',
        'Eficiencia_Innovadora': 'Eficiencia_Innovadora',
        'Productividad_Tecnologica': 'Productividad_Tecnologica',
        'Indice_Competitividad': 'Indice_Competitividad',
        'Productividad_Especializada': 'Productividad_Especializada',
        'Productividad_Diversificada': 'Productividad_Diversificada',
        'Eficiencia_Capital_Humano': 'Eficiencia_Capital_Humano'
    }

    tabla_resumen.rename(columns=new_column_names, inplace=True)

    # Guardar tabla
    tabla_resumen.to_csv(os.path.join(save_path, 'tabla_resumen_tipologico.csv'), encoding='utf-8')
    print("\n=== TABLA RESUMEN TIPOLÓGICO COMPLETA ===")
    print(tabla_resumen)
    return tabla_resumen

def analizar_trampa_innovacion_mercado_laboral(resultados: pd.DataFrame, save_path: str):
    """
    Análisis específico de la trampa de innovación relacionada con la estructura del mercado laboral

    Evalúa:
    - Polarización de empleos (alta calidad vs baja calidad)
    - Ventaja competitiva estática del mercado laboral
    - Círculo vicioso experiencia-valor diluido en entornos de baja tecnología
    - Dependencia de sectores específicos
    - Perpetuación de empleos de baja calidad
    """

    from scipy import stats
    from scipy.stats import pearsonr, spearmanr
    import numpy as np

    print("\n=== ANÁLISIS DE TRAMPA DE INNOVACIÓN: MERCADO LABORAL ===")

    # Preparar datos para análisis del mercado laboral
    resultados_laboral = resultados[['id_region', 'paso_tiempo', 'tipo_region_economica_inicial',
                                   'empleo_especializado', 'empleo_total', 'brecha_calificacion',
                                   'capacidad_tecnologica', 'tasa_innovacion', 'productividad_promedio',
                                   'especializacion', 'diversidad_sectorial']].copy()

    # =============================================
    # 1. POLARIZACIÓN DEL MERCADO LABORAL
    # =============================================

    # Clasificar empleos por calidad
    def clasificar_calidad_empleo(row):
        """Clasifica empleos según su calidad basada en múltiples factores"""
        empleo_especializado_ratio = row['empleo_especializado'] / max(1, row['empleo_total'])
        baja_brecha = (1 - row['brecha_calificacion'])  # Invertir brecha
        alta_capacidad = row['capacidad_tecnologica']
        alta_productividad = row['productividad_promedio'] / 50  # Normalizar productividad

        # Índice compuesto de calidad de empleo
        indice_calidad = (
            0.3 * empleo_especializado_ratio +
            0.25 * baja_brecha +
            0.25 * min(1.0, alta_capacidad / 1.5) +
            0.2 * min(1.0, alta_productividad)
        )

        if indice_calidad > 0.6:
            return 'Alta_Calidad'
        elif indice_calidad > 0.3:
            return 'Media_Calidad'
        else:
            return 'Baja_Calidad'

    resultados_laboral['calidad_empleo'] = resultados_laboral.apply(clasificar_calidad_empleo, axis=1)

    # Analizar polarización por región y tipología
    polarizacion_regional = []

    for region_id in resultados_laboral['id_region'].unique():
        datos_region = resultados_laboral[resultados_laboral['id_region'] == region_id]
        tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

        # Contar empleos por calidad
        conteo_calidades = datos_region['calidad_empleo'].value_counts()
        total_empleos = len(datos_region)

        alta_calidad_pct = conteo_calidades.get('Alta_Calidad', 0) / total_empleos * 100
        media_calidad_pct = conteo_calidades.get('Media_Calidad', 0) / total_empleos * 100
        baja_calidad_pct = conteo_calidades.get('Baja_Calidad', 0) / total_empleos * 100

        # Índice de polarización (diferencia entre empleos alta y baja calidad)
        indice_polarizacion = abs(alta_calidad_pct - baja_calidad_pct)

        polarizacion_regional.append({
            'id_region': region_id,
            'tipologia': tipologia,
            'empleos_alta_calidad_pct': alta_calidad_pct,
            'empleos_media_calidad_pct': media_calidad_pct,
            'empleos_baja_calidad_pct': baja_calidad_pct,
            'indice_polarizacion': indice_polarizacion,
            'empleos_alta_calidad_abs': conteo_calidades.get('Alta_Calidad', 0),
            'empleos_baja_calidad_abs': conteo_calidades.get('Baja_Calidad', 0)
        })

    df_polarizacion = pd.DataFrame(polarizacion_regional)

    # =============================================
    # 2. VENTAJA COMPETITIVA ESTÁTICA
    # =============================================

    # Calcular ventaja competitiva estática basada en estructura laboral
    resultados_laboral['ventaja_competitiva_estatica'] = (
        resultados_laboral['empleo_especializado'] / np.maximum(1, resultados_laboral['empleo_total']) *
        (1 - resultados_laboral['brecha_calificacion']) *
        resultados_laboral['productividad_promedio'] / 100
    )

    # =============================================
    # 3. CÍRCULO VICIOSO EXPERIENCIA-VALOR DILUIDO
    # =============================================

    # Simular el efecto de experiencia que se diluye en baja tecnología
    circulo_vicioso = []

    for region_id in resultados_laboral['id_region'].unique():
        datos_region = resultados_laboral[resultados_laboral['id_region'] == region_id].sort_values('paso_tiempo')
        tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

        if len(datos_region) > 3:
            # Calcular métricas de experiencia acumulada vs valor diluido
            capacidad_tech_promedio = datos_region['capacidad_tecnologica'].mean()
            brecha_calif_promedio = datos_region['brecha_calificacion'].mean()

            # Simular experiencia acumulada (basada en continuidad laboral)
            experiencia_simulada = np.cumsum(datos_region['empleo_especializado'] + datos_region['empleo_total'])

            # Valor diluido por baja tecnología (inversamente proporcional a capacidad tech)
            factor_dilucion = 1 / (1 + capacidad_tech_promedio)
            valor_real_experiencia = experiencia_simulada * factor_dilucion

            # Valor potencial en alta tecnología
            valor_potencial_experiencia = experiencia_simulada * 1.2

            # Pérdida de valor por dilución tecnológica
            perdida_valor = np.mean((valor_potencial_experiencia - valor_real_experiencia) / valor_potencial_experiencia)

            # Correlación entre experiencia y productividad (debe ser baja en trampa)
            if len(datos_region) > 5:
                corr_exp_prod = datos_region['empleo_total'].corr(datos_region['productividad_promedio'])
                corr_exp_innov = datos_region['empleo_total'].corr(datos_region['tasa_innovacion'])
            else:
                corr_exp_prod = 0
                corr_exp_innov = 0

            circulo_vicioso.append({
                'id_region': region_id,
                'tipologia': tipologia,
                'capacidad_tech_promedio': capacidad_tech_promedio,
                'brecha_calif_promedio': brecha_calif_promedio,
                'factor_dilucion': factor_dilucion,
                'perdida_valor_experiencia': perdida_valor,
                'corr_experiencia_productividad': corr_exp_prod,
                'corr_experiencia_innovacion': corr_exp_innov,
                'en_trampa_experiencia': (perdida_valor > 0.3) and (corr_exp_prod < 0.3)
            })

    df_circulo_vicioso = pd.DataFrame(circulo_vicioso)

    # =============================================
    # 4. DEPENDENCIA SECTORIAL ESPECÍFICA
    # =============================================

    # Calcular índice de dependencia sectorial
    dependencia_sectorial = []

    for region_id in resultados_laboral['id_region'].unique():
        datos_region = resultados_laboral[resultados_laboral['id_region'] == region_id]
        tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

        # Índice de especialización (Herfindahl-Hirschman invertido)
        especializacion_promedio = datos_region['especializacion'].mean()
        diversidad_promedio = datos_region['diversidad_sectorial'].mean()

        # Dependencia sectorial como proporción inversa de diversidad
        indice_dependencia = especializacion_promedio / (especializacion_promedio + diversidad_promedio + 0.01)

        # Vulnerabilidad por dependencia (alta cuando dependencia > 0.7)
        vulnerabilidad_dependencia = 'Alta' if indice_dependencia > 0.7 else 'Media' if indice_dependencia > 0.4 else 'Baja'

        dependencia_sectorial.append({
            'id_region': region_id,
            'tipologia': tipologia,
            'especializacion_promedio': especializacion_promedio,
            'diversidad_promedio': diversidad_promedio,
            'indice_dependencia_sectorial': indice_dependencia,
            'vulnerabilidad_dependencia': vulnerabilidad_dependencia
        })

    df_dependencia = pd.DataFrame(dependencia_sectorial)

    # =============================================
    # 5. PERPETUACIÓN DE EMPLEOS DE BAJA CALIDAD
    # =============================================

    # Analizar autosuficiencia en generación de empleos de alta calidad
    perpetuacion_empleos = []

    for tipologia in resultados_laboral['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados_laboral[resultados_laboral['tipo_region_economica_inicial'] == tipologia]

        # Proporción de empleos de baja calidad
        empleos_baja_calidad = len(datos_tipologia[datos_tipologia['calidad_empleo'] == 'Baja_Calidad'])
        total_empleos = len(datos_tipologia)
        proporcion_baja_calidad = empleos_baja_calidad / total_empleos

        # Capacidad de auto-mejora (correlación entre tiempo y mejora en calidad)
        if len(datos_tipologia) > 10:
            datos_tiempo = datos_tipologia.groupby('paso_tiempo')['calidad_empleo'].apply(
                lambda x: (x == 'Alta_Calidad').sum() / len(x)
            ).reset_index()
            datos_tiempo.columns = ['paso_tiempo', 'proporcion_alta_calidad']

            corr_tiempo_calidad = datos_tiempo['paso_tiempo'].corr(datos_tiempo['proporcion_alta_calidad'])
        else:
            corr_tiempo_calidad = 0

        # Tasa de transición empleos baja->alta calidad
        transiciones_baja_alta = 0
        regiones_con_transicion = 0

        for region_id in datos_tipologia['id_region'].unique():
            datos_region = datos_tipologia[datos_tipologia['id_region'] == region_id].sort_values('paso_tiempo')
            secuencia_calidad = datos_region['calidad_empleo'].tolist()

            # Detectar transición de baja a alta calidad
            if 'Baja_Calidad' in secuencia_calidad and 'Alta_Calidad' in secuencia_calidad:
                indices_baja = [i for i, cal in enumerate(secuencia_calidad) if cal == 'Baja_Calidad']
                indices_alta = [i for i, cal in enumerate(secuencia_calidad) if cal == 'Alta_Calidad']

                if min(indices_alta) > min(indices_baja):  # Transición real
                    transiciones_baja_alta += 1

            regiones_con_transicion += 1

        tasa_transicion = transiciones_baja_alta / max(1, regiones_con_transicion)

        perpetuacion_empleos.append({
            'tipologia': tipologia,
            'proporcion_empleos_baja_calidad': proporcion_baja_calidad,
            'corr_tiempo_mejora_calidad': corr_tiempo_calidad,
            'tasa_transicion_baja_alta': tasa_transicion,
            'regiones_con_transicion': transiciones_baja_alta,
            'total_regiones': regiones_con_transicion,
            'perpetuacion_alta': proporcion_baja_calidad > 0.6 and tasa_transicion < 0.3
        })

    df_perpetuacion = pd.DataFrame(perpetuacion_empleos)

    # =============================================
    # 6. VISUALIZACIÓN INTEGRAL
    # =============================================

    fig, axes = plt.subplots(2, 3, figsize=(20, 12))
    fig.suptitle('Trampa de Innovación: Estructura del Mercado Laboral\\n' +
                'Polarización • Ventaja Estática • Círculo Vicioso • Dependencia Sectorial',
                fontsize=16, fontweight='bold', y=0.95)

    # Panel 1: Distribución de empleos por calidad y tipología
    if not df_polarizacion.empty:
        tipologias = df_polarizacion['tipologia'].unique()
        x_pos = np.arange(len(tipologias))
        width = 0.25

        alta_calidad = [df_polarizacion[df_polarizacion['tipologia'] == t]['empleos_alta_calidad_pct'].mean() for t in tipologias]
        media_calidad = [df_polarizacion[df_polarizacion['tipologia'] == t]['empleos_media_calidad_pct'].mean() for t in tipologias]
        baja_calidad = [df_polarizacion[df_polarizacion['tipologia'] == t]['empleos_baja_calidad_pct'].mean() for t in tipologias]

        axes[0,0].bar(x_pos - width, alta_calidad, width, label='Alta Calidad', color='green', alpha=0.7)
        axes[0,0].bar(x_pos, media_calidad, width, label='Media Calidad', color='yellow', alpha=0.7)
        axes[0,0].bar(x_pos + width, baja_calidad, width, label='Baja Calidad', color='red', alpha=0.7)

        axes[0,0].set_xlabel('Tipología Regional')
        axes[0,0].set_ylabel('Porcentaje de Empleos')
        axes[0,0].set_title('Polarización del Mercado Laboral\\npor Tipología', fontweight='bold')
        axes[0,0].set_xticks(x_pos)
        axes[0,0].set_xticklabels(tipologias, rotation=45, ha='right')
        axes[0,0].legend()
        axes[0,0].grid(True, alpha=0.3)

    # Panel 2: Ventaja competitiva estática vs capacidad innovadora
    axes[0,1].scatter(resultados_laboral['ventaja_competitiva_estatica'],
                     resultados_laboral['tasa_innovacion'],
                     c=resultados_laboral['capacidad_tecnologica'],
                     cmap='viridis', alpha=0.6)
    axes[0,1].set_xlabel('Ventaja Competitiva Estática')
    axes[0,1].set_ylabel('Tasa de Innovación')
    axes[0,1].set_title('Ventaja Estática vs\\nCapacidad Innovadora', fontweight='bold')

    # Panel 3: Círculo vicioso - Pérdida de valor por dilución tecnológica
    if not df_circulo_vicioso.empty:
        scatter = axes[0,2].scatter(df_circulo_vicioso['capacidad_tech_promedio'],
                                   df_circulo_vicioso['perdida_valor_experiencia'],
                                   c=df_circulo_vicioso['brecha_calif_promedio'],
                                   cmap='RdYlBu_r', alpha=0.7, s=80)
        axes[0,2].set_xlabel('Capacidad Tecnológica Promedio')
        axes[0,2].set_ylabel('Pérdida de Valor de Experiencia')
        axes[0,2].set_title('Círculo Vicioso:\\nExperiencia Diluida por Baja Tecnología', fontweight='bold')

        # Línea de trampa (>30% pérdida)
        axes[0,2].axhline(y=0.3, color='red', linestyle='--', alpha=0.7, label='Umbral Trampa (30%)')
        axes[0,2].legend()
        plt.colorbar(scatter, ax=axes[0,2], label='Brecha Calificación')

    # Panel 4: Dependencia sectorial y vulnerabilidad
    if not df_dependencia.empty:
        dependencia_counts = df_dependencia['vulnerabilidad_dependencia'].value_counts()
        colores_vuln = {'Baja': 'green', 'Media': 'yellow', 'Alta': 'red'}
        colores_ordenados = [colores_vuln.get(vuln, 'gray') for vuln in dependencia_counts.index]

        axes[1,0].pie(dependencia_counts.values, labels=dependencia_counts.index,
                     autopct='%1.1f%%', colors=colores_ordenados, startangle=90)
        axes[1,0].set_title('Vulnerabilidad por\\nDependencia Sectorial', fontweight='bold')

    # Panel 5: Evolución de la calidad de empleos en el tiempo
    evolucion_calidad = resultados_laboral.groupby(['paso_tiempo', 'calidad_empleo']).size().unstack(fill_value=0)
    if not evolucion_calidad.empty and 'Alta_Calidad' in evolucion_calidad.columns and 'Baja_Calidad' in evolucion_calidad.columns:
        axes[1,1].plot(evolucion_calidad.index, evolucion_calidad['Alta_Calidad'],
                      'g-', linewidth=2, label='Empleos Alta Calidad', marker='o')
        axes[1,1].plot(evolucion_calidad.index, evolucion_calidad['Baja_Calidad'],
                      'r-', linewidth=2, label='Empleos Baja Calidad', marker='s')
        axes[1,1].set_xlabel('Paso de Tiempo')
        axes[1,1].set_ylabel('Número de Empleos')
        axes[1,1].set_title('Evolución Temporal de\\nCalidad de Empleos', fontweight='bold')
        axes[1,1].legend()
        axes[1,1].grid(True, alpha=0.3)

    # Panel 6: Matriz de correlaciones - Trampa de innovación
    variables_trampa = ['ventaja_competitiva_estatica', 'brecha_calificacion', 'capacidad_tecnologica',
                       'empleo_especializado', 'productividad_promedio']
    datos_correlacion = resultados_laboral[variables_trampa]

    if not datos_correlacion.empty:
        matriz_corr = calcular_correlacion_segura(datos_correlacion)
        if not matriz_corr.empty:
            im = axes[1,2].imshow(matriz_corr, cmap='RdBu_r', aspect='auto', vmin=-1, vmax=1)
            axes[1,2].set_xticks(range(len(variables_trampa)))
            axes[1,2].set_yticks(range(len(variables_trampa)))
            axes[1,2].set_xticklabels([var.replace('_', '\\n') for var in variables_trampa], rotation=45, ha='right')
            axes[1,2].set_yticklabels([var.replace('_', '\\n') for var in variables_trampa])
            axes[1,2].set_title('Correlaciones en la\\nTrampa de Innovacion', fontweight='bold')

            # Añadir valores de correlación
            for i in range(len(matriz_corr)):
                for j in range(len(matriz_corr)):
                    text = axes[1,2].text(j, i, f'{matriz_corr.iloc[i, j]:.2f}',
                                        ha="center", va="center", color="black", fontsize=8)

            plt.colorbar(im, ax=axes[1,2], shrink=0.8)
        else:
            axes[1,2].text(0.5, 0.5, 'No hay correlaciones\nválidas en la trampa',
                          ha='center', va='center', transform=axes[1,2].transAxes)
            axes[1,2].set_title('Correlaciones en la\nTrampa de Innovacion', fontweight='bold')

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '23_trampa_innovacion_mercado_laboral.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 7. EVALUACIÓN INTEGRAL DE LA TRAMPA
    # =============================================

    # Crear índice compuesto de trampa de innovación
    resultados_trampa = resultados_laboral.groupby('id_region').agg({
        'ventaja_competitiva_estatica': 'mean',
        'brecha_calificacion': 'mean',
        'capacidad_tecnologica': 'mean',
        'empleo_especializado': 'mean',
        'empleo_total': 'mean',
        'tasa_innovacion': 'mean',
        'productividad_promedio': 'mean'
    }).round(4)

    # Calcular índice de trampa de innovación
    resultados_trampa['indice_polarizacion'] = df_polarizacion.set_index('id_region')['indice_polarizacion']
    resultados_trampa['perdida_valor_experiencia'] = df_circulo_vicioso.set_index('id_region')['perdida_valor_experiencia']
    resultados_trampa['indice_dependencia_sectorial'] = df_dependencia.set_index('id_region')['indice_dependencia_sectorial']

    # Normalizar variables para el índice (0-1)
    for col in ['ventaja_competitiva_estatica', 'indice_polarizacion', 'perdida_valor_experiencia', 'indice_dependencia_sectorial']:
        if col in resultados_trampa.columns:
            max_val = resultados_trampa[col].max()
            min_val = resultados_trampa[col].min()
            if max_val > min_val:
                resultados_trampa[f'{col}_norm'] = (resultados_trampa[col] - min_val) / (max_val - min_val)
            else:
                resultados_trampa[f'{col}_norm'] = 0

    # Índice compuesto de trampa (ponderado)
    if all(col in resultados_trampa.columns for col in ['ventaja_competitiva_estatica_norm', 'indice_polarizacion_norm',
                                                       'perdida_valor_experiencia_norm', 'indice_dependencia_sectorial_norm']):
        resultados_trampa['indice_trampa_innovacion'] = (
            0.3 * resultados_trampa['ventaja_competitiva_estatica_norm'] +
            0.25 * resultados_trampa['indice_polarizacion_norm'] +
            0.25 * resultados_trampa['perdida_valor_experiencia_norm'] +
            0.2 * resultados_trampa['indice_dependencia_sectorial_norm']
        )
    else:
        resultados_trampa['indice_trampa_innovacion'] = 0.5  # Valor por defecto

    # Añadir tipología
    tipologias_map = resultados_laboral.groupby('id_region')['tipo_region_economica_inicial'].first()
    resultados_trampa['tipologia'] = tipologias_map

    # =============================================
    # 8. GUARDAR RESULTADOS
    # =============================================

    df_polarizacion.to_csv(os.path.join(save_path, 'polarizacion_mercado_laboral.csv'), index=False)
    df_circulo_vicioso.to_csv(os.path.join(save_path, 'circulo_vicioso_experiencia_valor.csv'), index=False)
    df_dependencia.to_csv(os.path.join(save_path, 'dependencia_sectorial.csv'), index=False)
    df_perpetuacion.to_csv(os.path.join(save_path, 'perpetuacion_empleos_baja_calidad.csv'), index=False)
    resultados_trampa.to_csv(os.path.join(save_path, 'indice_trampa_innovacion.csv'), index=False)

    # Resumen ejecutivo
    resumen_trampa = {
        'total_regiones_analizadas': len(df_polarizacion),
        'regiones_en_trampa_experiencia': len(df_circulo_vicioso[df_circulo_vicioso['en_trampa_experiencia'] == True]),
        'regiones_alta_dependencia_sectorial': len(df_dependencia[df_dependencia['vulnerabilidad_dependencia'] == 'Alta']),
        'tipologias_perpetuacion_alta': len(df_perpetuacion[df_perpetuacion['perpetuacion_alta'] == True]),
        'polarizacion_promedio': df_polarizacion['indice_polarizacion'].mean(),
        'perdida_valor_experiencia_promedio': df_circulo_vicioso['perdida_valor_experiencia'].mean(),
        'indice_trampa_promedio': resultados_trampa['indice_trampa_innovacion'].mean(),
        'tipologia_mayor_trampa': resultados_trampa.groupby('tipologia')['indice_trampa_innovacion'].mean().idxmax() if not resultados_trampa.empty else 'N/A'
    }

    pd.DataFrame([resumen_trampa]).to_csv(os.path.join(save_path, 'resumen_trampa_innovacion.csv'), index=False)

    # =============================================
    # 9. IMPRIMIR RESULTADOS
    # =============================================

    print(f"✓ Análisis de trampa de innovación completado")
    print(f"  - Polarización del mercado laboral: {len(df_polarizacion)} regiones analizadas")
    print(f"  - Círculo vicioso experiencia-valor: {len(df_circulo_vicioso)} regiones evaluadas")
    print(f"  - Dependencia sectorial: {len(df_dependencia)} regiones clasificadas")
    print(f"  - Perpetuación empleos baja calidad: {len(df_perpetuacion)} tipologías analizadas")
    print(f"  - Índice trampa innovación: {len(resultados_trampa)} regiones medidas")
    print(f"\\n  📊 HALLAZGOS CLAVE:")
    print(f"  - Regiones en trampa experiencia: {resumen_trampa['regiones_en_trampa_experiencia']}")
    print(f"  - Alta dependencia sectorial: {resumen_trampa['regiones_alta_dependencia_sectorial']}")
    print(f"  - Polarización promedio: {resumen_trampa['polarizacion_promedio']:.2f}%")
    print(f"  - Pérdida valor experiencia promedio: {resumen_trampa['perdida_valor_experiencia_promedio']:.1%}")
    print(f"  - Tipología con mayor trampa: {resumen_trampa['tipologia_mayor_trampa']}")

    return {
        'polarizacion': df_polarizacion,
        'circulo_vicioso': df_circulo_vicioso,
        'dependencia': df_dependencia,
        'perpetuacion': df_perpetuacion,
        'indice_trampa': resultados_trampa,
        'resumen': resumen_trampa
    }

def analizar_evolucion_cambio_tecnico(resultados: pd.DataFrame, save_path: str):
    """
    Análisis integral de la evolución del cambio técnico

    Incluye:
    - Trayectorias tecnológicas por región y tipología
    - Velocidades de cambio técnico
    - Convergencia tecnológica entre regiones
    - Índices de madurez tecnológica compuestos
    - Análisis de spillovers y difusión tecnológica
    - Clasificación de tipos de cambio (incremental vs radical)
    - Análisis temporal multiescala
    """

    from scipy import stats
    from scipy.stats import linregress
    import numpy as np
    from sklearn.preprocessing import StandardScaler
    from sklearn.cluster import KMeans

    print("\n=== ANÁLISIS DE EVOLUCIÓN DEL CAMBIO TÉCNICO ===")

    # Preparar datos para análisis temporal
    resultados_tecnologia = resultados[['id_region', 'paso_tiempo', 'tipo_region_economica_inicial',
                                       'capacidad_tecnologica', 'tasa_innovacion', 'actualizacion_tecnologica',
                                       'productividad_promedio', 'diversidad_sectorial']].copy()

    # =============================================
    # 1. ANÁLISIS DE TRAYECTORIAS TECNOLÓGICAS
    # =============================================

    trayectorias_tecnologicas = []

    for region_id in resultados_tecnologia['id_region'].unique():
        datos_region = resultados_tecnologia[resultados_tecnologia['id_region'] == region_id].copy()
        datos_region = datos_region.sort_values('paso_tiempo')

        if len(datos_region) > 3:  # Mínimo 4 puntos para análisis de tendencia
            tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

            # Calcular métricas de trayectoria
            x = datos_region['paso_tiempo'].values
            y_cap_tec = datos_region['capacidad_tecnologica'].values
            y_innov = datos_region['tasa_innovacion'].values
            y_actualiz = datos_region['actualizacion_tecnologica'].values

            # Regresiones lineales para tendencia
            slope_cap, intercept_cap, r_cap, p_cap, se_cap = linregress(x, y_cap_tec)
            slope_innov, intercept_innov, r_innov, p_innov, se_innov = linregress(x, y_innov)
            slope_act, intercept_act, r_act, p_act, se_act = linregress(x, y_actualiz)

            # Clasificar tipo de trayectoria
            crecimiento_tecnologico = slope_cap > 0.01
            crecimiento_innovacion = slope_innov > 0.001
            volatilidad_tecnologica = np.std(y_cap_tec) / np.mean(y_cap_tec) if np.mean(y_cap_tec) > 0 else 0

            if crecimiento_tecnologico and crecimiento_innovacion:
                tipo_trayectoria = 'Acelerada'
            elif crecimiento_tecnologico or crecimiento_innovacion:
                tipo_trayectoria = 'Moderada'
            else:
                tipo_trayectoria = 'Estancada'

            trayectorias_tecnologicas.append({
                'id_region': region_id,
                'tipologia': tipologia,
                'slope_capacidad_tecnologica': slope_cap,
                'r2_capacidad_tecnologica': r_cap**2,
                'p_value_capacidad_tecnologica': p_cap,
                'slope_tasa_innovacion': slope_innov,
                'r2_tasa_innovacion': r_innov**2,
                'p_value_tasa_innovacion': p_innov,
                'slope_actualizacion_tecnologica': slope_act,
                'r2_actualizacion_tecnologica': r_act**2,
                'p_value_actualizacion_tecnologica': p_act,
                'volatilidad_tecnologica': volatilidad_tecnologica,
                'tipo_trayectoria': tipo_trayectoria,
                'capacidad_inicial': y_cap_tec[0],
                'capacidad_final': y_cap_tec[-1],
                'cambio_absoluto_tecnologia': y_cap_tec[-1] - y_cap_tec[0],
                'tasa_crecimiento_promedio': slope_cap * 100
            })

    df_trayectorias = pd.DataFrame(trayectorias_tecnologicas)

    # =============================================
    # 2. ÍNDICES DE MADUREZ TECNOLÓGICA COMPUESTOS
    # =============================================

    # Crear índice compuesto de madurez tecnológica
    def calcular_indice_madurez(row):
        """Índice compuesto de 0-1 basado en múltiples variables tecnológicas"""
        capacidad_norm = min(1.0, row['capacidad_tecnologica'] / 1.5)  # Normalizar
        innovacion_norm = min(1.0, row['tasa_innovacion'] / 0.20)     # Normalizar
        actualizacion_norm = min(1.0, row['actualizacion_tecnologica'] / 0.10)  # Normalizar
        productividad_norm = min(1.0, row['productividad_promedio'] / 1.0)     # Normalizar

        # Índice ponderado
        indice = (0.35 * capacidad_norm + 0.25 * innovacion_norm +
                 0.25 * actualizacion_norm + 0.15 * productividad_norm)
        return min(1.0, indice)

    resultados_tecnologia['indice_madurez_tecnologica'] = resultados_tecnologia.apply(
        calcular_indice_madurez, axis=1
    )

    # Calcular evolución del índice de madurez por región
    madurez_temporal = []
    for region_id in resultados_tecnologia['id_region'].unique():
        datos_region = resultados_tecnologia[resultados_tecnologia['id_region'] == region_id]
        tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

        madurez_inicial = datos_region['indice_madurez_tecnologica'].iloc[0]
        madurez_final = datos_region['indice_madurez_tecnologica'].iloc[-1]

        madurez_temporal.append({
            'id_region': region_id,
            'tipologia': tipologia,
            'madurez_inicial': madurez_inicial,
            'madurez_final': madurez_final,
            'mejora_madurez': madurez_final - madurez_inicial,
            'tasa_mejora_madurez': ((madurez_final - madurez_inicial) / max(0.01, madurez_inicial)) * 100
        })

    df_madurez_temporal = pd.DataFrame(madurez_temporal)

    # =============================================
    # 3. ANÁLISIS DE CONVERGENCIA TECNOLÓGICA
    # =============================================

    convergencia_tecnologica = []

    for tipologia in resultados_tecnologia['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados_tecnologia[resultados_tecnologia['tipo_region_economica_inicial'] == tipologia]

        for paso in datos_tipologia['paso_tiempo'].unique():
            datos_paso = datos_tipologia[datos_tipologia['paso_tiempo'] == paso]

            # Calcular coeficiente de variación (brecha relativa)
            cv_capacidad = datos_paso['capacidad_tecnologica'].std() / datos_paso['capacidad_tecnologica'].mean() if datos_paso['capacidad_tecnologica'].mean() > 0 else 0
            cv_innovacion = datos_paso['tasa_innovacion'].std() / datos_paso['tasa_innovacion'].mean() if datos_paso['tasa_innovacion'].mean() > 0 else 0
            cv_madurez = datos_paso['indice_madurez_tecnologica'].std() / datos_paso['indice_madurez_tecnologica'].mean() if datos_paso['indice_madurez_tecnologica'].mean() > 0 else 0

            convergencia_tecnologica.append({
                'tipologia': tipologia,
                'paso_tiempo': paso,
                'cv_capacidad_tecnologica': cv_capacidad,
                'cv_tasa_innovacion': cv_innovacion,
                'cv_indice_madurez': cv_madurez,
                'num_regiones': len(datos_paso)
            })

    df_convergencia = pd.DataFrame(convergencia_tecnologica)

    # =============================================
    # 4. ANÁLISIS DE SPILLOVERS TECNOLÓGICOS
    # =============================================

    spillovers_tecnologicos = []

    # Analizar correlaciones temporales entre regiones para detectar spillovers
    regiones_unicas = resultados_tecnologia['id_region'].unique()

    # Crear matriz de correlaciones entre regiones
    matriz_correlaciones = np.zeros((len(regiones_unicas), len(regiones_unicas)))
    nombres_regiones = []

    for i, region_a in enumerate(regiones_unicas):
        datos_a = resultados_tecnologia[resultados_tecnologia['id_region'] == region_a].sort_values('paso_tiempo')
        tipologia_a = datos_a['tipo_region_economica_inicial'].iloc[0]
        nombres_regiones.append(f"{region_a}_{tipologia_a}")

        for j, region_b in enumerate(regiones_unicas):
            if i != j:
                datos_b = resultados_tecnologia[resultados_tecnologia['id_region'] == region_b].sort_values('paso_tiempo')
                tipologia_b = datos_b['tipo_region_economica_inicial'].iloc[0]

                # Solo analizar spillovers entre regiones de diferente tipología
                if tipologia_a != tipologia_b:
                    # Correlación entre capacidades tecnológicas
                    if len(datos_a) == len(datos_b):
                        corr_capacidad = datos_a['capacidad_tecnologica'].corr(datos_b['capacidad_tecnologica'])
                        corr_innovacion = datos_a['tasa_innovacion'].corr(datos_b['tasa_innovacion'])

                        if not np.isnan(corr_capacidad) and not np.isnan(corr_innovacion):
                            spillovers_tecnologicos.append({
                                'region_origen': region_a,
                                'tipologia_origen': tipologia_a,
                                'region_destino': region_b,
                                'tipologia_destino': tipologia_b,
                                'correlacion_capacidad': corr_capacidad,
                                'correlacion_innovacion': corr_innovacion,
                                'intensidad_spillover': (abs(corr_capacidad) + abs(corr_innovacion)) / 2
                            })

    df_spillovers = pd.DataFrame(spillovers_tecnologicos)

    # =============================================
    # 5. CLASIFICACIÓN DE TIPOS DE CAMBIO TÉCNICO
    # =============================================

    clasificacion_cambio = []

    for region_id in resultados_tecnologia['id_region'].unique():
        datos_region = resultados_tecnologia[resultados_tecnologia['id_region'] == region_id].copy()
        datos_region = datos_region.sort_values('paso_tiempo')

        if len(datos_region) > 5:
            tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

            # Calcular métricas de cambio
            capacidad_inicial = datos_region['capacidad_tecnologica'].iloc[0]
            capacidad_final = datos_region['capacidad_tecnologica'].iloc[-1]
            capacidad_maxima = datos_region['capacidad_tecnologica'].max()

            cambio_absoluto = capacidad_final - capacidad_inicial
            cambio_relativo = cambio_absoluto / max(0.01, capacidad_inicial)

            # Detectar saltos tecnológicos (cambios abruptos)
            diferencias = np.diff(datos_region['capacidad_tecnologica'])
            salto_maximo = np.max(np.abs(diferencias))

            # Clasificar tipo de cambio
            if cambio_relativo > 0.5 and salto_maximo > 0.1:
                tipo_cambio = 'Disruptivo'
            elif cambio_relativo > 0.2 or salto_maximo > 0.05:
                tipo_cambio = 'Radical'
            elif cambio_relativo > 0.05:
                tipo_cambio = 'Incremental'
            else:
                tipo_cambio = 'Estable'

            # Evaluar consistencia del cambio
            tendencia_positiva = np.sum(diferencias > 0) / len(diferencias)

            clasificacion_cambio.append({
                'id_region': region_id,
                'tipologia': tipologia,
                'cambio_absoluto': cambio_absoluto,
                'cambio_relativo': cambio_relativo,
                'salto_maximo': salto_maximo,
                'tipo_cambio_tecnico': tipo_cambio,
                'consistencia_tendencia': tendencia_positiva,
                'capacit_inicial': capacidad_inicial,
                'capacidad_final': capacidad_final,
                'capacidad_maxima': capacidad_maxima
            })

    df_clasificacion_cambio = pd.DataFrame(clasificacion_cambio)

    # =============================================
    # 6. VISUALIZACIÓN INTEGRAL
    # =============================================

    # Crear figura principal con múltiples paneles
    fig, axes = plt.subplots(3, 2, figsize=(18, 16))
    fig.suptitle('Evolución del Cambio Técnico: Análisis Integral\n' +
                'Trayectorias • Madurez • Convergencia • Spillovers • Clasificación',
                fontsize=16, fontweight='bold', y=0.95)

    # Panel 1: Distribución de tipos de trayectoria
    if not df_trayectorias.empty:
        conteo_trayectorias = df_trayectorias['tipo_trayectoria'].value_counts()
        axes[0,0].pie(conteo_trayectorias.values, labels=conteo_trayectorias.index, autopct='%1.1f%%',
                     startangle=90, colors=['#ff9999', '#66b3ff', '#99ff99'])
        axes[0,0].set_title('Distribución de Trayectorias\nTecnológicas por Región', fontweight='bold')

    # Panel 2: Evolución del índice de madurez tecnológica
    if not df_madurez_temporal.empty:
        for tipologia in df_madurez_temporal['tipologia'].unique():
            datos_tip = df_madurez_temporal[df_madurez_temporal['tipologia'] == tipologia]
            axes[0,1].scatter(datos_tip['madurez_inicial'], datos_tip['madurez_final'],
                            label=tipologia, alpha=0.7, s=60)

        # Línea de referencia (sin cambio)
        min_mad = min(df_madurez_temporal['madurez_inicial'].min(), df_madurez_temporal['madurez_final'].min())
        max_mad = max(df_madurez_temporal['madurez_inicial'].max(), df_madurez_temporal['madurez_final'].max())
        axes[0,1].plot([min_mad, max_mad], [min_mad, max_mad], 'k--', alpha=0.5, label='Sin cambio')
        axes[0,1].set_xlabel('Madurez Inicial')
        axes[0,1].set_ylabel('Madurez Final')
        axes[0,1].set_title('Evolución de la Madurez\nTecnológica por Tipología', fontweight='bold')
        axes[0,1].legend(bbox_to_anchor=(1.05, 1), loc='upper left')

    # Panel 3: Convergencia tecnológica por tipología
    if not df_convergencia.empty:
        for tipologia in df_convergencia['tipologia'].unique():
            datos_conv = df_convergencia[df_convergencia['tipologia'] == tipologia]
            axes[1,0].plot(datos_conv['paso_tiempo'], datos_conv['cv_capacidad_tecnologica'],
                          marker='o', label=tipologia, linewidth=2)
        axes[1,0].set_xlabel('Paso de Tiempo')
        axes[1,0].set_ylabel('Coeficiente de Variación\n(Capacidad Tecnológica)')
        axes[1,0].set_title('Convergencia Tecnológica\nEntre Regiones del Mismo Tipo', fontweight='bold')
        axes[1,0].legend()
        axes[1,0].grid(True, alpha=0.3)

    # Panel 4: Heatmap de spillovers entre tipologías
    if not df_spillovers.empty:
        # Crear matriz de spillovers promedio por par de tipologías
        tipologias = sorted(df_spillovers['tipologia_origen'].unique())
        matriz_spillover = np.zeros((len(tipologias), len(tipologias)))

        for i, tip_a in enumerate(tipologias):
            for j, tip_b in enumerate(tipologias):
                if i != j:
                    spillovers_ab = df_spillovers[
                        (df_spillovers['tipologia_origen'] == tip_a) &
                        (df_spillovers['tipologia_destino'] == tip_b)
                    ]['intensidad_spillover']

                    if len(spillovers_ab) > 0:
                        matriz_spillover[i,j] = spillovers_ab.mean()

        if matriz_spillover.sum() > 0:
            im = axes[1,1].imshow(matriz_spillover, cmap='YlOrRd', aspect='auto')
            axes[1,1].set_xticks(range(len(tipologias)))
            axes[1,1].set_yticks(range(len(tipologias)))
            axes[1,1].set_xticklabels(tipologias, rotation=45, ha='right')
            axes[1,1].set_yticklabels(tipologias)
            axes[1,1].set_title('Intensidad de Spillovers\nTecnológicos Entre Tipologías', fontweight='bold')

            # Añadir valores en las celdas
            for i in range(len(tipologias)):
                for j in range(len(tipologias)):
                    if matriz_spillover[i,j] > 0:
                        axes[1,1].text(j, i, f'{matriz_spillover[i,j]:.3f}',
                                     ha='center', va='center', color='black', fontweight='bold')

            plt.colorbar(im, ax=axes[1,1], shrink=0.8)

    # Panel 5: Distribución de tipos de cambio técnico
    if not df_clasificacion_cambio.empty:
        conteo_cambios = df_clasificacion_cambio['tipo_cambio_tecnico'].value_counts()
        colores_cambio = {'Estable': '#ffcccc', 'Incremental': '#ffffcc', 'Radical': '#ccffcc', 'Disruptivo': '#ccccff'}
        colores_ordenados = [colores_cambio.get(tipo, '#cccccc') for tipo in conteo_cambios.index]

        axes[2,0].bar(conteo_cambios.index, conteo_cambios.values, color=colores_ordenados)
        axes[2,0].set_title('Distribución de Tipos de\nCambio Técnico', fontweight='bold')
        axes[2,0].set_ylabel('Número de Regiones')

        # Añadir valores en las barras
        for i, v in enumerate(conteo_cambios.values):
            axes[2,0].text(i, v + 0.1, str(v), ha='center', va='bottom', fontweight='bold')

    # Panel 6: Relación entre cambio tecnológico y productividad
    if not df_clasificacion_cambio.empty:
        # Obtener datos de productividad por región
        productividad_promedio = resultados.groupby('id_region')['productividad_promedio'].mean()

        df_grafico = df_clasificacion_cambio.copy()
        df_grafico['productividad_promedio'] = df_grafico['id_region'].map(productividad_promedio)

        for tipo in df_grafico['tipo_cambio_tecnico'].unique():
            datos_tipo = df_grafico[df_grafico['tipo_cambio_tecnico'] == tipo]
            axes[2,1].scatter(datos_tipo['cambio_relativo'], datos_tipo['productividad_promedio'],
                            label=tipo, alpha=0.7, s=60, color=colores_cambio.get(tipo, '#cccccc'))

        axes[2,1].set_xlabel('Cambio Tecnológico Relativo')
        axes[2,1].set_ylabel('Productividad Promedio')
        axes[2,1].set_title('Cambio Técnico vs\nProductividad por Región', fontweight='bold')
        axes[2,1].legend()
        axes[2,1].grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '22_evolucion_cambio_tecnico.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 7. GUARDAR RESULTADOS
    # =============================================

    # Guardar todas las tablas de análisis
    df_trayectorias.to_csv(os.path.join(save_path, 'trayectorias_tecnologicas.csv'), index=False)
    df_madurez_temporal.to_csv(os.path.join(save_path, 'evolucion_madurez_tecnologica.csv'), index=False)
    df_convergencia.to_csv(os.path.join(save_path, 'convergencia_tecnologica.csv'), index=False)
    df_spillovers.to_csv(os.path.join(save_path, 'spillovers_tecnologicos.csv'), index=False)
    df_clasificacion_cambio.to_csv(os.path.join(save_path, 'clasificacion_cambio_tecnico.csv'), index=False)

    # Crear resumen ejecutivo
    resumen_evolucion = {
        'numero_regiones_analizadas': len(df_trayectorias),
        'trayectorias_aceleradas': len(df_trayectorias[df_trayectorias['tipo_trayectoria'] == 'Acelerada']),
        'trayectorias_moderadas': len(df_trayectorias[df_trayectorias['tipo_trayectoria'] == 'Moderada']),
        'trayectorias_estancadas': len(df_trayectorias[df_trayectorias['tipo_trayectoria'] == 'Estancada']),
        'cambio_disruptivo': len(df_clasificacion_cambio[df_clasificacion_cambio['tipo_cambio_tecnico'] == 'Disruptivo']),
        'cambio_radical': len(df_clasificacion_cambio[df_clasificacion_cambio['tipo_cambio_tecnico'] == 'Radical']),
        'cambio_incremental': len(df_clasificacion_cambio[df_clasificacion_cambio['tipo_cambio_tecnico'] == 'Incremental']),
        'cambio_estable': len(df_clasificacion_cambio[df_clasificacion_cambio['tipo_cambio_tecnico'] == 'Estable']),
        'spillovers_detectados': len(df_spillovers),
        'mejora_promedio_madurez': df_madurez_temporal['mejora_madurez'].mean() if not df_madurez_temporal.empty else 0,
        'convergencia_promedio_final': df_convergencia.groupby('tipologia')['cv_capacidad_tecnologica'].last().mean() if not df_convergencia.empty else 0
    }

    pd.DataFrame([resumen_evolucion]).to_csv(os.path.join(save_path, 'resumen_evolucion_cambio_tecnico.csv'), index=False)

    # =============================================
    # 8. IMPRIMIR RESULTADOS
    # =============================================

    print(f"✓ Análisis de evolución del cambio técnico completado")
    print(f"  - Trayectorias tecnológicas: {len(df_trayectorias)} regiones")
    print(f"  - Madurez tecnológica: {len(df_madurez_temporal)} regiones temporales")
    print(f"  - Convergencia tecnológica: {len(df_convergencia)} observaciones por tipología")
    print(f"  - Spillovers tecnológicos: {len(df_spillovers)} interacciones detectadas")
    print(f"  - Clasificación de cambio: {len(df_clasificacion_cambio)} regiones clasificadas")

    return {
        'trayectorias': df_trayectorias,
        'madurez': df_madurez_temporal,
        'convergencia': df_convergencia,
        'spillovers': df_spillovers,
        'clasificacion': df_clasificacion_cambio,
        'resumen': resumen_evolucion
    }

if __name__ == "__main__":
    # Ejecutar análisis completo
    modelo, resultados, resumen = ejecutar_analisis_completo()

    # Configurar directorio de salida
    save_path = '/content/drive/MyDrive/modelo_economico_resultados'
    os.makedirs(save_path, exist_ok=True)

    # Crear visualizaciones individuales
    print("\nGenerando visualizaciones individuales...")
    crear_visualizaciones_individuales(resultados, save_path)
    print("✓ Gráficas individuales guardadas")

    # Crear gráficos de correlación por categorías
    print("\nGenerando gráficos de correlación por categorías...")
    crear_graficos_correlacion(resultados, save_path)
    print("✓ Gráficos de correlación guardados")

    # Evaluar procesos emergentes dinámicos
    print("\nEvaluando procesos emergentes y dinámicas de capital humano...")
    evaluar_procesos_emergentes(resultados, save_path)
    print("✓ Procesos emergentes evaluados")

    # Analizar evolución del cambio técnico
    print("\nAnalizando evolución del cambio técnico...")
    analisis_cambio_tecnico = analizar_evolucion_cambio_tecnico(resultados, save_path)
    print("✓ Evolución del cambio técnico analizada")

    # Analizar trampa de innovación en mercado laboral
    print("\nAnalizando trampa de innovación del mercado laboral...")
    analisis_trampa_laboral = analizar_trampa_innovacion_mercado_laboral(resultados, save_path)
    print("✓ Trampa de innovación del mercado laboral analizada")

    # Crear tabla resumen tipológico
    print("\nGenerando tabla resumen tipológico...")
    tabla_tipologica = crear_tabla_resumen_tipologico(resultados, save_path)
    print("✓ Tabla resumen tipológico guardada")

    # Guardar datos
    resultados.to_csv(os.path.join(save_path, 'resultados_abm_tipologico.csv'), index=False)
    resumen.to_csv(os.path.join(save_path, 'resumen_abm_tipologico.csv'), index=False)
     # Guardar resultados
    resultados.to_csv(os.path.join(save_path, 'resultados_modelo_economico.csv'), index=False)
    resumen.to_csv(os.path.join(save_path, 'resumen_modelo_economico.csv'), index=False)

    print(f"\n=== ARCHIVOS GENERADOS ===")
    print("📊 GRÁFICAS INDIVIDUALES (21 TOTAL):")
    print("  • 01_capacidad_tecnologica_tipologias.png")
    print("  • 02_tasa_innovacion_tipologias.png")
    print("  • 03_diversidad_sectorial_tipologias.png")
    print("  • 04_especializacion_tipologias.png")
    print("  • 05_productividad_tipologias.png")
    print("  • 06_actualizacion_tecnologica_tipologias.png")
    print("  • 07_brecha_calificacion_tipologias.png")
    print("  • 08_empleo_especializado_tipologias.png")
    print("  • 09_empleo_total_tipologias.png")
    print("  • 10_evolucion_capacidad_tecnologica.png")
    print("  • 11_evolucion_tasa_innovacion.png")
    print("  • 12_porcentaje_atrapadas_tipologias.png")
    print("  • 13_productividad_por_empleado.png")
    print("  • 14_eficiencia_innovadora.png")
    print("  • 15_productividad_tecnologica.png")
    print("  • 16_competitividad_regional.png")
    print("  • 17_evolucion_productividad.png")
    print("  • 18_evaluacion_dinamica.png [NUEVO: Evaluación dinámica de tipologías]")
    print("\n📊 GRÁFICOS DE ANÁLISIS AVANZADO (5 TOTAL):")
    print("  • 19_matriz_correlacion_categorizada.png [NUEVO: Matriz por categorías]")
    print("  • 20_correlaciones_cruzadas_categorias.png [NUEVO: Correlaciones entre categorías]")
    print("  • 21_procesos_emergentes_dinamicos.png [NUEVO: Capital humano, brechas y loops de refuerzo]")
    print("  • 22_evolucion_cambio_tecnico.png [NUEVO: Análisis integral del cambio técnico]")
    print("  • 23_trampa_innovacion_mercado_laboral.png [NUEVO: Trampa de innovación del mercado laboral]")
    print("\n📋 TABLAS PRINCIPALES:")
    print("  • tabla_resumen_tipologico.csv")
    print("  • correlaciones_por_categoria.csv [NUEVO: Correlaciones importantes por categoría]")
    print("  • resumen_procesos_emergentes.csv [NUEVO: Resumen de procesos emergentes]")
    print("  • resumen_evolucion_cambio_tecnico.csv [NUEVO: Resumen del análisis de cambio técnico]")
    print("  • resumen_trampa_innovacion.csv [NUEVO: Resumen de la trampa de innovación del mercado laboral]")
    print("\n📋 TABLAS DETALLADAS DE PROCESOS EMERGENTES:")
    print("  • resultados_procesos_emergentes.csv [NUEVO: Datos completos de procesos emergentes]")
    print("  • brechas_inter_regionales.csv [NUEVO: Brechas entre regiones del mismo tipo]")
    print("  • brechas_intra_regionales.csv [NUEVO: Variabilidad temporal dentro de regiones]")
    print("  • loops_refuerzo_positivo.csv [NUEVO: Análisis de loops de retroalimentación]")
    print("  • convergencia_divergecia_regiones.csv [NUEVO: Tendencias de convergencia/divergencia]")
    print("\n📋 TABLAS DETALLADAS DE EVOLUCIÓN DEL CAMBIO TÉCNICO:")
    print("  • trayectorias_tecnologicas.csv [NUEVO: Análisis de trayectorias tecnológicas por región]")
    print("  • evolucion_madurez_tecnologica.csv [NUEVO: Evolución del índice de madurez tecnológica]")
    print("  • convergencia_tecnologica.csv [NUEVO: Análisis de convergencia tecnológica entre regiones]")
    print("  • spillovers_tecnologicos.csv [NUEVO: Detección de spillovers y difusión tecnológica]")
    print("  • clasificacion_cambio_tecnico.csv [NUEVO: Clasificación de tipos de cambio técnico]")
    print("\n📋 TABLAS DETALLADAS DE TRAMPA DE INNOVACIÓN DEL MERCADO LABORAL:")
    print("  • polarizacion_mercado_laboral.csv [NUEVO: Análisis de polarización empleo alta vs baja calidad]")
    print("  • circulo_vicioso_experiencia_valor.csv [NUEVO: Experiencia que se diluye en baja tecnología]")
    print("  • dependencia_sectorial.csv [NUEVO: Dependencia de sectores específicos y vulnerabilidad]")
    print("  • perpetuacion_empleos_baja_calidad.csv [NUEVO: Perpetuación de empleos de baja calidad]")
    print("  • indice_trampa_innovacion.csv [NUEVO: Índice compuesto de trampa de innovación]")
    print("\n📄 DATOS:")
    print("  • resultados_abm_tipologico.csv: Datos detallados por región, tipología y paso")
    print("  • resumen_abm_tipologico.csv: Resumen por paso de simulación")

    print("\n=== INTEGRACIÓN COMPLETADA ===")
    print("✓ Tipologías regionales integradas basadas en evidencia empírica")
    print("✓ Distribución ajustada: 75% regiones 'Atrapadas', 25% 'No Atrapadas'")
    print("✓ Funcionalidades ABM optimizado preservadas")
    print("✓ Análisis integral: Regional • Sectorial • Corporativo • Geográfico • Entorno")
    print("✓ Análisis geográfico específico para 7 regiones de México")
    print("✓ Métricas incluidas: Innovación • Especialización • Diversificación • Empleo")
    print("✓ Métricas adicionales: Brechas calificación • Actualización tecnológica")
    print("✓ EVALUACIÓN DINÁMICA: Sistema de clasificación basado en características reales")
    print("✓ EVOLUCIÓN: Las regiones pueden cambiar de categoría durante la simulación")
    print("✓ DISTRIBUCIÓN INICIAL: 75% atrapadas, 25% no atrapadas (punto de partida)")
    print("✓ PROPENSIÓN: Calculada dinámicamente para análisis de sensibilidad")
    print("✓ EVALUACIÓN: Basada en especialización, innovación, diversidad y capacidad tecnológica")
    print("✓ Características geográficas: Desarrollo • Frontera EE.UU. • Recursos naturales")
    print("✓ Métricas geográficas: Aridez • Rezago social • Inversión extranjera")
    print("✓ 18 gráficas individuales generadas (incluyendo evaluación dinámica)")
    print("✓ 5 gráficos de análisis avanzado generados")
    print("✓ CORRELACIONES: Análisis multivariado por categorías (Regional • Sectorial • Corporativo • Tecnológica)")
    print("✓ INTERDEPENDENCIAS: Matrices de correlación cruzadas entre categorías")
    print("✓ ANÁLISIS AVANZADO: Tabla de correlaciones importantes por categoría")
    print("✓ PROCESOS EMERGENTES: Formación de capital humano y procesos de aprendizaje dinámico")
    print("✓ BREGAS DINÁMICAS: Análisis de brechas inter e intra-regionales")
    print("✓ LOOPS DE REFUERZO: Identificación de retroalimentación positiva entre variables clave")
    print("✓ CONVERGENCIA: Evaluación de tendencias de convergencia vs divergencia regional")
    print("✓ PROCESOS ACUMULATIVOS: Dinámicas emergentes que se refuerzan mutuamente")
    print("✓ CAMBIO TÉCNICO: Análisis integral de evolución, trayectorias, madurez y spillovers tecnológicos")
    print("✓ TRAYECTORIAS TECNOLÓGICAS: Clasificación de patrones de evolución (Acelerada • Moderada • Estancada)")
    print("✓ MADUREZ TECNOLÓGICA: Índice compuesto de 0-1 con métricas integradas")
    print("✓ CONVERGENCIA TECNOLÓGICA: Análisis de brechas entre regiones del mismo tipo")
    print("✓ SPILLOVERS: Detección de difusión tecnológica entre regiones de diferente tipología")
    print("✓ CLASIFICACIÓN: Tipos de cambio técnico (Disruptivo • Radical • Incremental • Estable)")
    print("✓ ANÁLISIS TEMPORAL: Evaluación multiescala de la evolución del cambio técnico")
    print("✓ TRAMPA DE INNOVACIÓN: Análisis específico de la estructura del mercado laboral")
    print("✓ POLARIZACIÓN: Clasificación empleos alta vs baja calidad por múltiples factores")
    print("✓ VENTAJA COMPETITIVA ESTÁTICA: Análisis de estructuras laborales que perpetúan la trampa")
    print("✓ CÍRCULO VICIOSO: Experiencia laboral que se diluye en entornos de baja tecnología")
    print("✓ DEPENDENCIA SECTORIAL: Evaluación de vulnerabilidad por especialización excesiva")
    print("✓ PERPETUACIÓN: Análisis de la persistencia de empleos de baja calidad")
    print("✓ ÍNDICE COMPUESTO: Métrica integral de trampa de innovación del mercado laboral")
    print("✓ Parámetros específicos por tipología aplicados")
    print("✓ Políticas diferenciadas por región geográfica de México")