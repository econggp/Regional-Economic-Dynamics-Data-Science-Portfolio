# -*- coding: utf-8 -*-
"""índices_censos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sGPNTW_P2kMcRrVNFTUNJZ3fYiMabET0
"""

import pandas as pd
import numpy as np

df = pd.read_excel('/content/SAIC_Exporta_202623_11343700.xlsx')

# Columnas que son etiquetas (ID)
columnas_identidad = ['tcode', 'tent', 'NOMGEO', 'AE', 'ID']

variables = df.columns.difference(columnas_identidad)

# Limpieza a todas las variables numéricas simultáneamente
df[variables] = df[variables].apply(pd.to_numeric, errors='coerce')

# Totales por año y por sector
df['pot_i'] = df.groupby(['tcode', 'AE'])['pot'].transform(lambda x: x.sum(skipna=True))
df['pacd_i'] = df.groupby(['tcode', 'AE'])['pacd'].transform(lambda x: x.sum(skipna=True))
df['ppvs_i'] = df.groupby(['tcode', 'AE'])['ppvs'].transform(lambda x: x.sum(skipna=True))
df['ue_i'] = df.groupby(['tcode', 'AE'])['UE'].transform(lambda x: x.sum(skipna=True))
df['vacb_i'] = df.groupby(['tcode', 'AE'])['vacb'].transform(lambda x: x.sum(skipna=True))
df['itot_i'] = df.groupby(['tcode', 'AE'])['itot'].transform(lambda x: x.sum(skipna=True))
df['ataf_i'] = df.groupby(['tcode', 'AE'])['ataf'].transform(lambda x: x.sum(skipna=True))
df['fbcf_i'] = df.groupby(['tcode', 'AE'])['fbcf'].transform(lambda x: x.sum(skipna=True))

# Totales por año y por entidad
df['pot_j'] = df.groupby(['tcode', 'NOMGEO'])['pot'].transform(lambda x: x.sum(skipna=True))
df['pacd_j'] = df.groupby(['tcode', 'NOMGEO'])['pacd'].transform(lambda x: x.sum(skipna=True))
df['ppvs_j'] = df.groupby(['tcode', 'NOMGEO'])['ppvs'].transform(lambda x: x.sum(skipna=True))
df['ue_j'] = df.groupby(['tcode', 'NOMGEO'])['UE'].transform(lambda x: x.sum(skipna=True))
df['vacb_j'] = df.groupby(['tcode', 'NOMGEO'])['vacb'].transform(lambda x: x.sum(skipna=True))
df['itot_j'] = df.groupby(['tcode', 'NOMGEO'])['itot'].transform(lambda x: x.sum(skipna=True))
df['ataf_j'] = df.groupby(['tcode', 'NOMGEO'])['ataf'].transform(lambda x: x.sum(skipna=True))
df['fbcf_j'] = df.groupby(['tcode', 'NOMGEO'])['fbcf'].transform(lambda x: x.sum(skipna=True))

# Totales globales por año censal
pot_n = df.groupby('tcode')['pot'].sum().to_dict()
pacd_n = df.groupby('tcode')['pacd'].sum().to_dict()
ppvs_n = df.groupby('tcode')['ppvs'].sum().to_dict()
ue_n = df.groupby('tcode')['UE'].sum().to_dict()
vacb_n = df.groupby('tcode')['vacb'].sum().to_dict()
itot_n = df.groupby('tcode')['itot'].sum().to_dict()
ataf_n = df.groupby('tcode')['ataf'].sum().to_dict()
fbcf_n = df.groupby('tcode')['fbcf'].sum().to_dict()

"""Índices de capacidades"""

# automa
df['automa'] = df['atmep'] / df['ppvs']

# ecpacd
df['ecpacd'] = df['tspacd'] / (df['tga'] - df['tspacd'])

# ecppvs
df['ecppvs'] = df['tsppvs'] / (df['tga'] - df['tsppvs'])

# sact
df['sact'] = (df['ataf'] - df['dtaf']) / df['ataf']

# ecos
df['ecos'] = df['vacb'] / df['tga']

# efene
df['efene'] = (df['gcee'] + df['ccle']) / df['vacb']

# mbi
df['mbi'] = (df['tin'] - df['tga']) / df['tin']

# cdig
df['cdig'] = df['atecp'] / df['pot']

# intal
df['intal'] = (df['cspct'] + df['tspacd']) / df['tga']

# ite
df['ite'] = (df['atecp'] + df['atmep']) / df['ataf']

"""Índices de derrames"""

df['pn_pot'] = df['pot_i'] / df['tcode'].map(pot_n)
df['pn_pacd'] = df['pacd_i'] / df['tcode'].map(pacd_n)
df['pn_ppvs'] = df['ppvs_i'] / df['tcode'].map(ppvs_n)
df['pn_ue'] = df['ue_i'] / df['tcode'].map(ue_n)

df['marpot'] = (df['pot'] / df['pot_j'])/ df['pn_pot']
df['marpacd'] = (df['pacd'] / df['pacd_j'])/ df['pn_pot']
df['marppvs'] = (df['ppvs'] / df['ppvs_j'])/ df['pn_pot']

df['marpot'] = df['marpot'].replace([np.inf, -np.inf], 0).fillna(0)
df['marpacd'] = df['marpacd'].replace([np.inf, -np.inf], 0).fillna(0)
df['marppvs'] = df['marppvs'].replace([np.inf, -np.inf], 0).fillna(0)

df_2023 = df[df['tcode'] == 2023].copy()
df_2018 = df[df['tcode'] == 2018].copy()
df_2013 = df[df['tcode'] == 2013].copy()
df_2008 = df[df['tcode'] == 2008].copy()
df_2003 = df[df['tcode'] == 2003].copy()

top_5_sec23 = df_2023.sort_values(['NOMGEO', 'marpot'], ascending=[True, False])
top_5_sec23 = top_5_sec23.groupby('NOMGEO').head(5)
top_5_sec18 = df_2018.sort_values(['NOMGEO', 'marpot'], ascending=[True, False])
top_5_sec18 = top_5_sec18.groupby('NOMGEO').head(5)
top_5_sec13 = df_2013.sort_values(['NOMGEO', 'marpot'], ascending=[True, False])
top_5_sec13 = top_5_sec13.groupby('NOMGEO').head(5)
top_5_sec08 = df_2008.sort_values(['NOMGEO', 'marpot'], ascending=[True, False])
top_5_sec08 = top_5_sec08.groupby('NOMGEO').head(5)
top_5_sec03 = df_2003.sort_values(['NOMGEO', 'marpot'], ascending=[True, False])
top_5_sec03 = top_5_sec03.groupby('NOMGEO').head(5)

resultado_top23 = top_5_sec23[['NOMGEO', 'AE', 'marpot']]
resultado_top18 = top_5_sec18[['NOMGEO', 'AE', 'marpot']]
resultado_top13 = top_5_sec13[['NOMGEO', 'AE', 'marpot']]
resultado_top08 = top_5_sec08[['NOMGEO', 'AE', 'marpot']]
resultado_top03 = top_5_sec03[['NOMGEO', 'AE', 'marpot']]

# Ejemplo
print(resultado_top23[resultado_top23['NOMGEO'].str.contains("Nuevo León", na=False)])
print(resultado_top18[resultado_top18['NOMGEO'].str.contains("Nuevo León", na=False)])
print(resultado_top13[resultado_top13['NOMGEO'].str.contains("Nuevo León", na=False)])
print(resultado_top08[resultado_top08['NOMGEO'].str.contains("Nuevo León", na=False)])
print(resultado_top03[resultado_top03['NOMGEO'].str.contains("Nuevo León", na=False)])

# Proporciones regionales
df['ps_pot'] = df['pot'] / df['pot_j']
df['ps_pacd'] = df['pacd'] / df['pacd_j']
df['ps_ppvs'] = df['ppvs'] / df['ppvs_j']
df['ps_vacb'] = df['vacb'] / df['vacb_j']

# Calcular el componente de Shannon: p_i * ln(p_i)
df['sp_pot'] = df['ps_pot'] * np.log(df['ps_pot'])
df['sp_pacd'] = df['ps_pacd'] * np.log(df['ps_pacd'])
df['sp_ppvs'] = df['ps_ppvs'] * np.log(df['ps_ppvs'])

# DIV
sh_pot = df.groupby(['tcode', 'NOMGEO']).agg(
    h_pot=('sp_pot', lambda x: x.sum() * -1),
    S_sectores=('AE', 'count')).reset_index()
sh_pacd = df.groupby(['tcode', 'NOMGEO']).agg(
    h_pacd=('sp_pacd', lambda x: x.sum() * -1),
    S_sectores=('AE', 'count')).reset_index()
sh_ppvs = df.groupby(['tcode', 'NOMGEO']).agg(
    h_ppvs=('sp_ppvs', lambda x: x.sum() * -1),
    S_sectores=('AE', 'count')).reset_index()

# Equitabilidad Pielou (J')
sh_pot['ep_pot'] = sh_pot['h_pot'] / np.log(sh_pot['S_sectores'])
sh_pacd['ep_pacd'] = sh_pacd['h_pacd'] / np.log(sh_pacd['S_sectores'])
sh_ppvs['ep_ppvs'] = sh_ppvs['h_ppvs'] / np.log(sh_ppvs['S_sectores'])

import seaborn as sns
import matplotlib.pyplot as plt

heatmap_data = sh_pot.pivot(index='NOMGEO', columns='tcode', values='ep_pot')

plt.figure(figsize=(12, 10))
sns.set_theme(style="white")

sns.heatmap(heatmap_data,
            annot=True,
            fmt=".2f",
            cmap="RdYlGn",
            linewidths=.5,
            cbar_kws={'label': 'Índice de equitabilidad (Pielou)'})

plt.title('Evolución de la diversidad económica por estado (2003-2023)', fontsize=15)
plt.xlabel('Año censal', fontsize=12)
plt.ylabel('Entidad federativa', fontsize=12)

plt.show()

heatmap_data = sh_pacd.pivot(index='NOMGEO', columns='tcode', values='ep_pacd')

plt.figure(figsize=(12, 10))
sns.set_theme(style="white")

sns.heatmap(heatmap_data,
            annot=True,
            fmt=".2f",
            cmap="RdYlGn",
            linewidths=.5,
            cbar_kws={'label': 'Índice de equitabilidad (Pielou)'})

plt.title('Evolución de la diversidad económica por estado PACD (2003-2023)', fontsize=15)
plt.xlabel('Año censal', fontsize=12)
plt.ylabel('Entidad federativa', fontsize=12)

plt.show()

heatmap_data = sh_ppvs.pivot(index='NOMGEO', columns='tcode', values='ep_ppvs')

plt.figure(figsize=(12, 10))
sns.set_theme(style="white")

sns.heatmap(heatmap_data,
            annot=True,
            fmt=".2f",
            cmap="RdYlGn",
            linewidths=.5,
            cbar_kws={'label': 'Índice de equitabilidad (Pielou)'})

plt.title('Evolución de la diversidad económica por estado PPVS (2003-2023)', fontsize=15)
plt.xlabel('Año censal', fontsize=12)
plt.ylabel('Entidad federativa', fontsize=12)

plt.show()

# Índice de brecha laboral (ibl)
df['ibl_pot'] = df['ps_pot'] - df['ps_vacb']
df['ibl_pacd'] = df['ps_pacd'] - df['ps_vacb']
df['ibl_ppvs'] = df['ps_ppvs'] - df['ps_vacb']

# Índice de absorción de capacidades tecnológicas

# Cálculo de los componentes
df['dotacion_tech'] = df['ataf'] / df['pot']
df['tasa_absorcion'] = df['itot'] / df['vacb']

# Índice Final (IACT)
# Usamos raíz cuadrada para suavizar valores extremos
df['iact'] = np.sqrt(df['dotacion_tech'] * df['tasa_absorcion'])

# Normalización (para comparar entre 0 y 1 por año)
df['iact_norm'] = df.groupby('tcode')['iact'].transform(
    lambda x: (x - x.min()) / (x.max() - x.min())
)

plt.figure(figsize=(10, 6))
sns.boxplot(x='tcode', y='iact_norm', data=df, palette='viridis')
plt.title('Distribución de la absorción tecnológica por año')
plt.ylabel('IACT normalizado')
plt.show()

def clasificar_tech(valor):
    if valor >= 0.7: return 'Vanguardia'
    if valor >= 0.3: return 'Transición'
    return 'Base/Tradicional'

df['perfil_tech'] = df['iact_norm'].apply(clasificar_tech)

# Contar cuántos sectores hay en cada categoría por año
print(df.groupby(['tcode', 'perfil_tech']).size())

# 1. Filtramos los dos años de interés
df_comparativa = df[df['tcode'].isin([2018, 2023])].copy()

# 2. Obtenemos los 10 más altos de cada año
top_10_2018 = df_comparativa[df_comparativa['tcode'] == 2018].nlargest(10, 'iact')
top_10_2023 = df_comparativa[df_comparativa['tcode'] == 2023].nlargest(10, 'iact')

# 3. Concatenamos para comparar
comparativa_tech = pd.concat([top_10_2018, top_10_2023])

# 4. Mostramos columnas clave para entender el porqué del índice
columnas_analisis = ['tcode', 'NOMGEO', 'AE', 'iact', 'ataf', 'itot', 'pot', 'vacb']
print(comparativa_tech[columnas_analisis])

lider_2023 = df[(df['tcode'] == 2023) & (df['perfil_tech'] == 'Vanguardia')]
print(lider_2023[['NOMGEO', 'AE', 'iact_norm', 'itot']])

lider_2018 = df[(df['tcode'] == 2018) & (df['perfil_tech'] == 'Vanguardia')]
print(lider_2018[['NOMGEO', 'AE', 'iact_norm', 'itot']])

lider_2013 = df[(df['tcode'] == 2013) & (df['perfil_tech'] == 'Vanguardia')]
print(lider_2013[['NOMGEO', 'AE', 'iact_norm', 'itot']])

lider_2008 = df[(df['tcode'] == 2008) & (df['perfil_tech'] == 'Vanguardia')]
print(lider_2008[['NOMGEO', 'AE', 'iact_norm', 'itot']])

lider_2003 = df[(df['tcode'] == 2003) & (df['perfil_tech'] == 'Vanguardia')]
print(lider_2003[['NOMGEO', 'AE', 'iact_norm', 'itot']])

"""Índices espaciales"""

# Índice de Concentración Geográfica

# Gran Total Nacional por año (Denominador global)
df['pot_tn'] = df.groupby('tcode')['pot'].transform('sum')
df['pacd_tn'] = df.groupby('tcode')['pacd'].transform('sum')
df['ppvs_tn'] = df.groupby('tcode')['ppvs'].transform('sum')

# Calcular los dos términos de la resta dentro del valor absoluto
# Término A: Participación del estado j en el sector i
df['term_A_pot'] = df['pot'] / df['pot_i']
df['term_A_pacd'] = df['pacd'] / df['pacd_i']
df['term_A_ppvs'] = df['ppvs'] / df['ppvs_i']

# Término B: Participación del estado j en la economía nacional total
df['term_B_pot'] = df['pot_j'] / df['pot_tn']
df['term_B_pacd'] = df['pacd_j'] / df['pacd_tn']
df['term_B_ppvs'] = df['ppvs_j'] / df['ppvs_tn']

# Calcular el valor absoluto de la diferencia
df['abs_diff_pot'] = (df['term_A_pot'] - df['term_B_pot']).abs()
df['abs_diff_pacd'] = (df['term_A_pacd'] - df['term_B_pacd']).abs()
df['abs_diff_ppvs'] = (df['term_A_ppvs'] - df['term_B_ppvs']).abs()

# Sumar sobre todos los estados (j) para cada Sector y Año, y multiplicar por 0.5
qs_df_pot = df.groupby(['tcode', 'AE'])['abs_diff_pot'].sum().reset_index()
qs_df_pacd = df.groupby(['tcode', 'AE'])['abs_diff_pacd'].sum().reset_index()
qs_df_ppvs = df.groupby(['tcode', 'AE'])['abs_diff_ppvs'].sum().reset_index()

qs_df_pot['Qs_pot'] = qs_df_pot['abs_diff_pot'] * 0.5
qs_df_pacd['Qs_pacd'] = qs_df_pacd['abs_diff_pacd'] * 0.5
qs_df_ppvs['Qs_ppvs'] = qs_df_ppvs['abs_diff_ppvs'] * 0.5

# Índice de Especialización Regional ($Qr$)

# Cálculo de los componentes
# Participación local del sector i en el estado j
df['pl_pot'] = df['pot'] / df['pot_j']
df['pl_pacd'] = df['pacd'] / df['pacd_j']
df['pl_ppvs'] = df['ppvs'] / df['ppvs_j']

# Participación nacional del sector i
df['pn_pot'] = df['pot_i'] / df['pot_tn']
df['pn_pacd'] = df['pacd_i'] / df['pacd_tn']
df['pn_ppvs'] = df['ppvs_i'] / df['ppvs_tn']

# Cálculo del Índice Qr (Agrupado por Estado y Año)
qr_df_pot = df.groupby(['tcode', 'NOMGEO']).apply(
    lambda x: 0.5 * np.sum(np.abs(x['pl_pot'] - x['pn_pot']))
).reset_index(name='Qr_pot')
qr_df_pacd = df.groupby(['tcode', 'NOMGEO']).apply(
    lambda x: 0.5 * np.sum(np.abs(x['pl_pacd'] - x['pn_pacd']))
).reset_index(name='Qr_pacd')
qr_df_ppvs = df.groupby(['tcode', 'NOMGEO']).apply(
    lambda x: 0.5 * np.sum(np.abs(x['pl_ppvs'] - x['pn_ppvs']))
).reset_index(name='Qr_ppvs')

crecimiento_pot = df.groupby(['tcode', 'NOMGEO'])['pot'].sum().reset_index()
crecimiento_pacd = df.groupby(['tcode', 'NOMGEO'])['pacd'].sum().reset_index()
crecimiento_ppvs = df.groupby(['tcode', 'NOMGEO'])['ppvs'].sum().reset_index()

crecimiento_pivot_pot = crecimiento_pot.pivot(index=['NOMGEO'], columns='tcode', values='pot')
crecimiento_pivot_pacd = crecimiento_pacd.pivot(index=['NOMGEO'], columns='tcode', values='pacd')
crecimiento_pivot_ppvs = crecimiento_ppvs.pivot(index=['NOMGEO'], columns='tcode', values='ppvs')

crecimiento_pivot_pot['pct_crecimiento_pot'] = (crecimiento_pivot_pot[2023] - crecimiento_pivot_pot[2003]) / crecimiento_pivot_pot[2003] * 100
crecimiento_pivot_pacd['pct_crecimiento_pacd'] = (crecimiento_pivot_pacd[2023] - crecimiento_pivot_pacd[2003]) / crecimiento_pivot_pacd[2003] * 100
crecimiento_pivot_ppvs['pct_crecimiento_ppvs'] = (crecimiento_pivot_ppvs[2023] - crecimiento_pivot_ppvs[2003]) / crecimiento_pivot_ppvs[2003] * 100

qrpot_2023 = qr_df_pot[qr_df_pot['tcode'] == 2023].set_index(['NOMGEO'])
datapot_plot = qrpot_2023.join(crecimiento_pivot_pot['pct_crecimiento_pot']).reset_index()
qrpacd_2023 = qr_df_pacd[qr_df_pacd['tcode'] == 2023].set_index(['NOMGEO'])
datapacd_plot = qrpacd_2023.join(crecimiento_pivot_pacd['pct_crecimiento_pacd']).reset_index()
qrppvs_2023 = qr_df_ppvs[qr_df_ppvs['tcode'] == 2023].set_index(['NOMGEO'])
datappvs_plot = qrppvs_2023.join(crecimiento_pivot_ppvs['pct_crecimiento_ppvs']).reset_index()

plt.figure(figsize=(12, 8))
sns.set_theme(style="whitegrid")

scatter = sns.scatterplot(
    data=datapot_plot,
    x='Qr_pot',
    y='pct_crecimiento_pot',
    size=2023, # El tamaño del punto puede ser el total de personal en 2023
    sizes=(50, 500),
    alpha=0.7,
    hue='Qr_pot', # El color cambia según la especialización
    palette='viridis'
)

# Añadir etiquetas a los puntos (solo para los más destacados)
for i in range(datapot_plot.shape[0]):
    # Etiquetar estados con Qr alto o crecimiento muy alto/bajo
    if datapot_plot.Qr_pot[i] > 0.22 or datapot_plot.pct_crecimiento_pot[i] > 100:
        plt.text(
            datapot_plot.Qr_pot[i]+0.005,
            datapot_plot.pct_crecimiento_pot[i],
            datapot_plot.NOMGEO[i],
            fontsize=9
        )

plt.title('Relación entre especialización económica ($Qr$) y crecimiento laboral (2003-2023)', fontsize=15)
plt.xlabel('Índice de especialización regional ($Qr$) - Año 2023', fontsize=12)
plt.ylabel('Crecimiento porcentual del personal (%)', fontsize=12)
plt.axvline(datapot_plot['Qr_pot'].mean(), color='red', linestyle='--', alpha=0.5, label='Media Qr_pot')

plt.show()

plt.figure(figsize=(12, 8))
sns.set_theme(style="whitegrid")

scatter = sns.scatterplot(
    data=datapacd_plot,
    x='Qr_pacd',
    y='pct_crecimiento_pacd',
    size=2023, # El tamaño del punto puede ser el total de personal en 2023
    sizes=(50, 500),
    alpha=0.7,
    hue='Qr_pacd', # El color cambia según la especialización
    palette='viridis'
)

# Añadir etiquetas a los puntos (solo para los más destacados)
for i in range(datapacd_plot.shape[0]):
    # Etiquetar estados con Qr alto o crecimiento muy alto/bajo
    if datapacd_plot.Qr_pacd[i] > 0.22 or datapacd_plot.pct_crecimiento_pacd[i] > 100:
        plt.text(
            datapacd_plot.Qr_pacd[i]+0.005,
            datapacd_plot.pct_crecimiento_pacd[i],
            datapacd_plot.NOMGEO[i],
            fontsize=9
        )

plt.title('Relación entre especialización económica ($Qr$) y crecimiento laboral PACD (2003-2023)', fontsize=15)
plt.xlabel('Índice de especialización regional ($Qr$) - Año 2023', fontsize=12)
plt.ylabel('Crecimiento porcentual del PACD (%)', fontsize=12)
plt.axvline(datapacd_plot['Qr_pacd'].mean(), color='red', linestyle='--', alpha=0.5, label='Media Qr_pacd')

plt.show()

plt.figure(figsize=(12, 8))
sns.set_theme(style="whitegrid")

scatter = sns.scatterplot(
    data=datappvs_plot,
    x='Qr_ppvs',
    y='pct_crecimiento_ppvs',
    size=2023, # El tamaño del punto puede ser el total de personal en 2023
    sizes=(50, 500),
    alpha=0.7,
    hue='Qr_ppvs', # El color cambia según la especialización
    palette='viridis'
)

# Añadir etiquetas a los puntos (solo para los más destacados)
for i in range(datappvs_plot.shape[0]):
    # Etiquetar estados con Qr alto o crecimiento muy alto/bajo
    if datappvs_plot.Qr_ppvs[i] > 0.22 or datappvs_plot.pct_crecimiento_ppvs[i] > 100:
        plt.text(
            datappvs_plot.Qr_ppvs[i]+0.005,
            datappvs_plot.pct_crecimiento_ppvs[i],
            datappvs_plot.NOMGEO[i],
            fontsize=9
        )

plt.title('Relación entre especialización económica ($Qr$) y crecimiento laboral PPVS (2003-2023)', fontsize=15)
plt.xlabel('Índice de especialización regional ($Qr$) - Año 2023', fontsize=12)
plt.ylabel('Crecimiento porcentual del PPVS (%)', fontsize=12)
plt.axvline(datappvs_plot['Qr_ppvs'].mean(), color='red', linestyle='--', alpha=0.5, label='Media Qr_ppvs')

plt.show()

df_2003 = df[df['tcode'] == 2003].copy()
df_2023 = df[df['tcode'] == 2023].copy()

# Renombramos columnas para identificar V(0) y V(T)
# Usaremos 'AE' como sector y 'NOMGEO' como estado para el cruce (Merge)
df_base = df_2003[['NOMGEO', 'AE', 'pot']].rename(columns={'pot': 'pot_0'})
df_actual = df_2023[['NOMGEO', 'AE', 'pot']].rename(columns={'pot': 'pot_T'})

# Unimos ambos años en un solo DataFrame de trabajo
df_dinamico = pd.merge(df_actual, df_base, on=['NOMGEO', 'AE'], how='left')

df_dinamico['rv_ij'] = df_dinamico['pot_T'] / df_dinamico['pot_0']

df_dinamico['total_estado_T'] = df_dinamico.groupby('NOMGEO')['pot_T'].transform('sum')
df_dinamico['total_estado_0'] = df_dinamico.groupby('NOMGEO')['pot_0'].transform('sum')

# Calculamos las proporciones V_ij / sum(V_ij)
df_dinamico['prop_T'] = df_dinamico['pot_T'] / df_dinamico['total_estado_T']
df_dinamico['prop_0'] = df_dinamico['pot_0'] / df_dinamico['total_estado_0']

# Calculamos el valor absoluto de la diferencia
df_dinamico['diff_abs_crr'] = (df_dinamico['prop_T'] - df_dinamico['prop_0']).abs()

# Sumamos por estado y multiplicamos por 1/2
crr_resultado = df_dinamico.groupby(['NOMGEO'])['diff_abs_crr'].sum().reset_index()
crr_resultado['CRr'] = crr_resultado['diff_abs_crr'] * 0.5

plt.figure(figsize=(10, 12))
sns.barplot(data=crr_resultado.sort_values('CRr', ascending=False), x='CRr', y='NOMGEO', palette='magma')
plt.title('Coeficiente de reestructuración estatal (2004-2023)')
plt.axvline(0.5, color='red', linestyle='--') # Umbral de cambio profundo
plt.show()

df_dinamico['total_nacional_sec_T'] = df_dinamico.groupby('AE')['pot_T'].transform('sum')
df_dinamico['total_nacional_sec_0'] = df_dinamico.groupby('AE')['pot_0'].transform('sum')

# Calculamos las participaciones (proporciones geográficas)
# Si el total nacional es 0 (sector extinto), el resultado será 0
df_dinamico['part_geo_T'] = (df_dinamico['pot_T'] / df_dinamico['total_nacional_sec_T']).fillna(0)
df_dinamico['part_geo_0'] = (df_dinamico['pot_0'] / df_dinamico['total_nacional_sec_0']).fillna(0)

# Calculamos la diferencia absoluta
df_dinamico['diff_abs_crs'] = (df_dinamico['part_geo_T'] - df_dinamico['part_geo_0']).abs()

# Agrupamos por SECTOR (AE) para obtener el CRs final
crs_resultado = df_dinamico.groupby('AE')['diff_abs_crs'].sum().reset_index()
crs_resultado['CRs'] = crs_resultado['diff_abs_crs'] * 0.5

crs_plot = crs_resultado.sort_values('CRs', ascending=False).head(20) # Top 20 para no saturar

plt.figure(figsize=(12, 8))
sns.set_theme(style="whitegrid")

sns.barplot(
    data=crs_plot,
    x='CRs',
    y='AE',
    palette='flare' # Degradado de color para enfatizar el cambio
)

plt.axvline(crs_resultado['CRs'].mean(), color='blue', linestyle='--', label='Promedio Nacional')

plt.title('Reestructuración geográfica sectorial (2004-2023)', fontsize=15)
plt.xlabel('Coeficiente de reestructuración sectorial (CRs)', fontsize=12)
plt.ylabel('Código de sector', fontsize=12)
plt.legend()

plt.tight_layout()
plt.show()

sector_top = crs_plot.iloc[0]['AE']
detalle = df_dinamico[df_dinamico['AE'] == sector_top][['NOMGEO', 'part_geo_0', 'part_geo_T']]

# Graficar los 5 estados que más ganaron y los 5 que más perdieron participación
detalle['cambio'] = detalle['part_geo_T'] - detalle['part_geo_0']
detalle_cambio = detalle.sort_values('cambio', ascending=False)

print(f"Cambios geográficos para el sector: {sector_top}")
print(pd.concat([detalle_cambio.head(5), detalle_cambio.tail(5)]))

# Calculamos el crecimiento nacional por sector (rVi)
crecimiento_sectorial = df_dinamico.groupby('AE').agg({
    'pot_T': 'sum',
    'pot_0': 'sum'
}).reset_index()

crecimiento_sectorial['rVi'] = (crecimiento_sectorial['pot_T'] / crecimiento_sectorial['pot_0'])

# Unimos con el CRs que ya teníamos
cuadrante_data = pd.merge(crs_resultado[['AE', 'CRs']], crecimiento_sectorial[['AE', 'rVi']], on='AE')

# Limpiamos valores infinitos o NaN por si algún sector era nuevo
cuadrante_data = cuadrante_data.replace([np.inf, -np.inf], np.nan).dropna()

plt.figure(figsize=(12, 10))

# Definir los umbrales
x_med = cuadrante_data['CRs'].median()
y_med = 1.0 # 1.0 significa crecimiento cero; arriba es crecimiento, abajo es pérdida

# Crear el Scatter Plot
sns.scatterplot(data=cuadrante_data, x='CRs', y='rVi', s=100, alpha=0.6, color='darkblue')

# Añadir las líneas del cuadrante
plt.axvline(x_med, color='red', linestyle='--', alpha=0.5)
plt.axhline(y_med, color='red', linestyle='--', alpha=0.5)

# Etiquetas para los cuadrantes
plt.text(cuadrante_data['CRs'].max()*0.8, cuadrante_data['rVi'].max()*0.9, 'ESTRELLA (Dinámicos)', fontsize=12, color='green', fontweight='bold')
plt.text(cuadrante_data['CRs'].min(), cuadrante_data['rVi'].max()*0.9, 'MADUROS (Crecientes estables)', fontsize=12, color='blue', fontweight='bold')
plt.text(cuadrante_data['CRs'].min(), cuadrante_data['rVi'].min(), 'ESTÁTICOS (En declive)', fontsize=12, color='gray', fontweight='bold')
plt.text(cuadrante_data['CRs'].max()*0.8, cuadrante_data['rVi'].min(), 'TRANSICIÓN (Reubicación crítica)', fontsize=12, color='orange', fontweight='bold')

# Etiquetar algunos puntos clave (Sectores más extremos)
top_sectors = pd.concat([cuadrante_data.nlargest(5, 'rVi'), cuadrante_data.nlargest(5, 'CRs')])
for i, row in top_sectors.iterrows():
    plt.text(row['CRs']+0.01, row['rVi'], row['AE'], fontsize=9)

plt.title('Cuadrante de dinamismo sectorial (2004-2023)', fontsize=15)
plt.xlabel('Reestructuración geográfica (CRs)', fontsize=12)
plt.ylabel('Crecimiento relativo nacional (rVi)', fontsize=12)
plt.yscale('log') # Usamos escala logarítmica si hay crecimientos muy disparados

plt.show()

# Definimos los umbrales
umbral_crs = cuadrante_data['CRs'].median()
umbral_crecimiento = 1.0 # Crecimiento positivo

# Filtramos el cuadrante superior derecho
estrellas = cuadrante_data[
    (cuadrante_data['CRs'] > umbral_crs) &
    (cuadrante_data['rVi'] > umbral_crecimiento)
].copy()

# Ordenamos por dinamismo (una combinación de ambos factores)
estrellas['puntuacion_dinamismo'] = estrellas['CRs'] * estrellas['rVi']
estrellas_ranking = estrellas.sort_values('puntuacion_dinamismo', ascending=False)

# Mostrar el Top 10 de sectores Estrella
print("Top 10 Sectores Estrella (Dinámicos y en Reubicación):")
print(estrellas_ranking[['AE', 'CRs', 'rVi']].head(10))

# Tomamos el sector líder de las estrellas
sector_lider = estrellas_ranking.iloc[0]['AE']

# Buscamos en qué estados creció más su participación
ganadores = df_dinamico[df_dinamico['AE'] == sector_lider].copy()
ganadores['cambio_participacion'] = ganadores['part_geo_T'] - ganadores['part_geo_0']

print(f"\nEstados que 'conquistaron' el sector {sector_lider}:")
print(ganadores.sort_values('cambio_participacion', ascending=False)[['NOMGEO', 'cambio_participacion']].head(5))

# Calcular rSi: Tasa de crecimiento nacional por sector (i)
# Usamos los totales nacionales que calculamos para el CRs
crecimiento_nacional_it = df_dinamico.groupby('AE')['pot_T'].sum()
crecimiento_nacional_i0 = df_dinamico.groupby('AE')['pot_0'].sum()

# rSi = V_i(t) / V_i(0)
rsi = (crecimiento_nacional_it / crecimiento_nacional_i0).rename('rsi')

# Unir rSi al dataframe dinámico
df_shift = pd.merge(df_dinamico, rsi, on='AE', how='left')

# Calcular el Valor Esperado (lo que se supone que debía crecer según la nación)
# Valor_esperado = V_ij(0) * rSi
df_shift['valor_esperado'] = df_shift['pot_0'] * df_shift['rsi']

# Calcular el Efecto Diferencial (EDj) por estado
# Es la suma de (Lo observado - Lo esperado)
df_shift['diff_local'] = df_shift['pot_T'] - df_shift['valor_esperado']

edj_resultado = df_shift.groupby(['NOMGEO'])['diff_local'].sum().reset_index()
edj_resultado.rename(columns={'diff_local': 'EDj'}, inplace=True)

plt.figure(figsize=(12, 10))
# Ordenamos para ver quién tiene mayor ventaja competitiva
edj_sorted = edj_resultado.sort_values('EDj', ascending=False)

sns.barplot(data=edj_sorted, x='EDj', y='NOMGEO',
            palette=['green' if x > 0 else 'red' for x in edj_sorted['EDj']])

plt.axvline(0, color='black', linestyle='-')
plt.title('Efecto diferencial (EDj): Ventaja competitiva por Estado (2004-2023)', fontsize=15)
plt.xlabel('Empleos generados por encima/debajo de la tendencia nacional', fontsize=12)
plt.show()

# Promediamos el IACT normalizado por estado para el 2023
iact_estatal = df[df['tcode'] == 2023].groupby(['NOMGEO'])['iact_norm'].mean().reset_index()

# 2. Unimos con el Efecto Diferencial (EDj)
analisis_final = pd.merge(edj_resultado, iact_estatal, on=['NOMGEO'])

# 3. Calculamos la correlación para ver qué tan fuerte es la relación
correlacion = analisis_final['EDj'].corr(analisis_final['iact_norm'])
print(f"La correlación entre tecnología y competitividad es: {correlacion:.2f}")

plt.figure(figsize=(14, 9))
sns.set_theme(style="whitegrid")

# Definir los umbrales de los cuadrantes
x_med = analisis_final['iact_norm'].mean()
y_med = 0  # El EDj es 0 para el equilibrio de competitividad

# Crear el scatter plot base
scatter = sns.scatterplot(
    data=analisis_final,
    x='iact_norm', y='EDj',
    size='iact_norm', hue='EDj',
    palette='RdYlGn', sizes=(100, 1000), alpha=0.6
)

# Función para filtrar y etiquetar el Top 3 por cuadrante
def etiquetar_top_cuadrantes(df, x_col, y_col, name_col, x_m, y_m):
    # Cuadrante 1: Alto IACT, Alto EDj (Líderes)
    c1 = df[(df[x_col] >= x_m) & (df[y_col] >= y_m)].nlargest(3, y_col)
    # Cuadrante 2: Bajo IACT, Alto EDj (Eficientes)
    c2 = df[(df[x_col] < x_m) & (df[y_col] >= y_m)].nlargest(3, y_col)
    # Cuadrante 3: Bajo IACT, Bajo EDj (Rezagados)
    c3 = df[(df[x_col] < x_m) & (df[y_col] < y_m)].nsmallest(3, y_col)
    # Cuadrante 4: Alto IACT, Bajo EDj (Falla de Absorción)
    c4 = df[(df[x_col] >= x_m) & (df[y_col] < y_m)].nsmallest(3, y_col)

    tops = pd.concat([c1, c2, c3, c4])

    for i, row in tops.iterrows():
        plt.text(row[x_col] + 0.005, row[y_col], row[name_col],
                 fontsize=11, fontweight='bold', alpha=0.9)

# Aplicar la función de etiquetado
etiquetar_top_cuadrantes(analisis_final, 'iact_norm', 'EDj', 'NOMGEO', x_med, y_med)

# Líneas y estética
plt.axhline(y_med, color='black', linestyle='--', alpha=0.4)
plt.axvline(x_med, color='blue', linestyle='--', alpha=0.4)
plt.title('Top 3 Estados por Perfil Tecnológico y Competitivo', fontsize=16)

plt.show()

def asignar_perfil(row, xm, ym):
    if row['iact_norm'] >= xm and row['EDj'] >= ym: return 'Líder Tecnológico'
    if row['iact_norm'] < xm and row['EDj'] >= ym: return 'Eficiente Tradicional'
    if row['iact_norm'] < xm and row['EDj'] < ym: return 'Rezagado'
    return 'Falla de Absorción'

analisis_final['Perfil_Estratégico'] = analisis_final.apply(asignar_perfil, args=(x_med, y_med), axis=1)

# Ver cuántos estados hay en cada categoría
resumen_perfiles = analisis_final['Perfil_Estratégico'].value_counts()
print(resumen_perfiles)

# Calcular la tasa de crecimiento nacional global (R_nacional)
total_t = df_dinamico['pot_T'].sum()
total_0 = df_dinamico['pot_0'].sum()
R_nacional = total_t / total_0

# Aplicar la fórmula del Efecto Estructural (EEj)
# EEj = suma de { V_ij(0) * (rSi - R_nacional) }
df_shift['efecto_estructural_sectorial'] = df_shift['pot_0'] * (df_shift['rsi'] - R_nacional)

eej_resultado = df_shift.groupby(['NOMGEO'])['efecto_estructural_sectorial'].sum().reset_index()
eej_resultado.rename(columns={'efecto_estructural_sectorial': 'EEj'}, inplace=True)

# Unir todos los componentes en una tabla maestra
resumen_shift_share = pd.merge(edj_resultado, eej_resultado, on=['NOMGEO'])

# Añadir el crecimiento total observado para comparar
crecimiento_total = df_dinamico.groupby(['NOMGEO'])['pot_T'].sum() - \
                   df_dinamico.groupby(['NOMGEO'])['pot_0'].sum()
resumen_shift_share['Crecimiento_Total'] = crecimiento_total.values

resumen_shift_share.set_index('NOMGEO')[['EEj', 'EDj']].plot(kind='bar', stacked=True, figsize=(15,7))
plt.title('Descomposición del Crecimiento Estatal: Estructura vs. Competitividad')
plt.ylabel('Personal Ocupado')
plt.axhline(0, color='black')
plt.show()

# Calcular inversos de tasas de crecimiento (T0 / Tt)
# Inverso Nacional
inverso_R_nacional = df_dinamico['pot_0'].sum() / df_dinamico['pot_T'].sum()

# Inverso Estatal (por cada estado)
totales_estatales = df_dinamico.groupby(['NOMGEO']).agg({
    'pot_T': 'sum',
    'pot_0': 'sum'
}).reset_index()

totales_estatales['inverso_R_estatal'] = totales_estatales['pot_0'] / totales_estatales['pot_T']

# 2. Unir al dataframe principal
df_shift = pd.merge(df_shift, totales_estatales[['NOMGEO', 'inverso_R_estatal']], on='NOMGEO', how='left')

# 3. Aplicar la fórmula del Efecto Inercial por sector
# EI = V(t) * (Inverso_Nac - Inverso_Est)
df_shift['ei_sectorial'] = df_shift['pot_T'] * (inverso_R_nacional - df_shift['inverso_R_estatal'])

# 4. Agrupar por estado para obtener el EIj final
eij_resultado = df_shift.groupby(['NOMGEO'])['ei_sectorial'].sum().reset_index()
eij_resultado.rename(columns={'ei_sectorial': 'EIj'}, inplace=True)

eij_plot = eij_resultado.sort_values('EIj', ascending=False)

# Crear el gráfico
plt.figure(figsize=(10, 12))
colors = ['#2ecc71' if x > 0 else '#e74c3c' for x in eij_plot['EIj']]

sns.barplot(
    data=eij_plot,
    x='EIj',
    y='NOMGEO',
    palette=colors
)

# 3. Estética y referencias
plt.axvline(0, color='black', linewidth=1.5, linestyle='-')
plt.title('Efecto Inercial ($EI_j$): Inercia del Crecimiento Estatal vs. Nacional\n(2004-2023)', fontsize=14)
plt.xlabel('Magnitud del Efecto Inercial (Positivo = Ritmo superior al Nacional)', fontsize=12)
plt.ylabel('Entidad Federativa', fontsize=12)
plt.grid(axis='x', linestyle='--', alpha=0.6)

plt.tight_layout()
plt.show()

# Preparar datos: Crecimiento Nacional (CN), Efecto Estructural (EEj) y Diferencial (EDj)
# Nota: CN = V_ij(0) * (R_nacional - 1)
resumen_shift_share['CN'] = df_dinamico.groupby(['NOMGEO'])['pot_0'].sum().values * (R_nacional - 1)

plot_data = resumen_shift_share.set_index('NOMGEO')[['CN', 'EEj', 'EDj']]

# Graficar
ax = plot_data.sort_values('CN', ascending=True).plot(
    kind='barh',
    stacked=True,
    figsize=(12, 10),
    color=['#3498db', '#f1c40f', '#2ecc71']
)

plt.axvline(0, color='black', linewidth=0.8)
plt.title('Componentes del Cambio en el Personal Ocupado (2004-2023)', fontsize=15)
plt.xlabel('Número de Personas Ocupadas')
plt.legend(['Crecimiento Nacional (Inercia)', 'Efecto Estructural (Mezcla)', 'Efecto Diferencial (Competitividad)'])
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 8))
sns.scatterplot(data=resumen_shift_share, x='EEj', y='EDj', s=100, color='red')

# Líneas cruzadas en el origen (0,0)
plt.axhline(0, color='black', linestyle='--', alpha=0.5)
plt.axvline(0, color='black', linestyle='--', alpha=0.5)

# Etiquetas de cuadrantes
plt.text(resumen_shift_share['EEj'].max()*0.5, resumen_shift_share['EDj'].max()*0.8, 'GANADORES\n(Sectores dinámicos + Eficiencia)', color='green', fontweight='bold')
plt.text(resumen_shift_share['EEj'].min()*0.8, resumen_shift_share['EDj'].max()*0.8, 'SOBREVIVIENTES\n(Sectores lentos + Eficiencia)', color='blue', fontweight='bold')
plt.text(resumen_shift_share['EEj'].min()*0.8, resumen_shift_share['EDj'].min()*0.8, 'REZAGADOS\n(Sectores lentos + Ineficiencia)', color='red', fontweight='bold')

# Etiquetar solo los 5 estados más extremos
for i, row in resumen_shift_share.nlargest(5, 'EDj').iterrows():
    plt.text(row['EEj'], row['EDj'], row['NOMGEO'])

plt.title('Matriz de Diagnóstico Regional: Estructura vs. Competitividad', fontsize=14)
plt.xlabel('Efecto Estructural (EEj)')
plt.ylabel('Efecto Diferencial (EDj)')
plt.show()

def veredicto(row):
    if row['EEj'] > 0 and row['EDj'] > 0: return "Líder: Sectores ganadores y alta competitividad."
    if row['EEj'] < 0 and row['EDj'] > 0: return "Resiliente: Supera su mala estructura sectorial."
    if row['EEj'] > 0 and row['EDj'] < 0: return "Desaprovechado: Tiene buenos sectores pero es ineficiente."
    return "Crítico: Estructura obsoleta y baja competitividad."

resumen_shift_share['Conclusión'] = resumen_shift_share.apply(veredicto, axis=1)

# Mostrar los estados más interesantes
print(resumen_shift_share[['NOMGEO', 'EEj', 'EDj', 'Conclusión']].sort_values('EDj', ascending=False))

# Calcular el promedio de automatización por sector (AE) en 2023
automa_sectorial = df[df['tcode'] == 2023].groupby('AE').agg({
    'atmep': 'sum',
    'ppvs': 'sum',
    'pot': 'sum'
}).reset_index()

automa_sectorial['automa'] = automa_sectorial['atmep'] / automa_sectorial['ppvs']

# Unir con la tasa de crecimiento rSi
bubble_data = pd.merge(automa_sectorial, rsi.reset_index(), on='AE')

# Limpiar valores para el gráfico (evitar división por cero o NaNs)
bubble_data = bubble_data.replace([np.inf, -np.inf], np.nan).dropna()

plt.figure(figsize=(14, 10))

# Crear el gráfico de burbujas
# Eje X: Automatización (Log para manejar escalas grandes)
# Eje Y: Crecimiento Sectorial
# Tamaño: Personal Ocupado Total (pot)
scatter = plt.scatter(
    x=bubble_data['automa'],
    y=bubble_data['rsi'],
    s=bubble_data['pot'] / 100, # Ajustar escala del tamaño
    alpha=0.5,
    c=bubble_data['rsi'],
    cmap='viridis',
    edgecolors="w",
    linewidth=1
)

# Líneas de referencia
plt.axhline(1, color='red', linestyle='--', alpha=0.5) # Línea de no crecimiento
plt.axvline(bubble_data['automa'].median(), color='blue', linestyle='--', alpha=0.5) # Mediana de automatización

# Etiquetar los 8 sectores más automatizados o con más crecimiento
top_labels = bubble_data.nlargest(8, 'automa')
for i, row in top_labels.iterrows():
    plt.text(row['automa'], row['rsi'], row['AE'], fontsize=9, fontweight='bold')

plt.xscale('log') # Escala logarítmica para ver mejor la distribución
plt.title('Grado de Automatización vs. Crecimiento Sectorial (2004-2023)', fontsize=16)
plt.xlabel('Grado de Automatización (Activos / Personal Operativo) - Escala Log', fontsize=12)
plt.ylabel('Crecimiento Nacional del Sector (rSi)', fontsize=12)
plt.colorbar(label='Tasa de Crecimiento')

plt.show()