# -*- coding: utf-8 -*-
"""abmctmex.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jV36qD_6zgGIYusCYc2uEuIWRjeZfE_v
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import defaultdict

# Definición de sectores simplificados
SECTORS = {
    1: "Agricultura-Minería",
    2: "Manufactura",
    3: "Servicios",
    4: "Turismo"
}

# Parámetros clave ajustados
INITIAL_TECH = 0.4  # Capacidad tecnológica inicial baja
PROFIT_MARGIN_IMPACT = 0.7  # Peso del margen de ganancia en las decisiones
TECH_DEVELOPMENT_COST = 0.1  # Costo de desarrollar capacidades tecnológicas

class Region:
    """Clase que representa una región con preferencia por margen de ganancia."""
    def __init__(self, region_id):
        self.id = region_id
        self.sector = random.choice(list(SECTORS.keys()))
        self.tech_capability = INITIAL_TECH
        self.profit_margin = self.set_initial_margin()
        self.productivity = 0.5
        self.specialization = random.uniform(0.3, 0.8)
        self.trapped = False

    def set_initial_margin(self):
        """Establece margen inicial basado en sector"""
        if self.sector == 1:  # Agricultura-Minería
            return random.uniform(0.2, 0.4)
        elif self.sector == 2:  # Manufactura
            return random.uniform(0.15, 0.3)
        elif self.sector == 3:  # Servicios
            return random.uniform(0.3, 0.5)
        else:  # Turismo
            return random.uniform(0.25, 0.6)

    def update(self):
        """Actualiza el estado de la región"""
        # Toma de decisiones basada en margen vs productividad
        self.make_decision()

        # Actualizar métricas
        self.update_metrics()

        # Verificar trampa de innovación
        self.check_innovation_trap()

    def make_decision(self):
        """Toma decisiones entre mantener margen o invertir en productividad"""
        # Probabilidad de invertir en tecnología (inversa al margen actual)
        tech_investment_prob = 0.1 * (1 - self.profit_margin)

        if random.random() < tech_investment_prob:
            # Invierte en tecnología (reduce margen, aumenta capacidad)
            self.tech_capability += random.uniform(0.05, 0.15)
            self.profit_margin = max(0.1, self.profit_margin - random.uniform(0.05, 0.1))
        else:
            # Prioriza margen (poco desarrollo tecnológico)
            self.profit_margin += random.uniform(0, 0.05)
            # Pequeña degradación tecnológica por falta de inversión
            self.tech_capability = max(0.1, self.tech_capability - random.uniform(0, 0.02))

    def update_metrics(self):
        """Actualiza métricas de desempeño"""
        # Productividad depende de capacidad tecnológica pero limitada por preferencia de margen
        self.productivity = np.clip(
            self.tech_capability * (1 - self.profit_margin * PROFIT_MARGIN_IMPACT),
            0.1, 0.9
        )

        # Especialización tiende a disminuir sin inversión tecnológica
        if random.random() < 0.7:  # Alta probabilidad de pérdida
            self.specialization = max(0.1, self.specialization - random.uniform(0, 0.03))

    def check_innovation_trap(self):
        """Determina si la región está en trampa de innovación"""
        # Condiciones para trampa:
        low_tech = self.tech_capability < 0.3
        high_margin = self.profit_margin > 0.35
        low_productivity = self.productivity < 0.4

        self.trapped = low_tech and high_margin and low_productivity

        # Refuerzo de la trampa
        if self.trapped:
            # Menor probabilidad de invertir en tecnología
            self.profit_margin = min(0.9, self.profit_margin + random.uniform(0, 0.02))
            self.tech_capability = max(0.1, self.tech_capability - random.uniform(0, 0.01))

class ProfitFocusModel:
    """Modelo de preferencia por margen de ganancia vs desarrollo tecnológico."""
    def __init__(self, n_regions=20):
        self.regions = [Region(i) for i in range(n_regions)]
        self.steps = 0
        self.history = []

    def step(self):
        """Avanza la simulación un paso."""
        for region in random.sample(self.regions, len(self.regions)):
            region.update()

        self.record_state()
        self.steps += 1

    def record_state(self):
        """Registra métricas clave."""
        avg_tech = np.mean([r.tech_capability for r in self.regions])
        avg_margin = np.mean([r.profit_margin for r in self.regions])
        avg_productivity = np.mean([r.productivity for r in self.regions])
        trapped_pct = np.mean([1 if r.trapped else 0 for r in self.regions])

        sector_dist = defaultdict(int)
        for region in self.regions:
            sector_dist[region.sector] += 1

        self.history.append({
            "step": self.steps,
            "avg_tech": avg_tech,
            "avg_margin": avg_margin,
            "avg_productivity": avg_productivity,
            "trapped_pct": trapped_pct,
            **{f"sector_{s}": sector_dist.get(s, 0) for s in SECTORS.keys()}
        })

    def run(self, steps=30):
        """Ejecuta la simulación."""
        for _ in range(steps):
            self.step()

    def get_results(self):
        """Obtiene resultados."""
        model_data = pd.DataFrame(self.history)

        agent_data = []
        for region in self.regions:
            agent_data.append({
                "id": region.id,
                "sector": SECTORS[region.sector],
                "tech": region.tech_capability,
                "margin": region.profit_margin,
                "productivity": region.productivity,
                "specialization": region.specialization,
                "trapped": region.trapped
            })

        return model_data, pd.DataFrame(agent_data)

def analyze_results(model_data, agent_data):
    """Analiza y visualiza resultados."""
    plt.figure(figsize=(15, 10))

    # 1. Evolución de métricas promedio
    plt.subplot(2, 2, 1)
    plt.plot(model_data['step'], model_data['avg_tech'], label='Capacidad Tecnológica')
    plt.plot(model_data['step'], model_data['avg_productivity'], label='Productividad')
    plt.title('Desarrollo Tecnológico vs Productividad')
    plt.xlabel('Paso de tiempo')
    plt.ylabel('Valor promedio')
    plt.legend()

    plt.subplot(2, 2, 2)
    plt.plot(model_data['step'], model_data['avg_margin'], color='red')
    plt.title('Evolución del Margen de Ganancia Promedio')
    plt.xlabel('Paso de tiempo')
    plt.ylabel('Margen promedio')

    plt.subplot(2, 2, 3)
    plt.plot(model_data['step'], model_data['trapped_pct'], color='darkred')
    plt.title('Porcentaje de Regiones en Trampa de Innovación')
    plt.xlabel('Paso de tiempo')
    plt.ylabel('Porcentaje')

    # 2. Distribución por sector
    sector_cols = [f"sector_{s}" for s in SECTORS.keys()]
    sector_data = model_data[sector_cols]
    sector_data.columns = [SECTORS[s] for s in SECTORS.keys()]
    sector_data.plot(kind='area', stacked=True, ax=plt.subplot(2, 2, 4))
    plt.title('Distribución de Sectores Económicos')
    plt.xlabel('Paso de tiempo')
    plt.ylabel('Número de regiones')

    plt.tight_layout()
    plt.show()

    # 3. Relación entre variables finales
    sns.pairplot(
        agent_data[['tech', 'margin', 'productivity', 'specialization', 'sector']],
        hue='sector', palette='viridis', plot_kws={'alpha': 0.6}
    )
    plt.suptitle('Relaciones Clave por Sector Económico', y=1.02)
    plt.show()

    # 4. Análisis de trampas por sector
    if 'trapped' in agent_data.columns:
        trapped_by_sector = agent_data[agent_data['trapped']].groupby('sector').size()
        print("\nRegiones en trampa de innovación por sector:")
        print(trapped_by_sector)

        print("\nCaracterísticas promedio de regiones atrapadas:")
        print(agent_data[agent_data['trapped']].describe().round(3))
    else:
        print("\nNo hay regiones en trampa de innovación al final")

# Ejecutar simulación
model = ProfitFocusModel(n_regions=20)
model.run(steps=30)

# Analizar resultados
model_data, agent_data = model.get_results()
analyze_results(model_data, agent_data)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import defaultdict

# Definición completa de sectores económicos basados en el estudio original
SECTORS = {
    11: "Agricultura, ganadería, silvicultura y pesca",
    21: "Minería",
    22: "Generación y distribución de energía",
    23: "Construcción",
    31: "Manufactura (alimentos, bebidas, tabaco)",
    32: "Manufactura (textiles, prendas de vestir)",
    33: "Manufactura (productos de madera, papel)",
    34: "Manufactura (químicos, farmacéuticos)",
    35: "Manufactura (plásticos, minerales no metálicos)",
    36: "Manufactura (metálicos, maquinaria)",
    37: "Manufactura (electrónica, equipos)",
    43: "Comercio al por mayor",
    46: "Comercio al por menor",
    48: "Transporte terrestre",
    49: "Transporte aéreo y marítimo",
    51: "Servicios de información (TI, telecomunicaciones)",
    52: "Servicios financieros y seguros",
    53: "Servicios inmobiliarios",
    54: "Servicios profesionales, científicos y técnicos",
    55: "Servicios corporativos",
    56: "Servicios de apoyo a negocios",
    61: "Servicios educativos",
    62: "Servicios de salud",
    71: "Servicios de esparcimiento y culturales",
    72: "Servicios de alojamiento y alimentos",
    81: "Otros servicios",
    93: "Actividades gubernamentales"
}

# Clasificación de sectores por tipo para simplificar análisis
SECTOR_TYPES = {
    'Primario': [11, 21],
    'Manufactura': list(range(31, 38)),
    'Comercio': [43, 46],
    'Transporte': [48, 49],
    'Servicios_Especializados': list(range(51, 57)),
    'Servicios_Sociales': [61, 62],
    'Turismo': [71, 72],
    'Otros': [81, 93]
}

# Parámetros de comportamiento por tipo de sector
SECTOR_PARAMS = {
    'Primario': {'margin_range': (0.2, 0.4), 'tech_invest': 0.1, 'volatility': 0.3},
    'Manufactura': {'margin_range': (0.15, 0.3), 'tech_invest': 0.3, 'volatility': 0.2},
    'Comercio': {'margin_range': (0.25, 0.45), 'tech_invest': 0.15, 'volatility': 0.25},
    'Transporte': {'margin_range': (0.2, 0.35), 'tech_invest': 0.25, 'volatility': 0.15},
    'Servicios_Especializados': {'margin_range': (0.3, 0.5), 'tech_invest': 0.35, 'volatility': 0.1},
    'Servicios_Sociales': {'margin_range': (0.1, 0.25), 'tech_invest': 0.2, 'volatility': 0.05},
    'Turismo': {'margin_range': (0.25, 0.6), 'tech_invest': 0.1, 'volatility': 0.4},
    'Otros': {'margin_range': (0.15, 0.3), 'tech_invest': 0.05, 'volatility': 0.2}
}

class EconomicSector:
    """Clase que representa un sector económico con sus características."""
    def __init__(self, sector_id):
        self.id = sector_id
        self.name = SECTORS[sector_id]
        self.type = self.get_sector_type()
        self.params = SECTOR_PARAMS[self.type]

    def get_sector_type(self):
        """Obtiene el tipo de sector para el ID dado."""
        for sector_type, ids in SECTOR_TYPES.items():
            if self.id in ids:
                return sector_type
        return 'Otros'

class Region:
    """Clase que representa una región con su sector económico predominante."""
    def __init__(self, region_id):
        self.id = region_id
        self.sector = EconomicSector(random.choice(list(SECTORS.keys())))
        self.tech_capability = INITIAL_TECH
        self.profit_margin = self.set_initial_margin()
        self.productivity = 0.5
        self.specialization = random.uniform(0.3, 0.8)
        self.trapped = False
        self.history = []

    def set_initial_margin(self):
        """Establece margen inicial basado en sector."""
        params = self.sector.params
        return random.uniform(*params['margin_range'])

    def update(self):
        """Actualiza el estado de la región."""
        # Toma de decisiones estratégicas
        self.make_strategic_decision()

        # Actualización de métricas de desempeño
        self.update_performance()

        # Verificación de trampa de innovación
        self.check_innovation_trap()

        # Registro histórico
        self.record_history()

    def make_strategic_decision(self):
        """Toma decisiones entre margen y desarrollo tecnológico."""
        params = self.sector.params

        # Probabilidad base de invertir en tecnología
        tech_invest_prob = params['tech_invest'] * (1 - self.profit_margin)

        if random.random() < tech_invest_prob:
            # Decide invertir en tecnología
            tech_gain = random.uniform(0.05, 0.15)
            margin_cost = random.uniform(0.03, 0.08)

            self.tech_capability += tech_gain
            self.profit_margin = max(0.1, self.profit_margin - margin_cost)
        else:
            # Prioriza margen de ganancia
            margin_gain = random.uniform(0, 0.05)
            tech_decay = random.uniform(0, 0.03) * params['volatility']

            self.profit_margin += margin_gain
            self.tech_capability = max(0.1, self.tech_capability - tech_decay)

    def update_performance(self):
        """Actualiza métricas de desempeño."""
        params = self.sector.params

        # Productividad depende de tecnología pero limitada por enfoque en margen
        self.productivity = np.clip(
            self.tech_capability * (1 - self.profit_margin * PROFIT_MARGIN_IMPACT),
            0.1, 0.9
        )

        # Especialización tiende a disminuir sin inversión tecnológica
        if random.random() < 0.6:  # Probabilidad de pérdida de especialización
            loss_rate = 0.02 * (1 + params['volatility'])
            self.specialization = max(0.1, self.specialization - loss_rate)

    def check_innovation_trap(self):
        """Determina si la región está en trampa de innovación."""
        sector_params = self.sector.params

        # Umbrales adaptados por tipo de sector
        tech_threshold = 0.35 if sector_params['tech_invest'] > 0.2 else 0.25
        margin_threshold = 0.4 - (sector_params['tech_invest'] * 0.2)
        productivity_threshold = 0.45

        conditions = (
            self.tech_capability < tech_threshold,
            self.profit_margin > margin_threshold,
            self.productivity < productivity_threshold
        )

        self.trapped = all(conditions)

        # Refuerzo de la trampa
        if self.trapped:
            self.profit_margin = min(0.9, self.profit_margin + random.uniform(0, 0.02))
            self.tech_capability = max(0.1, self.tech_capability - random.uniform(0, 0.01))

    def record_history(self):
        """Registra el estado actual en el historial."""
        self.history.append({
            'step': len(self.history),
            'tech': self.tech_capability,
            'margin': self.profit_margin,
            'productivity': self.productivity,
            'specialization': self.specialization,
            'trapped': self.trapped
        })

class ComprehensiveModel:
    """Modelo completo con todos los sectores económicos."""
    def __init__(self, n_regions=32):
        self.regions = [Region(i) for i in range(n_regions)]
        self.steps = 0
        self.history = []

    def step(self):
        """Avanza la simulación un paso."""
        for region in random.sample(self.regions, len(self.regions)):
            region.update()

        self.record_state()
        self.steps += 1

    def record_state(self):
        """Registra métricas agregadas."""
        # Cálculo de promedios generales
        avg_tech = np.mean([r.tech_capability for r in self.regions])
        avg_margin = np.mean([r.profit_margin for r in self.regions])
        avg_productivity = np.mean([r.productivity for r in self.regions])
        trapped_pct = np.mean([1 if r.trapped else 0 for r in self.regions])

        # Distribución por tipo de sector
        sector_dist = defaultdict(int)
        for region in self.regions:
            sector_dist[region.sector.type] += 1

        # Guardar en historial
        self.history.append({
            "step": self.steps,
            "avg_tech": avg_tech,
            "avg_margin": avg_margin,
            "avg_productivity": avg_productivity,
            "trapped_pct": trapped_pct,
            **{f"sector_{t}": sector_dist.get(t, 0) for t in SECTOR_TYPES.keys()}
        })

    def run(self, steps=30):
        """Ejecuta la simulación."""
        for _ in range(steps):
            self.step()

    def get_results(self):
        """Obtiene resultados de la simulación."""
        model_data = pd.DataFrame(self.history)

        agent_data = []
        for region in self.regions:
            agent_data.append({
                "id": region.id,
                "sector_id": region.sector.id,
                "sector_name": region.sector.name,
                "sector_type": region.sector.type,
                "tech": region.tech_capability,
                "margin": region.profit_margin,
                "productivity": region.productivity,
                "specialization": region.specialization,
                "trapped": region.trapped,
                "tech_invest_prob": region.sector.params['tech_invest'],
                "sector_volatility": region.sector.params['volatility']
            })

        return model_data, pd.DataFrame(agent_data)

def analyze_results(model_data, agent_data):
    """Analiza y visualiza resultados."""
    plt.figure(figsize=(18, 12))

    # 1. Evolución de métricas clave
    plt.subplot(2, 2, 1)
    plt.plot(model_data['step'], model_data['avg_tech'], label='Capacidad Tecnológica')
    plt.plot(model_data['step'], model_data['avg_productivity'], label='Productividad')
    plt.title('Evolución de Capacidades y Productividad', fontsize=12)
    plt.xlabel('Paso de tiempo')
    plt.ylabel('Valor promedio')
    plt.legend()

    plt.subplot(2, 2, 2)
    plt.plot(model_data['step'], model_data['avg_margin'], color='red')
    plt.title('Evolución del Margen de Ganancia Promedio', fontsize=12)
    plt.xlabel('Paso de tiempo')
    plt.ylabel('Margen promedio')

    plt.subplot(2, 2, 3)
    plt.plot(model_data['step'], model_data['trapped_pct'], color='darkred')
    plt.title('Porcentaje de Regiones en Trampa de Innovación', fontsize=12)
    plt.xlabel('Paso de tiempo')
    plt.ylabel('Porcentaje')
    plt.ylim(0, 1)

    # 2. Distribución por tipo de sector
    sector_cols = [f"sector_{t}" for t in SECTOR_TYPES.keys()]
    sector_data = model_data[sector_cols]
    sector_data.columns = [t.replace('_', ' ') for t in SECTOR_TYPES.keys()]
    sector_data.plot(kind='area', stacked=True, ax=plt.subplot(2, 2, 4))
    plt.title('Distribución de Tipos de Sectores', fontsize=12)
    plt.xlabel('Paso de tiempo')
    plt.ylabel('Número de regiones')

    plt.tight_layout()
    plt.show()

    # 3. Análisis por tipo de sector
    sector_analysis = agent_data.groupby('sector_type').agg({
        'tech': 'mean',
        'margin': 'mean',
        'productivity': 'mean',
        'specialization': 'mean',
        'trapped': 'mean',
        'tech_invest_prob': 'first',
        'sector_volatility': 'first'
    }).sort_values('tech', ascending=False)

    print("\nAnálisis comparativo por tipo de sector:")
    print(sector_analysis.round(3))

    # 4. Relaciones entre variables
    plt.figure(figsize=(15, 10))
    sns.scatterplot(
        data=agent_data,
        x='margin',
        y='tech',
        hue='sector_type',
        size='productivity',
        sizes=(20, 200),
        alpha=0.7,
        palette='viridis'
    )
    plt.title('Relación entre Margen de Ganancia y Capacidad Tecnológica', fontsize=14)
    plt.xlabel('Margen de Ganancia')
    plt.ylabel('Capacidad Tecnológica')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.grid(True, alpha=0.3)
    plt.show()

    # 5. Análisis de trampas por sector
    if 'trapped' in agent_data.columns:
        trapped_by_sector = agent_data[agent_data['trapped']].groupby('sector_type').size()
        trapped_by_sector = trapped_by_sector.reindex(SECTOR_TYPES.keys(), fill_value=0)

        plt.figure(figsize=(10, 6))
        trapped_by_sector.plot(kind='bar', color='darkred')
        plt.title('Regiones en Trampa de Innovación por Tipo de Sector', fontsize=12)
        plt.xlabel('Tipo de Sector')
        plt.ylabel('Número de regiones')
        plt.xticks(rotation=45)
        plt.show()

        print("\nResumen de regiones atrapadas:")
        print(agent_data[agent_data['trapped']].describe().round(3))

# Configuración global
INITIAL_TECH = 0.4
PROFIT_MARGIN_IMPACT = 0.7

# Ejecución del modelo
model = ComprehensiveModel(n_regions=32)
model.run(steps=30)

# Análisis de resultados
model_data, agent_data = model.get_results()
analyze_results(model_data, agent_data)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import defaultdict

# Configuración inicial
sns.set_style('darkgrid')
sns.set_palette("viridis")

# Parámetros globales
INITIAL_TECH = 0.4
PROFIT_MARGIN_IMPACT = 0.7
TECH_DEVELOPMENT_COST = 0.1
INITIAL_WORKFORCE_SKILL = 0.5
EDUCATION_INVESTMENT_RATE = 0.05

# Definición completa de sectores económicos
SECTORS = {
    11: "Agricultura, ganadería, silvicultura y pesca",
    21: "Minería",
    22: "Generación y distribución de energía",
    23: "Construcción",
    31: "Manufactura (alimentos, bebidas, tabaco)",
    32: "Manufactura (textiles, prendas de vestir)",
    33: "Manufactura (productos de madera, papel)",
    34: "Manufactura (químicos, farmacéuticos)",
    35: "Manufactura (plásticos, minerales no metálicos)",
    36: "Manufactura (metálicos, maquinaria)",
    37: "Manufactura (electrónica, equipos)",
    43: "Comercio al por mayor",
    46: "Comercio al por menor",
    48: "Transporte terrestre",
    49: "Transporte aéreo y marítimo",
    51: "Servicios de información (TI, telecomunicaciones)",
    52: "Servicios financieros y seguros",
    53: "Servicios inmobiliarios",
    54: "Servicios profesionales, científicos y técnicos",
    55: "Servicios corporativos",
    56: "Servicios de apoyo a negocios",
    61: "Servicios educativos",
    62: "Servicios de salud",
    71: "Servicios de esparcimiento y culturales",
    72: "Servicios de alojamiento y alimentos",
    81: "Otros servicios",
    93: "Actividades gubernamentales"
}

# Clasificación de sectores por tipo
SECTOR_TYPES = {
    'Primario': [11, 21],
    'Manufactura': list(range(31, 38)),
    'Comercio': [43, 46],
    'Transporte': [48, 49],
    'Servicios_Especializados': list(range(51, 57)),
    'Servicios_Sociales': [61, 62],
    'Turismo': [71, 72],
    'Otros': [81, 93]
}

# Parámetros por tipo de sector
SECTOR_PARAMS = {
    'Primario': {
        'margin_range': (0.2, 0.4),
        'tech_invest': 0.1,
        'volatility': 0.3,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.85, 0.95),
        'training_investment': 0.02
    },
    'Manufactura': {
        'margin_range': (0.15, 0.3),
        'tech_invest': 0.3,
        'volatility': 0.2,
        'skill_requirements': (0.4, 0.7),
        'employment_rate': (0.75, 0.9),
        'training_investment': 0.1
    },
    'Comercio': {
        'margin_range': (0.25, 0.45),
        'tech_invest': 0.15,
        'volatility': 0.25,
        'skill_requirements': (0.3, 0.6),
        'employment_rate': (0.7, 0.85),
        'training_investment': 0.05
    },
    'Transporte': {
        'margin_range': (0.2, 0.35),
        'tech_invest': 0.25,
        'volatility': 0.15,
        'skill_requirements': (0.4, 0.65),
        'employment_rate': (0.8, 0.9),
        'training_investment': 0.08
    },
    'Servicios_Especializados': {
        'margin_range': (0.3, 0.5),
        'tech_invest': 0.35,
        'volatility': 0.1,
        'skill_requirements': (0.6, 0.9),
        'employment_rate': (0.85, 0.95),
        'training_investment': 0.15
    },
    'Servicios_Sociales': {
        'margin_range': (0.1, 0.25),
        'tech_invest': 0.2,
        'volatility': 0.05,
        'skill_requirements': (0.5, 0.8),
        'employment_rate': (0.9, 0.98),
        'training_investment': 0.12
    },
    'Turismo': {
        'margin_range': (0.25, 0.6),
        'tech_invest': 0.1,
        'volatility': 0.4,
        'skill_requirements': (0.2, 0.5),
        'employment_rate': (0.6, 0.8),
        'training_investment': 0.03
    },
    'Otros': {
        'margin_range': (0.15, 0.3),
        'tech_invest': 0.05,
        'volatility': 0.2,
        'skill_requirements': (0.3, 0.6),
        'employment_rate': (0.7, 0.88),
        'training_investment': 0.04
    }
}

class Workforce:
    """Clase que representa la fuerza laboral de una región."""
    def __init__(self, sector_type):
        params = SECTOR_PARAMS[sector_type]
        self.skill_level = INITIAL_WORKFORCE_SKILL
        self.employment_rate = random.uniform(*params['employment_rate'])
        self.unemployment_rate = 1 - self.employment_rate
        self.training_investment = params['training_investment']
        self.skill_requirements = random.uniform(*params['skill_requirements'])

    def update(self, tech_investment, is_trapped):
        """Actualiza el estado de la fuerza laboral."""
        # Efecto de la inversión en tecnología
        tech_impact = tech_investment * 0.3  # La inversión en tecnología mejora habilidades

        # Efecto de la inversión en capacitación (reducida si está en trampa)
        training_impact = self.training_investment * (0.2 if is_trapped else 1.0)

        # Actualización de habilidades
        skill_change = (tech_impact + training_impact) * random.uniform(0.8, 1.2)
        self.skill_level = np.clip(self.skill_level + skill_change, 0.1, 1.0)

        # Ajuste de tasas de empleo
        skill_gap = abs(self.skill_level - self.skill_requirements)
        employment_change = (0.05 - skill_gap) * random.uniform(0.1, 0.3)
        self.employment_rate = np.clip(self.employment_rate + employment_change, 0.4, 0.98)
        self.unemployment_rate = 1 - self.employment_rate

        # Ajuste de requerimientos de habilidades (aumentan con inversión tecnológica)
        self.skill_requirements = np.clip(
            self.skill_requirements + (tech_investment * 0.1),
            0.2, 0.95
        )

class Region:
    """Clase que representa una región con dinámica laboral."""
    def __init__(self, region_id):
        self.id = region_id
        self.sector = EconomicSector(random.choice(list(SECTORS.keys())))
        self.tech_capability = INITIAL_TECH
        self.profit_margin = self.set_initial_margin()
        self.productivity = 0.5
        self.specialization = random.uniform(0.3, 0.8)
        self.workforce = Workforce(self.sector.type)
        self.trapped = False
        self.history = []

    def set_initial_margin(self):
        """Establece margen inicial basado en sector."""
        params = self.sector.params
        return random.uniform(*params['margin_range'])

    def update(self):
        """Actualiza el estado de la región."""
        # Toma de decisiones estratégicas
        self.make_strategic_decision()

        # Actualización de métricas de desempeño
        self.update_performance()

        # Actualización de la fuerza laboral
        self.update_workforce()

        # Verificación de trampa de innovación
        self.check_innovation_trap()

        # Registro histórico
        self.record_history()

    def make_strategic_decision(self):
        """Toma decisiones entre margen, tecnología y capital humano."""
        params = self.sector.params

        # Probabilidad de invertir en tecnología
        tech_invest_prob = params['tech_invest'] * (1 - self.profit_margin)

        if random.random() < tech_invest_prob:
            # Decide invertir en tecnología
            tech_gain = random.uniform(0.05, 0.15)
            margin_cost = random.uniform(0.03, 0.08)

            self.tech_capability += tech_gain
            self.profit_margin = max(0.1, self.profit_margin - margin_cost)
        else:
            # Prioriza margen de ganancia
            margin_gain = random.uniform(0, 0.05)
            tech_decay = random.uniform(0, 0.03) * params['volatility']

            self.profit_margin += margin_gain
            self.tech_capability = max(0.1, self.tech_capability - tech_decay)

        # Decisión sobre inversión en capital humano (depende de no estar atrapado)
        if not self.trapped and random.random() < EDUCATION_INVESTMENT_RATE:
            self.workforce.training_investment = min(
                0.2, self.workforce.training_investment * 1.1
            )
            self.profit_margin = max(0.1, self.profit_margin - 0.02)

    def update_performance(self):
        """Actualiza métricas de desempeño."""
        params = self.sector.params

        # Productividad depende de tecnología y habilidades de la fuerza laboral
        workforce_impact = 0.3 * self.workforce.skill_level
        tech_impact = 0.7 * self.tech_capability

        self.productivity = np.clip(
            (workforce_impact + tech_impact) * (1 - self.profit_margin * PROFIT_MARGIN_IMPACT),
            0.1, 0.9
        )

        # Especialización afectada por empleo y habilidades
        if random.random() < 0.6:
            specialization_loss = 0.02 * (1 + params['volatility'])
            if self.workforce.unemployment_rate > 0.15:
                specialization_loss *= 1.5
            self.specialization = max(0.1, self.specialization - specialization_loss)

    def update_workforce(self):
        """Actualiza la dinámica de la fuerza laboral."""
        # La inversión en tecnología afecta las habilidades requeridas
        self.workforce.update(self.tech_capability, self.trapped)

        # Efecto de trampa de innovación en capital humano
        if self.trapped:
            # Reducción de inversión en capacitación
            self.workforce.training_investment = max(
                0.01, self.workforce.training_investment * 0.9
            )

            # Pérdida de habilidades por falta de práctica
            if random.random() < 0.3:
                self.workforce.skill_level = max(
                    0.2, self.workforce.skill_level - 0.02
                )

    def check_innovation_trap(self):
        """Determina si la región está en trampa de innovación."""
        params = self.sector.params

        # Umbrales adaptados por tipo de sector
        tech_threshold = 0.35 if params['tech_invest'] > 0.2 else 0.25
        margin_threshold = 0.4 - (params['tech_invest'] * 0.2)
        productivity_threshold = 0.45
        skill_threshold = 0.5 if params['skill_requirements'][0] > 0.4 else 0.4

        conditions = (
            self.tech_capability < tech_threshold,
            self.profit_margin > margin_threshold,
            self.productivity < productivity_threshold,
            self.workforce.skill_level < skill_threshold,
            self.workforce.unemployment_rate > 0.1
        )

        self.trapped = sum(conditions) >= 3  # 3 de 5 condiciones

        # Refuerzo de la trampa
        if self.trapped:
            self.profit_margin = min(0.9, self.profit_margin + random.uniform(0, 0.02))
            self.tech_capability = max(0.1, self.tech_capability - random.uniform(0, 0.01))

    def record_history(self):
        """Registra el estado actual en el historial."""
        self.history.append({
            'step': len(self.history),
            'tech': self.tech_capability,
            'margin': self.profit_margin,
            'productivity': self.productivity,
            'specialization': self.specialization,
            'workforce_skill': self.workforce.skill_level,
            'employment_rate': self.workforce.employment_rate,
            'unemployment_rate': self.workforce.unemployment_rate,
            'training_investment': self.workforce.training_investment,
            'trapped': self.trapped
        })

class LaborMarketModel:
    """Modelo completo con dinámica laboral."""
    def __init__(self, n_regions=32):
        self.regions = [Region(i) for i in range(n_regions)]
        self.steps = 0
        self.history = []

    def step(self):
        """Avanza la simulación un paso."""
        for region in random.sample(self.regions, len(self.regions)):
            region.update()

        self.record_state()
        self.steps += 1

    def record_state(self):
        """Registra métricas agregadas."""
        # Cálculo de promedios generales
        avg_tech = np.mean([r.tech_capability for r in self.regions])
        avg_margin = np.mean([r.profit_margin for r in self.regions])
        avg_productivity = np.mean([r.productivity for r in self.regions])
        avg_skill = np.mean([r.workforce.skill_level for r in self.regions])
        avg_unemployment = np.mean([r.workforce.unemployment_rate for r in self.regions])
        trapped_pct = np.mean([1 if r.trapped else 0 for r in self.regions])

        # Distribución por tipo de sector
        sector_dist = defaultdict(int)
        for region in self.regions:
            sector_dist[region.sector.type] += 1

        # Guardar en historial
        self.history.append({
            "step": self.steps,
            "avg_tech": avg_tech,
            "avg_margin": avg_margin,
            "avg_productivity": avg_productivity,
            "avg_workforce_skill": avg_skill,
            "avg_unemployment": avg_unemployment,
            "trapped_pct": trapped_pct,
            **{f"sector_{t}": sector_dist.get(t, 0) for t in SECTOR_TYPES.keys()}
        })

    def run(self, steps=30):
        """Ejecuta la simulación."""
        for _ in range(steps):
            self.step()

    def get_results(self):
        """Obtiene resultados de la simulación."""
        model_data = pd.DataFrame(self.history)

        agent_data = []
        for region in self.regions:
            agent_data.append({
                "id": region.id,
                "sector_id": region.sector.id,
                "sector_name": region.sector.name,
                "sector_type": region.sector.type,
                "tech": region.tech_capability,
                "margin": region.profit_margin,
                "productivity": region.productivity,
                "specialization": region.specialization,
                "workforce_skill": region.workforce.skill_level,
                "employment_rate": region.workforce.employment_rate,
                "unemployment_rate": region.workforce.unemployment_rate,
                "training_investment": region.workforce.training_investment,
                "trapped": region.trapped,
                "tech_invest_prob": region.sector.params['tech_invest'],
                "sector_volatility": region.sector.params['volatility']
            })

        return model_data, pd.DataFrame(agent_data)

def analyze_results(model_data, agent_data):
    """Analiza y visualiza resultados."""
    # 1. Evolución de métricas clave
    fig, axes = plt.subplots(3, 2, figsize=(18, 15))

    # Tecnología y productividad
    axes[0, 0].plot(model_data['step'], model_data['avg_tech'], label='Capacidad Tecnológica')
    axes[0, 0].plot(model_data['step'], model_data['avg_productivity'], label='Productividad')
    axes[0, 0].set_title('Evolución de Capacidades y Productividad')
    axes[0, 0].legend()

    # Margen de ganancia
    axes[0, 1].plot(model_data['step'], model_data['avg_margin'], color='red')
    axes[0, 1].set_title('Evolución del Margen de Ganancia Promedio')

    # Habilidades de la fuerza laboral
    axes[1, 0].plot(model_data['step'], model_data['avg_workforce_skill'], color='green')
    axes[1, 0].set_title('Evolución de Calificación de la Fuerza Laboral')

    # Tasa de desempleo
    axes[1, 1].plot(model_data['step'], model_data['avg_unemployment'], color='orange')
    axes[1, 1].set_title('Evolución de la Tasa de Desempleo Promedio')

    # Regiones atrapadas
    axes[2, 0].plot(model_data['step'], model_data['trapped_pct'], color='darkred')
    axes[2, 0].set_title('Porcentaje de Regiones en Trampa de Innovación')
    axes[2, 0].set_ylim(0, 1)

    # Distribución de sectores
    sector_cols = [f"sector_{t}" for t in SECTOR_TYPES.keys()]
    sector_data = model_data[sector_cols]
    sector_data.columns = [t.replace('_', ' ') for t in SECTOR_TYPES.keys()]
    sector_data.plot(kind='area', stacked=True, ax=axes[2, 1])
    axes[2, 1].set_title('Distribución de Tipos de Sectores')

    plt.tight_layout()
    plt.show()

    # 2. Análisis por tipo de sector
    sector_analysis = agent_data.groupby('sector_type').agg({
        'tech': 'mean',
        'margin': 'mean',
        'productivity': 'mean',
        'workforce_skill': 'mean',
        'unemployment_rate': 'mean',
        'training_investment': 'mean',
        'trapped': 'mean'
    }).sort_values('workforce_skill', ascending=False)

    print("\nAnálisis comparativo por tipo de sector:")
    print(sector_analysis.round(3))

    # 3. Relación entre inversión en capacitación y habilidades
    plt.figure(figsize=(12, 6))
    sns.scatterplot(
        data=agent_data,
        x='training_investment',
        y='workforce_skill',
        hue='sector_type',
        size='tech',
        sizes=(20, 200),
        alpha=0.7
    )
    plt.title('Relación entre Inversión en Capacitación y Nivel de Habilidades')
    plt.xlabel('Inversión en Capacitación')
    plt.ylabel('Nivel de Habilidades de la Fuerza Laboral')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.grid(True, alpha=0.3)
    plt.show()

    # 4. Efecto de las trampas de innovación en el mercado laboral
    if 'trapped' in agent_data.columns:
        print("\nImpacto de las trampas de innovación en el mercado laboral:")
        trapped_stats = agent_data[agent_data['trapped']][[
            'workforce_skill', 'unemployment_rate', 'training_investment'
        ]].describe().round(3)

        non_trapped_stats = agent_data[~agent_data['trapped']][[
            'workforce_skill', 'unemployment_rate', 'training_investment'
        ]].describe().round(3)

        print("\nRegiones en trampa de innovación:")
        print(trapped_stats)

        print("\nRegiones no atrapadas:")
        print(non_trapped_stats)

        # Visualización comparativa
        fig, axes = plt.subplots(1, 3, figsize=(18, 5))

        sns.boxplot(data=agent_data, x='trapped', y='workforce_skill', ax=axes[0])
        axes[0].set_title('Nivel de Habilidades')

        sns.boxplot(data=agent_data, x='trapped', y='unemployment_rate', ax=axes[1])
        axes[1].set_title('Tasa de Desempleo')

        sns.boxplot(data=agent_data, x='trapped', y='training_investment', ax=axes[2])
        axes[2].set_title('Inversión en Capacitación')

        plt.tight_layout()
        plt.show()

# Ejecución del modelo
model = LaborMarketModel(n_regions=32)
model.run(steps=30)

# Análisis de resultados
model_data, agent_data = model.get_results()
analyze_results(model_data, agent_data)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import defaultdict

# Configuración inicial
sns.set_style('darkgrid')
sns.set_palette("viridis")
plt.rcParams['figure.figsize'] = [12, 6]

# Implementación del coeficiente Gini
def gini_coefficient(x):
    """Calcula el coeficiente de Gini para un array de valores."""
    x = np.abs(x)
    x = np.sort(x)
    n = len(x)
    cumx = np.cumsum(x)
    return (n + 1 - 2 * np.sum(cumx) / cumx[-1]) / n

# Parámetros globales
INITIAL_TECH = 0.1
PROFIT_MARGIN_IMPACT = 0.6
TECH_DEVELOPMENT_COST = 0.12
INITIAL_WORKFORCE_SKILL = 0.3
EDUCATION_INVESTMENT_RATE = 0.04
INNOVATION_THRESHOLD = 0.1
KNOWLEDGE_SPILLOVER = 0.1
WORKER_POOL_SIZE = 100000  # Tamaño del pool de trabajadores disponibles

# Sectores económicos con mayor detalle y características específicas
SECTORS = {
    1: "Agricultura Tradicional",
    2: "Agricultura Tecnificada",
    3: "Minería Básica",
    4: "Minería Tecnológica",
    5: "Manufactura Básica",
    6: "Manufactura Avanzada",
    7: "Servicios Básicos",
    8: "Servicios Financieros",
    9: "Servicios Tecnológicos",
    10: "Turismo Masivo",
    11: "Turismo Especializado",
    12: "Industria Creativa"
}

# Categorización de sectores por tipo y nivel tecnológico
SECTOR_TYPES = {
    'Primario_Bajo': [1, 3],
    'Primario_Alto': [2, 4],
    'Manufactura_Baja': [5],
    'Manufactura_Alta': [6],
    'Servicios_Bajos': [7],
    'Servicios_Intermedios': [8],
    'Servicios_Avanzados': [9],
    'Turismo_Masivo': [10],
    'Turismo_Especializado': [11],
    'Industria_Creativa': [12]
}

# Parámetros detallados por tipo de sector
SECTOR_PARAMS = {
    'Primario_Bajo': {
        'margin_range': (0.25, 0.45),
        'tech_invest': 0.05,
        'volatility': 0.35,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.7, 0.8),
        'training_investment': 0.05,
        'innovation_capacity': 0.1,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.7,
        'productivity': 5,
        'product_range': (3, 7)
    },
    'Primario_Alto': {
        'margin_range': (0.35, 0.55),
        'tech_invest': 0.25,
        'volatility': 0.25,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.75, 0.85),
        'training_investment': 0.15,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9)
    },
    'Manufactura_Baja': {
        'margin_range': (0.15, 0.3),
        'tech_invest': 0.2,
        'volatility': 0.2,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.85),
        'training_investment': 0.1,
        'innovation_capacity': 0.25,
        'knowledge_intensity': 0.35,
        'linkages': 0.6,
        'specialization_coeff': 0.5,
        'productivity': 8,
        'product_range': (6, 10)
    },
    'Manufactura_Alta': {
        'margin_range': (0.25, 0.4),
        'tech_invest': 0.4,
        'volatility': 0.15,
        'skill_requirements': (0.6, 0.8),
        'employment_rate': (0.8, 0.9),
        'training_investment': 0.2,
        'innovation_capacity': 0.5,
        'knowledge_intensity': 0.7,
        'linkages': 0.8,
        'specialization_coeff': 0.4,
        'productivity': 10,
        'product_range': (8, 12)
    },
    'Servicios_Bajos': {
        'margin_range': (0.2, 0.4),
        'tech_invest': 0.1,
        'volatility': 0.15,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.75, 0.9),
        'training_investment': 0.08,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.3,
        'linkages': 0.4,
        'specialization_coeff': 0.3,
        'productivity': 6,
        'product_range': (4, 8)
    },
    'Servicios_Intermedios': {
        'margin_range': (0.3, 0.5),
        'tech_invest': 0.25,
        'volatility': 0.1,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.8, 0.95),
        'training_investment': 0.15,
        'innovation_capacity': 0.35,
        'knowledge_intensity': 0.5,
        'linkages': 0.7,
        'specialization_coeff': 0.2,
        'productivity': 9,
        'product_range': (7, 11)
    },
    'Servicios_Avanzados': {
        'margin_range': (0.4, 0.65),
        'tech_invest': 0.45,
        'volatility': 0.1,
        'skill_requirements': (0.7, 0.9),
        'employment_rate': (0.85, 0.98),
        'training_investment': 0.25,
        'innovation_capacity': 0.7,
        'knowledge_intensity': 0.9,
        'linkages': 0.9,
        'specialization_coeff': 0.1,
        'productivity': 12,
        'product_range': (10, 14)
    },
    'Turismo_Masivo': {
        'margin_range': (0.2, 0.5),
        'tech_invest': 0.05,
        'volatility': 0.4,
        'skill_requirements': (0.2, 0.4),
        'employment_rate': (0.6, 0.85),
        'training_investment': 0.03,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.8,
        'productivity': 5,
        'product_range': (3, 7)
    },
    'Turismo_Especializado': {
        'margin_range': (0.3, 0.6),
        'tech_invest': 0.15,
        'volatility': 0.3,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.9),
        'training_investment': 0.1,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9)
    },
    'Industria_Creativa': {
        'margin_range': (0.35, 0.7),
        'tech_invest': 0.3,
        'volatility': 0.25,
        'skill_requirements': (0.6, 0.9),
        'employment_rate': (0.8, 0.95),
        'training_investment': 0.2,
        'innovation_capacity': 0.6,
        'knowledge_intensity': 0.8,
        'linkages': 0.7,
        'specialization_coeff': 0.3,
        'productivity': 9,
        'product_range': (7, 11)
    }
}

class Product:
    """Clase para modelar productos/servicios de una región."""
    def __init__(self, sector_type, product_id):
        params = SECTOR_PARAMS[sector_type]
        self.id = product_id
        self.name = f"Product_{sector_type}_{product_id}"
        self.revenue = random.uniform(*params['product_range'])
        self.cost = random.uniform(0.5, 0.9) * self.revenue
        self.production = random.uniform(3, 10)
        self.tech_intensity = random.uniform(0.1, params['knowledge_intensity'])
        self.skill_required = random.uniform(*params['skill_requirements'])

    def calculate_margin(self):
        return (self.revenue - self.cost) / self.revenue

class Worker:
    """Clase para modelar trabajadores individuales con sus habilidades."""
    def __init__(self, sector_type=None):
        if sector_type:
            params = SECTOR_PARAMS[sector_type]
            self.skill = random.uniform(
                max(0.1, params['skill_requirements'][0] - 0.2),
                min(1.0, params['skill_requirements'][1] + 0.1)
            )
            self.specialized_skill = random.uniform(0.5, 1.0)  # Habilidad específica para el sector
        else:
            self.skill = random.uniform(0.1, 0.7)  # Trabajador no especializado
            self.specialized_skill = 0.0

        self.employed = False
        self.region_id = None
        self.sector_type = sector_type

    def improve_skills(self, training_investment, tech_exposure):
        """Mejora las habilidades del trabajador basado en entrenamiento y tecnología."""
        skill_gain = (training_investment * 0.3) + (tech_exposure * 0.2)
        self.skill = np.clip(self.skill + random.uniform(0, skill_gain), 0.1, 1.0)

        if self.sector_type:
            specialized_gain = (training_investment * 0.4) + (tech_exposure * 0.1)
            self.specialized_skill = np.clip(
                self.specialized_skill + random.uniform(0, specialized_gain),
                0.1, 1.0
            )

class Workforce:
    """Clase para modelar la fuerza laboral con mayor detalle en cualificación."""
    def __init__(self, sector_type, region_id):
        params = SECTOR_PARAMS[sector_type]
        self.workers = []
        self.sector_type = sector_type
        self.region_id = region_id
        self.training_investment = params['training_investment']
        self.skill_requirements = random.uniform(*params['skill_requirements'])
        self.min_specialized_skill = 0.3  # Mínimo requerido para trabajadores especializados
        self.update_metrics()

    def update_metrics(self):
        """Calcula métricas basadas en la fuerza laboral actual."""
        if self.workers:
            self.avg_skill = np.mean([w.skill for w in self.workers])
            self.avg_specialized_skill = np.mean([w.specialized_skill for w in self.workers])
            self.qualification_gap = max(0, self.skill_requirements - self.avg_skill)
            self.specialization_gap = max(0, self.min_specialized_skill - self.avg_specialized_skill)
            self.wage_inequality = gini_coefficient([w.skill for w in self.workers])
        else:
            self.avg_skill = 0
            self.avg_specialized_skill = 0
            self.qualification_gap = self.skill_requirements
            self.specialization_gap = self.min_specialized_skill
            self.wage_inequality = 0

    def hire_workers(self, num_workers, worker_pool):
        """Contrata trabajadores del pool de trabajadores disponibles."""
        hired = 0
        available_workers = [w for w in worker_pool if not w.employed]

        # Primero intentar contratar trabajadores con habilidades especializadas
        specialized_workers = [w for w in available_workers if w.sector_type == self.sector_type]
        for worker in specialized_workers[:min(num_workers, len(specialized_workers))]:
            worker.employed = True
            worker.region_id = self.region_id
            self.workers.append(worker)
            hired += 1

        # Si aún necesitamos más trabajadores, contratar no especializados
        remaining = num_workers - hired
        if remaining > 0:
            general_workers = [w for w in available_workers if w not in specialized_workers]
            for worker in general_workers[:min(remaining, len(general_workers))]:
                worker.employed = True
                worker.region_id = self.region_id
                worker.sector_type = self.sector_type  # Se convierten en especializados
                self.workers.append(worker)
                hired += 1

        self.update_metrics()
        return hired

    def fire_workers(self, num_workers):
        """Despide trabajadores, comenzando por los menos calificados."""
        if not self.workers:
            return 0

        # Ordenar trabajadores por habilidad (menos calificados primero)
        self.workers.sort(key=lambda x: x.skill + x.specialized_skill)

        fired = 0
        for _ in range(min(num_workers, len(self.workers))):
            worker = self.workers.pop(0)
            worker.employed = False
            worker.region_id = None
            fired += 1

        self.update_metrics()
        return fired

    def adjust_workforce(self, required_workers, worker_pool):
        """Ajusta la fuerza laboral a los trabajadores requeridos."""
        current = len(self.workers)
        if current < required_workers:
            self.hire_workers(required_workers - current, worker_pool)
        elif current > required_workers:
            self.fire_workers(current - required_workers)

    def evaluate_workers(self):
        """Evalúa y posiblemente despide trabajadores que no cumplen los requisitos."""
        to_fire = []
        for worker in self.workers:
            if (worker.skill < self.skill_requirements * 0.7 or
                (worker.specialized_skill < self.min_specialized_skill * 0.7)):
                to_fire.append(worker)

        for worker in to_fire:
            self.workers.remove(worker)
            worker.employed = False
            worker.region_id = None

        self.update_metrics()
        return len(to_fire)

    def train_workers(self, tech_exposure):
        """Entrena y mejora las habilidades de los trabajadores."""
        for worker in self.workers:
            worker.improve_skills(self.training_investment, tech_exposure)
        self.update_metrics()

class Region:
    """Clase que representa una región con su economía y fuerza laboral."""
    def __init__(self, region_id, worker_pool):
        self.id = region_id
        self.worker_pool = worker_pool
        self.sector_id = random.choice(list(SECTORS.keys()))
        self.sector_type = self.get_sector_type()
        self.sector_name = SECTORS[self.sector_id]
        self.params = SECTOR_PARAMS[self.sector_type]

        # Variables económicas
        self.tech_capability = INITIAL_TECH
        self.profit_margin = random.uniform(*self.params['margin_range'])
        self.productivity = self.params['productivity']
        self.specialization = self.params['specialization_coeff']
        self.diversification = 1 - self.specialization
        self.innovation_rate = 0.03
        self.trapped = False
        self.employment_rate = random.uniform(*self.params['employment_rate'])

        # Productos/servicios
        self.products = [
            Product(self.sector_type, i) for i in range(random.randint(2, 5))
        ]
        self.total_production = sum(p.production for p in self.products)

        # Fuerza laboral
        self.workforce = Workforce(self.sector_type, self.id)
        self.required_workers = max(1, int(self.total_production / self.productivity))
        self.workforce.hire_workers(self.required_workers, self.worker_pool)

        # Historial
        self.specialization_history = [self.specialization]
        self.diversification_history = [self.diversification]
        self.qualification_gap_history = [self.workforce.qualification_gap]

    def get_sector_type(self):
        """Determina el tipo de sector."""
        for sector_type, ids in SECTOR_TYPES.items():
            if self.sector_id in ids:
                return sector_type
        return 'Primario_Bajo'

    def update(self):
        """Actualiza el estado de la región."""
        # Perturbaciones externas
        self.external_shocks()

        # Toma de decisiones estratégicas
        self.make_strategic_decision()

        # Ajustar productos/servicios
        self.adjust_products()

        # Innovación
        self.innovate()

        # Actualizar fuerza laboral
        self.update_workforce()

        # Actualizar métricas de desempeño
        self.update_performance()

        # Verificar trampa de innovación
        self.check_innovation_trap()

        # Registrar historial
        self.specialization_history.append(self.specialization)
        self.diversification_history.append(self.diversification)
        self.qualification_gap_history.append(self.workforce.qualification_gap)

    def external_shocks(self):
        """Simula perturbaciones externas a la región."""
        shock_factor = random.uniform(0.3, 0.6)
        self.total_production *= shock_factor

        # Afectar márgenes de ganancia
        margin_shock = random.uniform(-0.05, 0.05) * self.params['volatility']
        self.profit_margin = np.clip(
            self.profit_margin + margin_shock,
            *self.params['margin_range']
        )

        # Afectar productividad
        productivity_shock = random.uniform(-0.1, 0.1) * (1 - self.tech_capability)
        self.productivity = np.clip(
            self.productivity + productivity_shock,
            self.params['productivity'] * 0.7,
            self.params['productivity'] * 1.3
        )

    def make_strategic_decision(self):
        """Toma decisiones sobre inversión en tecnología vs márgenes."""
        if random.random() < self.params['tech_invest'] * (1 - self.profit_margin):
            # Invertir en tecnología
            tech_investment = random.uniform(0.05, 0.15) * (1 + self.diversification)
            self.tech_capability += tech_investment
            self.profit_margin = max(
                self.params['margin_range'][0],
                self.profit_margin - random.uniform(0.03, 0.08)
            )
        else:
            # Priorizar márgenes
            margin_increase = random.uniform(0, 0.05) * self.specialization
            self.profit_margin += margin_increase
            self.tech_capability = max(
                INITIAL_TECH,
                self.tech_capability - random.uniform(0, 0.03)
            )

    def adjust_products(self):
        """Ajusta la cartera de productos/servicios de la región."""
        # Calcular márgenes de cada producto
        product_margins = [p.calculate_margin() for p in self.products]
        avg_margin = np.mean(product_margins) if product_margins else 0

        # Eliminar productos con bajo desempeño (con cierta probabilidad)
        new_products = []
        production_lost = 0
        for product in self.products:
            if (product.calculate_margin() >= avg_margin * 0.7 or
                random.random() < 0.2):  # 20% de probabilidad de mantener
                new_products.append(product)
            else:
                production_lost += product.production

        self.products = new_products
        self.total_production -= production_lost

        # Añadir nuevos productos con cierta probabilidad
        if random.random() < self.innovation_rate * 2:  # Doble probabilidad para nuevos productos
            new_product = Product(self.sector_type, len(self.products) + 1)
            self.products.append(new_product)
            self.total_production += new_product.production

        # Recalcular trabajadores requeridos
        self.required_workers = max(1, int(self.total_production / self.productivity))

    def innovate(self):
        """Realiza actividades de innovación."""
        # Innovación tecnológica
        if random.random() < self.tech_capability:
            tech_gain = random.uniform(0.05, 0.1) * self.diversification
            self.tech_capability = min(1.0, self.tech_capability + tech_gain)

            # Aumentar requerimientos de habilidades con innovación tecnológica
            self.workforce.skill_requirements = np.clip(
                self.workforce.skill_requirements + (tech_gain * 0.3),
                *self.params['skill_requirements']
            )

        # Calcular tasa de innovación
        tech_factor = max(0, self.tech_capability - INNOVATION_THRESHOLD)
        skill_factor = self.workforce.avg_skill
        diversification_factor = self.diversification

        self.innovation_rate = (
            tech_factor * skill_factor * diversification_factor * 0.5 *
            (1 - self.workforce.wage_inequality) *
            self.params['innovation_capacity']
        )

    def update_workforce(self):
        """Actualiza la fuerza laboral de la región."""
        # Ajustar número de trabajadores
        self.workforce.adjust_workforce(self.required_workers, self.worker_pool)

        # Evaluar y posiblemente despedir trabajadores no calificados
        self.workforce.evaluate_workers()

        # Entrenar trabajadores
        self.workforce.train_workers(self.tech_capability)

        # Competir por trabajadores calificados con otras regiones
        self.compete_for_workers()

        # Actualizar tasa de empleo
        self.employment_rate = len(self.workforce.workers) / self.required_workers if self.required_workers > 0 else 0

    def compete_for_workers(self):
        """Competencia por trabajadores calificados con otras regiones."""
        if not hasattr(self, 'other_regions'):
            return

        # Solo competir si tenemos baja calificación laboral
        if self.workforce.qualification_gap > 0.1:
            for region in random.sample(self.other_regions, min(3, len(self.other_regions))):
                if region.id == self.id:
                    continue

                # Buscar trabajadores calificados en otras regiones
                qualified_workers = [
                    w for w in region.workforce.workers
                    if w.skill > self.workforce.avg_skill and
                    w.specialized_skill > self.workforce.avg_specialized_skill
                ]

                if qualified_workers and len(self.workforce.workers) < self.required_workers:
                    # Intentar "robar" un trabajador calificado
                    worker = random.choice(qualified_workers)
                    region.workforce.workers.remove(worker)
                    region.workforce.update_metrics()
                    self.workforce.workers.append(worker)
                    worker.region_id = self.id
                    self.workforce.update_metrics()

    def update_performance(self):
        """Actualiza métricas de desempeño económico."""
        # Calcular productividad
        workforce_impact = 0.4 * self.workforce.avg_skill
        tech_impact = 0.5 * self.tech_capability
        diversification_impact = 0.3 * self.diversification

        self.productivity = np.clip(
            (workforce_impact + tech_impact + diversification_impact) *
            (1 - self.profit_margin * PROFIT_MARGIN_IMPACT),
            self.params['productivity'] * 0.5,
            self.params['productivity'] * 1.5
        )

        # Ajustar especialización y diversificación
        margin_factor = self.profit_margin / self.params['margin_range'][1]
        if margin_factor > 0.8:
            # Alta rentabilidad lleva a mayor especialización
            self.specialization = min(
                0.95,
                self.specialization + random.uniform(0, 0.05) * margin_factor
            )
        else:
            # Baja rentabilidad puede llevar a diversificación
            if random.random() < 0.3:
                self.specialization = max(
                    0.05,
                    self.specialization - random.uniform(0, 0.03) * (1 - margin_factor)
                )

        self.diversification = 1 - self.specialization

    def check_innovation_trap(self):
        """Determina si la región cae en trampa de innovación."""
        conditions = (
            self.tech_capability < 0.35,
            self.profit_margin > 0.5,
            self.innovation_rate < 0.05,
            self.workforce.qualification_gap > 0.2,
            self.diversification < 0.3,
            len(self.products) <= 2
        )

        self.trapped = sum(conditions) >= 4

        # Refuerzo de la trampa
        if self.trapped:
            self.profit_margin = min(0.9, self.profit_margin * 1.02)
            self.tech_capability = max(0.1, self.tech_capability * 0.98)
            self.diversification = max(0.05, self.diversification * 0.95)
            self.specialization = 1 - self.diversification

class EconomicModel:
    """Modelo económico completo con todas las regiones."""
    def __init__(self, n_regions=20):
        # Crear pool global de trabajadores
        self.worker_pool = [Worker() for _ in range(WORKER_POOL_SIZE)]

        # Crear regiones
        self.regions = [Region(i, self.worker_pool) for i in range(n_regions)]

        # Establecer referencias cruzadas entre regiones para competencia laboral
        for region in self.regions:
            region.other_regions = [r for r in self.regions if r.id != region.id]

        self.steps = 0
        self.history = []

    def step(self):
        """Avanza la simulación un paso."""
        # Actualizar todas las regiones en orden aleatorio
        for region in random.sample(self.regions, len(self.regions)):
            region.update()

        self.record_state()
        self.steps += 1

    def record_state(self):
        """Registra el estado actual del modelo."""
        # Cálculo de promedios
        avg_tech = np.mean([r.tech_capability for r in self.regions])
        avg_margin = np.mean([r.profit_margin for r in self.regions])
        avg_productivity = np.mean([r.productivity for r in self.regions])
        avg_innovation = np.mean([r.innovation_rate for r in self.regions])
        avg_diversification = np.mean([r.diversification for r in self.regions])
        avg_specialization = np.mean([r.specialization for r in self.regions])

        # Desigualdades
        tech_inequality = gini_coefficient([r.tech_capability for r in self.regions])
        skill_inequality = np.mean([r.workforce.wage_inequality for r in self.regions])
        qualification_gap = np.mean([r.workforce.qualification_gap for r in self.regions])

        # Empleo y productos
        total_workers = sum(len(r.workforce.workers) for r in self.regions)
        unemployment_rate = 1 - (total_workers / WORKER_POOL_SIZE)
        total_products = sum(len(r.products) for r in self.regions)
        product_diversity = len(set(p.name for r in self.regions for p in r.products))

        # Guardar en historial
        self.history.append({
            "step": self.steps,
            "avg_tech": avg_tech,
            "avg_margin": avg_margin,
            "avg_productivity": avg_productivity,
            "avg_innovation": avg_innovation,
            "avg_diversification": avg_diversification,
            "avg_specialization": avg_specialization,
            "tech_inequality": tech_inequality,
            "skill_inequality": skill_inequality,
            "qualification_gap": qualification_gap,
            "unemployment_rate": unemployment_rate,
            "total_products": total_products,
            "product_diversity": product_diversity,
            "trapped_pct": np.mean([1 if r.trapped else 0 for r in self.regions])
        })

    def run(self, steps=30):
        """Ejecuta la simulación para varios pasos."""
        for _ in range(steps):
            self.step()

    def get_results(self):
        """Obtiene los resultados de la simulación."""
        model_data = pd.DataFrame(self.history)

        agent_data = []
        for region in self.regions:
            agent_data.append({
                "id": region.id,
                "sector_type": region.sector_type,
                "sector_name": region.sector_name,
                "tech": region.tech_capability,
                "margin": region.profit_margin,
                "productivity": region.productivity,
                "specialization": region.specialization,
                "diversification": region.diversification,
                "num_products": len(region.products),
                "workforce_size": len(region.workforce.workers),
                "avg_skill": region.workforce.avg_skill,
                "avg_specialized_skill": region.workforce.avg_specialized_skill,
                "skill_requirements": region.workforce.skill_requirements,
                "qualification_gap": region.workforce.qualification_gap,
                "specialization_gap": region.workforce.specialization_gap,
                "wage_inequality": region.workforce.wage_inequality,
                "innovation_rate": region.innovation_rate,
                "employment_rate": region.employment_rate,
                "trapped": region.trapped
            })

        return model_data, pd.DataFrame(agent_data)

# Función para visualizar resultados
def visualize_results(model_data, agent_data):
    """Crea visualizaciones para analizar los resultados."""
    fig, axs = plt.subplots(3, 3, figsize=(18, 15))

    # 1. Evolución de capacidades tecnológicas e innovación
    axs[0, 0].plot(model_data['step'], model_data['avg_tech'], label='Capacidad Tecnológica')
    axs[0, 0].plot(model_data['step'], model_data['avg_innovation'], label='Tasa de Innovación')
    axs[0, 0].set_title('Evolución de CT e Innovación')
    axs[0, 0].legend()

    # 2. Desigualdades
    axs[0, 1].plot(model_data['step'], model_data['tech_inequality'], label='Desigualdad en CT')
    axs[0, 1].plot(model_data['step'], model_data['skill_inequality'], label='Desigualdad Salarial')
    axs[0, 1].set_title('Evolución de Desigualdades')
    axs[0, 1].legend()

    # 3. Diversificación y especialización
    axs[0, 2].plot(model_data['step'], model_data['avg_diversification'], label='Diversificación')
    axs[0, 2].plot(model_data['step'], model_data['avg_specialization'], label='Especialización')
    axs[0, 2].set_title('Diversificación vs Especialización')
    axs[0, 2].legend()

    # 4. Relación entre margen, CT e innovación
    sns.scatterplot(
        data=agent_data,
        x='margin',
        y='tech',
        hue='innovation_rate',
        size='diversification',
        sizes=(20, 200),
        alpha=0.6,
        ax=axs[1, 0]
    )
    axs[1, 0].set_title('Relación Margen-CT-Innovación')

    # 5. Brechas de cualificación por sector
    sns.boxplot(
        data=agent_data,
        x='sector_type',
        y='qualification_gap',
        hue='trapped',
        ax=axs[1, 1]
    )
    axs[1, 1].set_title('Brechas de Cualificación por Sector')
    axs[1, 1].tick_params(axis='x', rotation=45)

    # 6. Diversidad productiva y empleo
    axs[1, 2].plot(model_data['step'], model_data['product_diversity'], label='Diversidad Productiva')
    axs[1, 2].plot(model_data['step'], model_data['unemployment_rate'], label='Tasa Desempleo')
    axs[1, 2].set_title('Diversidad Productiva y Empleo')
    axs[1, 2].legend()

    # 7. Correlaciones en regiones atrapadas
    trapped_data = agent_data[agent_data['trapped']]
    if not trapped_data.empty:
        sns.heatmap(
            trapped_data[['tech', 'margin', 'diversification', 'innovation_rate', 'qualification_gap']].corr(),
            annot=True,
            ax=axs[2, 0]
        )
        axs[2, 0].set_title('Correlaciones en Regiones Atrapadas')

    # 8. Evolución de la brecha de cualificación
    axs[2, 1].plot(model_data['step'], model_data['qualification_gap'], label='Brecha Cualificación')
    axs[2, 1].plot(model_data['step'], model_data['avg_tech'], label='CT Promedio')
    axs[2, 1].set_title('Brecha de Cualificación vs CT')
    axs[2, 1].legend()

    # 9. Productividad por tipo de sector
    sns.boxplot(
        data=agent_data,
        x='sector_type',
        y='productivity',
        hue='trapped',
        ax=axs[2, 2]
    )
    axs[2, 2].set_title('Productividad por Sector')
    axs[2, 2].tick_params(axis='x', rotation=45)

    plt.tight_layout()
    plt.show()

    # Análisis estadístico
    print("\n=== Estadísticas Descriptivas ===")
    print(agent_data.describe().round(3))

    print("\n=== Comparación por Sector ===")
    print(agent_data.groupby('sector_type').agg({
        'tech': ['mean', 'std'],
        'margin': ['mean', 'std'],
        'productivity': ['mean', 'std'],
        'innovation_rate': ['mean', 'std'],
        'qualification_gap': ['mean', 'std'],
        'specialization': ['mean', 'std'],
        'num_products': ['mean', 'std'],
        'trapped': 'mean'
    }).round(3))

    print("\n=== Comparación Regiones Atrapadas vs No Atrapadas ===")
    print(agent_data.groupby('trapped').agg({
        'tech': 'mean',
        'margin': 'mean',
        'diversification': 'mean',
        'specialization': 'mean',
        'innovation_rate': 'mean',
        'qualification_gap': 'mean',
        'wage_inequality': 'mean',
        'num_products': 'mean'
    }).round(3))

# Ejecución del modelo
model = EconomicModel(n_regions=20)
model.run(steps=30)

# Obtención y visualización de resultados
model_data, agent_data = model.get_results()
visualize_results(model_data, agent_data)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import defaultdict
from matplotlib.gridspec import GridSpec

# Configuración inicial
sns.set_style('darkgrid')
sns.set_palette("viridis")
plt.rcParams['figure.figsize'] = [16, 12]

# Implementación del coeficiente Gini
def gini_coefficient(x):
    """Calcula el coeficiente de Gini para un array de valores."""
    x = np.abs(x)
    x = np.sort(x)
    n = len(x)
    cumx = np.cumsum(x)
    return (n + 1 - 2 * np.sum(cumx) / cumx[-1]) / n

# Parámetros globales
INITIAL_TECH = 0.1
PROFIT_MARGIN_IMPACT = 0.6
TECH_DEVELOPMENT_COST = 0.12
INITIAL_WORKFORCE_SKILL = 0.1
EDUCATION_INVESTMENT_RATE = 0.04
INNOVATION_BASE_RATE = 0.05
MIN_INNOVATION_THRESHOLD = 0.1
KNOWLEDGE_SPILLOVER = 0.25
INNOVATION_ACCELERATION = 0.02
WORKER_POOL_SIZE = 100000
PRODUCTIVITY_BASE_VARIABILITY = 0.15  # Variabilidad base en productividad
LEARNING_RATE = 0.05  # Tasa de aprendizaje por experiencia
TECH_PRODUCTIVITY_IMPACT = 0.6  # Impacto de tecnología en productividad
WORKFORCE_PRODUCTIVITY_IMPACT = 0.7  # Impacto de fuerza laboral en productividad

# Sectores económicos con mayor detalle y características específicas
SECTORS = {
    1: "Agricultura Tradicional",
    2: "Agricultura Tecnificada",
    3: "Minería Básica",
    4: "Minería Tecnológica",
    5: "Manufactura Básica",
    6: "Manufactura Avanzada",
    7: "Servicios Básicos",
    8: "Servicios Financieros",
    9: "Servicios Tecnológicos",
    10: "Turismo Masivo",
    11: "Turismo Especializado",
    12: "Industria Creativa"
}

# Categorización de sectores por tipo y nivel tecnológico
SECTOR_TYPES = {
    'Primario_Bajo': [1, 3],
    'Primario_Alto': [2, 4],
    'Manufactura_Baja': [5],
    'Manufactura_Alta': [6],
    'Servicios_Bajos': [7],
    'Servicios_Intermedios': [8],
    'Servicios_Avanzados': [9],
    'Turismo_Masivo': [10],
    'Turismo_Especializado': [11],
    'Industria_Creativa': [12]
}

# Parámetros detallados por tipo de sector
SECTOR_PARAMS = {
    'Primario_Bajo': {
        'margin_range': (0.25, 0.45),
        'tech_invest': 0.05,
        'volatility': 0.35,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.7, 0.8),
        'training_investment': 0.05,
        'innovation_capacity': 0.1,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.7,
        'productivity': 5,
        'product_range': (3, 7)
    },
    'Primario_Alto': {
        'margin_range': (0.35, 0.55),
        'tech_invest': 0.25,
        'volatility': 0.25,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.75, 0.85),
        'training_investment': 0.15,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9)
    },
    'Manufactura_Baja': {
        'margin_range': (0.15, 0.3),
        'tech_invest': 0.2,
        'volatility': 0.2,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.85),
        'training_investment': 0.1,
        'innovation_capacity': 0.25,
        'knowledge_intensity': 0.35,
        'linkages': 0.6,
        'specialization_coeff': 0.5,
        'productivity': 8,
        'product_range': (6, 10)
    },
    'Manufactura_Alta': {
        'margin_range': (0.25, 0.4),
        'tech_invest': 0.4,
        'volatility': 0.15,
        'skill_requirements': (0.6, 0.8),
        'employment_rate': (0.8, 0.9),
        'training_investment': 0.2,
        'innovation_capacity': 0.5,
        'knowledge_intensity': 0.7,
        'linkages': 0.8,
        'specialization_coeff': 0.4,
        'productivity': 10,
        'product_range': (8, 12)
    },
    'Servicios_Bajos': {
        'margin_range': (0.2, 0.4),
        'tech_invest': 0.1,
        'volatility': 0.15,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.75, 0.9),
        'training_investment': 0.08,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.3,
        'linkages': 0.4,
        'specialization_coeff': 0.3,
        'productivity': 6,
        'product_range': (4, 8)
    },
    'Servicios_Intermedios': {
        'margin_range': (0.3, 0.5),
        'tech_invest': 0.25,
        'volatility': 0.1,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.8, 0.95),
        'training_investment': 0.15,
        'innovation_capacity': 0.35,
        'knowledge_intensity': 0.5,
        'linkages': 0.7,
        'specialization_coeff': 0.2,
        'productivity': 9,
        'product_range': (7, 11)
    },
    'Servicios_Avanzados': {
        'margin_range': (0.4, 0.65),
        'tech_invest': 0.45,
        'volatility': 0.1,
        'skill_requirements': (0.7, 0.9),
        'employment_rate': (0.85, 0.98),
        'training_investment': 0.25,
        'innovation_capacity': 0.7,
        'knowledge_intensity': 0.9,
        'linkages': 0.9,
        'specialization_coeff': 0.1,
        'productivity': 12,
        'product_range': (10, 14)
    },
    'Turismo_Masivo': {
        'margin_range': (0.2, 0.5),
        'tech_invest': 0.05,
        'volatility': 0.4,
        'skill_requirements': (0.2, 0.4),
        'employment_rate': (0.6, 0.85),
        'training_investment': 0.03,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.8,
        'productivity': 5,
        'product_range': (3, 7)
    },
    'Turismo_Especializado': {
        'margin_range': (0.3, 0.6),
        'tech_invest': 0.15,
        'volatility': 0.3,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.9),
        'training_investment': 0.1,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9)
    },
    'Industria_Creativa': {
        'margin_range': (0.35, 0.7),
        'tech_invest': 0.3,
        'volatility': 0.25,
        'skill_requirements': (0.6, 0.9),
        'employment_rate': (0.8, 0.95),
        'training_investment': 0.2,
        'innovation_capacity': 0.6,
        'knowledge_intensity': 0.8,
        'linkages': 0.7,
        'specialization_coeff': 0.3,
        'productivity': 9,
        'product_range': (7, 11)
    }
}

class Product:
    """Clase para modelar productos/servicios de una región."""
    def __init__(self, sector_type, product_id):
        params = SECTOR_PARAMS[sector_type]
        self.id = product_id
        self.name = f"Product_{sector_type}_{product_id}"
        self.revenue = random.uniform(*params['product_range'])
        self.cost = random.uniform(0.5, 0.8) * self.revenue
        self.production = random.uniform(3, 8)
        self.tech_intensity = random.uniform(0.1, params['knowledge_intensity'])
        self.skill_required = random.uniform(*params['skill_requirements'])

    def calculate_margin(self):
        return (self.revenue - self.cost) / self.revenue

class Worker:
    """Clase para modelar trabajadores individuales con sus habilidades."""
    def __init__(self, sector_type=None):
        if sector_type:
            params = SECTOR_PARAMS[sector_type]
            self.skill = random.uniform(
                max(0.1, params['skill_requirements'][0] - 0.2),
                min(1.0, params['skill_requirements'][1] + 0.1)
            )
            self.specialized_skill = random.uniform(0.5, 1.1)
        else:
            self.skill = random.uniform(0.1, 0.7)
            self.specialized_skill = 0.0

        self.employed = False
        self.region_id = None
        self.sector_type = sector_type

    def improve_skills(self, training_investment, tech_exposure):
        """Mejora las habilidades del trabajador basado en entrenamiento y tecnología."""
        skill_gain = (training_investment * 0.3) + (tech_exposure * 0.2)
        self.skill = np.clip(self.skill + random.uniform(0, skill_gain), 0.1, 1.0)

        if self.sector_type:
            specialized_gain = (training_investment * 0.3) + (tech_exposure * 0.1)
            self.specialized_skill = np.clip(
                self.specialized_skill + random.uniform(0, specialized_gain),
                0.1, 1.0
            )

class Workforce:
    """Clase para modelar la fuerza laboral con mayor detalle en cualificación."""
    def __init__(self, sector_type, region_id):
        params = SECTOR_PARAMS[sector_type]
        self.workers = []
        self.sector_type = sector_type
        self.region_id = region_id
        self.training_investment = params['training_investment']
        self.skill_requirements = random.uniform(*params['skill_requirements'])
        self.min_specialized_skill = 0.5
        self.update_metrics()

    def update_metrics(self):
        """Calcula métricas basadas en la fuerza laboral actual."""
        if self.workers:
            self.avg_skill = np.mean([w.skill for w in self.workers])
            self.avg_specialized_skill = np.mean([w.specialized_skill for w in self.workers])
            self.qualification_gap = max(0, self.skill_requirements - self.avg_skill)
            self.specialization_gap = max(0, self.min_specialized_skill - self.avg_specialized_skill)
            self.wage_inequality = gini_coefficient([w.skill for w in self.workers])
        else:
            self.avg_skill = 0
            self.avg_specialized_skill = 0
            self.qualification_gap = self.skill_requirements
            self.specialization_gap = self.min_specialized_skill
            self.wage_inequality = 0

    def hire_workers(self, num_workers, worker_pool):
        """Contrata trabajadores del pool de trabajadores disponibles."""
        hired = 0
        available_workers = [w for w in worker_pool if not w.employed]

        specialized_workers = [w for w in available_workers if w.sector_type == self.sector_type]
        for worker in specialized_workers[:min(num_workers, len(specialized_workers))]:
            worker.employed = True
            worker.region_id = self.region_id
            self.workers.append(worker)
            hired += 1

        remaining = num_workers - hired
        if remaining > 0:
            general_workers = [w for w in available_workers if w not in specialized_workers]
            for worker in general_workers[:min(remaining, len(general_workers))]:
                worker.employed = True
                worker.region_id = self.region_id
                worker.sector_type = self.sector_type
                self.workers.append(worker)
                hired += 1

        self.update_metrics()
        return hired

    def fire_workers(self, num_workers):
        """Despide trabajadores, comenzando por los menos calificados."""
        if not self.workers:
            return 0

        self.workers.sort(key=lambda x: x.skill + x.specialized_skill)

        fired = 0
        for _ in range(min(num_workers, len(self.workers))):
            worker = self.workers.pop(0)
            worker.employed = False
            worker.region_id = None
            fired += 1

        self.update_metrics()
        return fired

    def adjust_workforce(self, required_workers, worker_pool):
        """Ajusta la fuerza laboral a los trabajadores requeridos."""
        current = len(self.workers)
        if current < required_workers:
            self.hire_workers(required_workers - current, worker_pool)
        elif current > required_workers:
            self.fire_workers(current - required_workers)

    def evaluate_workers(self):
        """Evalúa y posiblemente despide trabajadores que no cumplen los requisitos."""
        to_fire = []
        for worker in self.workers:
            if (worker.skill < self.skill_requirements * 0.7 or
                (worker.specialized_skill < self.min_specialized_skill * 0.7)):
                to_fire.append(worker)

        for worker in to_fire:
            self.workers.remove(worker)
            worker.employed = False
            worker.region_id = None

        self.update_metrics()
        return len(to_fire)

    def train_workers(self, tech_exposure):
        """Entrena y mejora las habilidades de los trabajadores."""
        for worker in self.workers:
            worker.improve_skills(self.training_investment, tech_exposure)
        self.update_metrics()

class Region:
    """Clase que representa una región con su economía y fuerza laboral."""
    def __init__(self, region_id, worker_pool):
        self.id = region_id
        self.worker_pool = worker_pool
        self.sector_id = random.choice(list(SECTORS.keys()))
        self.sector_type = self.get_sector_type()
        self.sector_name = SECTORS[self.sector_id]
        self.params = SECTOR_PARAMS[self.sector_type]

        # Variables económicas
        self.tech_capability = INITIAL_TECH
        self.profit_margin = random.uniform(*self.params['margin_range'])
        self.productivity = self.params['productivity']
        self.specialization = self.params['specialization_coeff']
        self.diversification = 1 - self.specialization
        self.innovation_rate = 0.0
        self.trapped = False
        self.employment_rate = random.uniform(*self.params['employment_rate'])
        self.steps = 0

        # Productos/servicios
        self.products = [
            Product(self.sector_type, i) for i in range(random.randint(2, 5))
        ]
        self.total_production = sum(p.production for p in self.products)

        # Fuerza laboral
        self.workforce = Workforce(self.sector_type, self.id)
        self.required_workers = max(1, int(self.total_production / self.productivity))
        self.workforce.hire_workers(self.required_workers, self.worker_pool)

        # Historial
        self.specialization_history = [self.specialization]
        self.diversification_history = [self.diversification]
        self.qualification_gap_history = [self.workforce.qualification_gap]

    def get_sector_type(self):
        """Determina el tipo de sector."""
        for sector_type, ids in SECTOR_TYPES.items():
            if self.sector_id in ids:
                return sector_type
        return 'Primario_Bajo'

    def update(self):
        """Actualiza el estado de la región."""
        # Perturbaciones externas
        self.external_shocks()

        # Toma de decisiones estratégicas
        self.make_strategic_decision()

        # Ajustar productos/servicios
        self.adjust_products()

        # Innovación
        self.innovate()

        # Actualizar fuerza laboral
        self.update_workforce()

        # Actualizar métricas de desempeño
        self.update_performance()

        # Verificar trampa de innovación (umbrales más bajos)
        self.check_innovation_trap()

        # Registrar historial
        self.specialization_history.append(self.specialization)
        self.diversification_history.append(self.diversification)
        self.qualification_gap_history.append(self.workforce.qualification_gap)

        # Incrementar contador de pasos
        self.steps += 1

    def external_shocks(self):
        """Simula perturbaciones externas a la región."""
        # Shock general (economía, demanda)
        shock_factor = random.uniform(0.85, 1.15) ** (1 + self.params['volatility'])
        self.total_production *= shock_factor

        # Shock en márgenes (competencia, costos)
        margin_shock = random.normalvariate(0, 0.08) * self.params['volatility']
        self.profit_margin = np.clip(
             self.profit_margin + margin_shock,
             self.params['margin_range'][0] * 0.8,  # Permite márgenes más bajos en crisis
             self.params['margin_range'][1] * 1.1   # Permite márgenes algo más altos
    )

        # Shock en productividad (innovaciones, fallas)
        productivity_shock = random.normalvariate(0, 0.1) * (1 - self.tech_capability/2)
        self.productivity = np.clip(
             self.productivity * (1 + productivity_shock),
             self.params['productivity'] * 0.5,
             self.params['productivity'] * 2.0
    )

        # Eventos raros pero impactantes (crisis, boom tecnológico)
        if random.random() < 0.02:  # 2% de probabilidad por paso
           big_shock = random.uniform(-0.4, 0.6)  # Puede ser negativo o positivo
           self.productivity *= (1 + big_shock)

    def make_strategic_decision(self):
        """Toma decisiones sobre inversión en tecnología vs márgenes."""
        if random.random() < self.params['tech_invest'] * (1 - self.profit_margin):
            tech_investment = random.uniform(0.05, 0.15) * (1 + self.diversification)
            self.tech_capability += tech_investment
            self.profit_margin = max(
                self.params['margin_range'][0],
                self.profit_margin - random.uniform(0.03, 0.08)
            )
        else:
            margin_increase = random.uniform(0, 0.05) * self.specialization
            self.profit_margin += margin_increase
            self.tech_capability = max(
                INITIAL_TECH,
                self.tech_capability - random.uniform(0, 0.03)
            )

    def adjust_products(self):
        """Ajusta la cartera de productos con dinámica mejorada de diversidad."""
        # 1. Eliminar productos no rentables con cierta probabilidad
        to_remove = []
        for product in self.products:
            if (product.calculate_margin() < self.profit_margin * 0.7 and
                random.random() < 0.4):  # 40% de chance de eliminar producto no rentable
                to_remove.append(product)

        # Eliminar productos seleccionados
        for product in to_remove:
            self.products.remove(product)
            self.total_production -= product.production

        # 2. Innovación de productos --- tres tipos posibles
        if random.random() < self.innovation_rate:
            innovation_type = random.choices(
                ['incremental', 'sector_relacionado', 'radical'],
                weights=[0.6, 0.3, 0.1]
            )[0]

            if innovation_type == 'incremental':
                # Producto similar a los existentes
                new_product = Product(self.sector_type, len(self.products) + 1)
            elif innovation_type == 'sector_relacionado':
                # Producto de sector relacionado
                related_sectors = [
                    k for k, v in SECTOR_PARAMS.items()
                    if abs(v['knowledge_intensity'] - self.params['knowledge_intensity']) < 0.2
                    and k != self.sector_type
                ]
                if related_sectors:
                    new_sector = random.choice(related_sectors)
                    new_product = Product(new_sector, len(self.products) + 1)
                else:
                    new_product = Product(self.sector_type, len(self.products) + 1)
            else:  # radical
                # Producto completamente nuevo (puede ser de cualquier sector)
                random_sector = random.choice(list(SECTOR_PARAMS.keys()))
                new_product = Product(random_sector, len(self.products) + 1)

            self.products.append(new_product)
            self.total_production += new_product.production

        # 3. Ocasionalmente agregar producto aleatorio (diversificación espontánea)
        if random.random() < 0.05:  # 5% de chance por paso
            random_sector = random.choice(list(SECTOR_PARAMS.keys()))
            new_product = Product(random_sector, len(self.products) + 1)
            self.products.append(new_product)
            self.total_production += new_product.production

        # Actualizar trabajadores requeridos
        self.required_workers = max(1, int(self.total_production / self.productivity))

    def innovate(self):
        """Realiza actividades de innovación."""
        if self.tech_capability > MIN_INNOVATION_THRESHOLD:
            tech_factor = np.log1p(self.tech_capability)
            skill_factor = min(1.0, self.workforce.avg_skill)**2
            diversification_factor = 4 * self.diversification * (1 - self.diversification)
            inequality_factor = 1 - self.workforce.wage_inequality
            size_factor = min(1.0, len(self.workforce.workers) / 50)

            self.innovation_rate = (
                INNOVATION_BASE_RATE +
                tech_factor * skill_factor * diversification_factor *
                inequality_factor * size_factor *
                self.params['innovation_capacity'] *
                (1 + self.steps * INNOVATION_ACCELERATION)
            )

            if hasattr(self, 'other_regions'):
                avg_neighbor_tech = np.mean([r.tech_capability for r in self.other_regions])
                if avg_neighbor_tech > self.tech_capability:
                    tech_transfer = KNOWLEDGE_SPILLOVER * (avg_neighbor_tech - self.tech_capability)
                    self.tech_capability = min(1.0, self.tech_capability + tech_transfer)

            if random.random() < self.innovation_rate:
                tech_gain = random.uniform(0.01, 0.1) * (1 + self.diversification)
                self.tech_capability = min(1.0, self.tech_capability + tech_gain)

                if random.random() < 0.3:
                    new_product = Product(self.sector_type, len(self.products) + 1)
                    self.products.append(new_product)
                    self.total_production += new_product.production

                skill_increase = random.uniform(0.01, 0.05)
                self.workforce.skill_requirements = np.clip(
                    self.workforce.skill_requirements + skill_increase,
                    *self.params['skill_requirements']
                )
        else:
            self.innovation_rate = 0

    def update_workforce(self):
        """Actualiza la fuerza laboral de la región."""
        self.workforce.adjust_workforce(self.required_workers, self.worker_pool)
        self.workforce.evaluate_workers()
        self.workforce.train_workers(self.tech_capability)
        self.compete_for_workers()
        self.employment_rate = len(self.workforce.workers) / self.required_workers if self.required_workers > 0 else 0

    def compete_for_workers(self):
        """Competencia por trabajadores calificados con otras regiones."""
        if not hasattr(self, 'other_regions'):
            return

        if self.workforce.qualification_gap > 0.1:
            for region in random.sample(self.other_regions, min(3, len(self.other_regions))):
                if region.id == self.id:
                    continue

                qualified_workers = [
                    w for w in region.workforce.workers
                    if w.skill > self.workforce.avg_skill and
                    w.specialized_skill > self.workforce.avg_specialized_skill
                ]

                if qualified_workers and len(self.workforce.workers) < self.required_workers:
                    worker = random.choice(qualified_workers)
                    region.workforce.workers.remove(worker)
                    region.workforce.update_metrics()
                    self.workforce.workers.append(worker)
                    worker.region_id = self.id
                    self.workforce.update_metrics()

    def update_performance(self):
        """Actualiza métricas de desempeño económico."""
        workforce_impact = 0.4 * self.workforce.avg_skill
        tech_impact = 0.5 * self.tech_capability
        diversification_impact = 0.3 * self.diversification

        self.productivity = np.clip(
            (workforce_impact + tech_impact + diversification_impact) *
            (1 - self.profit_margin * PROFIT_MARGIN_IMPACT),
            self.params['productivity'] * 0.5,
            self.params['productivity'] * 1.5
        )

        margin_factor = self.profit_margin / self.params['margin_range'][1]
        if margin_factor > 0.8:
            self.specialization = min(
                0.95,
                self.specialization + random.uniform(0, 0.05) * margin_factor
            )
        else:
            if random.random() < 0.3:
                self.specialization = max(
                    0.05,
                    self.specialization - random.uniform(0, 0.03) * (1 - margin_factor)
                )

        self.diversification = 1 - self.specialization

    def check_innovation_trap(self):
        """Determina si la región cae en trampa de innovación con umbrales más bajos."""
        conditions = (
            self.tech_capability < 0.25,
            self.profit_margin > 0.45,
            self.innovation_rate < 0.03,
            self.workforce.qualification_gap > 0.15,
            self.diversification < 0.4,
            len(self.products) <= 3
        )

        self.trapped = sum(conditions) >= 4

        if self.trapped:
            self.profit_margin = min(0.9, self.profit_margin * 1.02)
            self.tech_capability = max(0.1, self.tech_capability * 0.98)
            self.diversification = max(0.05, self.diversification * 0.95)
            self.specialization = 1 - self.diversification

    def update_performance(self):
        """Actualiza métricas de desempeño económico con mayor dinamismo."""
        # Factores que afectan la productividad
        workforce_impact = 0.5 * self.workforce.avg_skill * (1 + self.workforce.avg_specialized_skill/2)
        tech_impact = 0.6 * self.tech_capability

        # Efecto de la diversificación (curva en U invertida)
        diversification_impact = 2.5 * self.diversification * (1 - self.diversification)

        # Efecto de aprendizaje por experiencia
        learning_effect = np.log1p(self.steps) * 0.1

        # Variabilidad aleatoria (innovación, shocks)
        random_effect = random.uniform(-0.1, 0.1) * (1 - self.tech_capability/2)

        # Productividad base del sector
        sector_base = self.params['productivity']

        # Cálculo final de productividad con límites
        min_productivity = sector_base * 0.6
        max_productivity = sector_base * 1.8

        self.productivity = np.clip(
            sector_base * (1 + workforce_impact + tech_impact + diversification_impact +
                          learning_effect + random_effect),
            min_productivity,
            max_productivity
        )

        # Actualizar especialización/diversificación basado en rendimiento
        margin_factor = self.profit_margin / self.params['margin_range'][1]

        if margin_factor > 0.8:
            # Buen desempeño -> puede especializarse más
            self.specialization = min(
                0.95,
                self.specialization + random.uniform(0, 0.05) * margin_factor
            )
        else:
            # Mal desempeño -> necesita diversificarse
            if random.random() < 0.4:  # 40% de probabilidad de ajuste
                self.specialization = max(
                    0.05,
                    self.specialization - random.uniform(0, 0.08) * (1 - margin_factor)
                )

        self.diversification = 1 - self.specialization

        # Efecto de la trampa de innovación en productividad
        if self.trapped:
            self.productivity = max(
                min_productivity,
                self.productivity * 0.98  # Pérdida gradual de productividad
            )

class EconomicModel:
    """Modelo económico completo con todas las regiones."""
    def __init__(self, n_regions=20):
        self.worker_pool = [Worker() for _ in range(WORKER_POOL_SIZE)]
        self.regions = [Region(i, self.worker_pool) for i in range(n_regions)]

        for region in self.regions:
            region.other_regions = [r for r in self.regions if r.id != region.id]

        self.steps = 0
        self.history = []  # Lista para almacenar el historial

    def step(self):
        """Avanza la simulación un paso."""
        for region in random.sample(self.regions, len(self.regions)):
            region.update()

        self.record_state()
        self.steps += 1

    def run(self, steps=30):
        """Ejecuta la simulación para varios pasos."""
        for _ in range(steps):
            self.step()

    def calculate_sector_diversity(self):
        """Calcula la diversidad sectorial usando el índice de Shannon."""
        sector_counts = pd.Series([r.sector_type for r in self.regions]).value_counts()
        proportions = sector_counts / sector_counts.sum()
        # Evitar log(0) reemplazando ceros con un valor pequeño
        proportions = proportions.replace(0, 1e-10)
        return -np.sum(proportions * np.log(proportions))

    def calculate_tech_diversity(self):
        """Calcula la diversidad tecnológica usando el coeficiente de variación."""
        tech_levels = [r.tech_capability for r in self.regions]
        return np.std(tech_levels) / np.mean(tech_levels) if np.mean(tech_levels) != 0 else 0

    def record_state(self):
        """Registra el estado actual del modelo con todas las métricas."""
        current_state = {
            "step": self.steps,
            "avg_tech": np.mean([r.tech_capability for r in self.regions]),
            "avg_margin": np.mean([r.profit_margin for r in self.regions]),
            "avg_productivity": np.mean([r.productivity for r in self.regions]),
            "avg_innovation": np.mean([r.innovation_rate for r in self.regions]),
            "avg_diversification": np.mean([r.diversification for r in self.regions]),
            "avg_specialization": np.mean([r.specialization for r in self.regions]),
            "sector_diversity": self.calculate_sector_diversity(),
            "tech_diversity": self.calculate_tech_diversity(),
            "pct_trapped": np.mean([1 if r.trapped else 0 for r in self.regions])
        }

        # Calcular diversidad de productos
        all_products = []
        for r in self.regions:
            all_products.extend([p.name for p in r.products])
        current_state["unique_products"] = len(set(all_products)) if all_products else 0
        current_state["product_diversity"] = current_state["unique_products"] / len(self.regions) if len(self.regions) > 0 else 0

        # Agregar métricas por sector
        for sector_type in SECTOR_PARAMS.keys():
            sector_regions = [r for r in self.regions if r.sector_type == sector_type]
            if sector_regions:
                current_state[f"tech_{sector_type}"] = np.mean([r.tech_capability for r in sector_regions])
                current_state[f"innov_{sector_type}"] = np.mean([r.innovation_rate for r in sector_regions])

        self.history.append(current_state)

    def get_results(self):
        """Obtiene los resultados asegurando la estructura correcta del DataFrame."""
        # Crear DataFrame del modelo
        model_data = pd.DataFrame(self.history)

        # Datos de los agentes (regiones)
        agent_data = []
        for region in self.regions:
            agent_data.append({
                "id": region.id,
                "sector_type": region.sector_type,
                "sector_name": region.sector_name,
                "tech": region.tech_capability,
                "margin": region.profit_margin,
                "productivity": region.productivity,
                "innovation_rate": region.innovation_rate,
                "diversification": region.diversification,
                "specialization": region.specialization,
                "num_products": len(region.products),
                "qualification_gap": region.workforce.qualification_gap,
                "trapped": region.trapped,
                "employment_rate": region.employment_rate
            })

        return model_data, pd.DataFrame(agent_data)


def visualize_results_individual(model_data, agent_data):
    """Función de visualización que genera gráficas individuales."""

    # 1. Evolución de métricas principales
    plt.figure(figsize=(18, 12))
    main_metrics = ['avg_tech', 'avg_innovation', 'product_diversity']
    for metric in main_metrics:
        if metric in model_data.columns:
            plt.plot(model_data['step'], model_data[metric], label=metric)
    plt.title('Evolución de Métricas Principales')
    plt.legend()
    plt.grid(True)
    plt.show()

    # 2. Diversidad sectorial y tecnológica
    plt.figure(figsize=(18, 12))
    diversity_metrics = ['sector_diversity', 'tech_diversity']
    for metric in diversity_metrics:
        if metric in model_data.columns:
            plt.plot(model_data['step'], model_data[metric], label=metric)
    plt.title('Evolución de Diversidades')
    plt.legend()
    plt.grid(True)
    plt.show()

    # 3. Especialización vs Diversificación
    if all(col in model_data.columns for col in ['avg_specialization', 'avg_diversification']):
        plt.figure(figsize=(18, 12))
        plt.plot(model_data['step'], model_data['avg_specialization'], label='Especialización')
        plt.plot(model_data['step'], model_data['avg_diversification'], label='Diversificación')
        plt.title('Especialización vs Diversificación')
        plt.legend()
        plt.grid(True)
        plt.show()

    # 4. Productos por sector
    if all(col in agent_data.columns for col in ['sector_type', 'num_products']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='num_products')
        plt.title('Productos por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 5. Innovación por sector
    if all(col in agent_data.columns for col in ['sector_type', 'innovation_rate']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='innovation_rate')
        plt.title('Innovación por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 6. Tecnología por sector
    if all(col in agent_data.columns for col in ['sector_type', 'tech']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='tech')
        plt.title('Tecnología por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 7. Correlaciones entre variables del modelo
    numeric_cols = [col for col in model_data.columns if col != 'step' and pd.api.types.is_numeric_dtype(model_data[col])]
    if len(numeric_cols) > 1:
        plt.figure(figsize=(18, 12))
        sns.heatmap(model_data[numeric_cols].corr(), annot=True, cmap='coolwarm')
        plt.title('Correlaciones entre Variables del Modelo')
        plt.show()

    # 8. Correlaciones entre variables de agentes
    agent_numeric = agent_data.select_dtypes(include=np.number).columns.tolist()
    if len(agent_numeric) > 1:
        plt.figure(figsize=(12, 6))
        sns.heatmap(agent_data[agent_numeric].corr(), annot=True, cmap='viridis')
        plt.title('Correlaciones entre Variables de Regiones')
        plt.show()

    # 9. Regiones atrapadas vs no atrapadas
    if 'trapped' in agent_data.columns:
        trapped_vars = ['tech', 'innovation_rate', 'diversification', 'num_products']
        trapped_vars = [var for var in trapped_vars if var in agent_data.columns]
        if trapped_vars:
            plt.figure(figsize=(18, 12))
            trapped_stats = agent_data.groupby('trapped')[trapped_vars].mean().T
            trapped_stats.plot(kind='bar')
            plt.title('Comparación Regiones Atrapadas vs No Atrapadas')
            plt.grid(True)
            plt.show()

    # 10. Evolución de productividad
    plt.figure(figsize=(18, 12))
    plt.plot(model_data['step'], model_data['avg_productivity'], label='Promedio')

    # Calcular y mostrar banda de variación entre percentiles
    if 'productivity' in agent_data.columns:
        plt.fill_between(
            model_data['step'],
            model_data['avg_productivity'] - model_data['avg_productivity'].std(),
            model_data['avg_productivity'] + model_data['avg_productivity'].std(),
            alpha=0.2,
            label='Variación'
        )

    plt.title('Evolución de Productividad Promedio')
    plt.xlabel('Pasos')
    plt.ylabel('Productividad')
    plt.legend()
    plt.grid(True)
    plt.show()

    # 11. Evolución de margen de ganancia
    if 'avg_margin' in model_data.columns:
        plt.figure(figsize=(18, 12))
        plt.plot(model_data['step'], model_data['avg_margin'])
        plt.title('Evolución de Margen de Ganancia Promedio')
        plt.grid(True)
        plt.show()

    # 12. Porcentaje de regiones atrapadas
    if 'pct_trapped' in model_data.columns:
        plt.figure(figsize=(18, 12))
        plt.plot(model_data['step'], model_data['pct_trapped'])
        plt.title('Porcentaje de Regiones Atrapadas')
        plt.grid(True)
        plt.show()

    # 13. Factores que afectan la productividad
    plt.figure(figsize=(18, 12))
    factors = {
        'Tecnología': 'avg_tech',
        'Innovación': 'avg_innovation'
    }

    # Normalizar factores para comparación
    for name, col in factors.items():
        if col in model_data.columns:
            plt.plot(model_data['step'],
                    (model_data[col] - model_data[col].min()) /
                    (model_data[col].max() - model_data[col].min()),
                    label=name)

    plt.title('Factores que Afectan la Productividad (Normalizados)')
    plt.xlabel('Pasos')
    plt.ylabel('Influencia Normalizada')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Análisis estadístico detallado
    print("\n=== Estadísticas del Modelo ===")
    print(model_data.describe().round(3))

    print("\n=== Estadísticas por Sector ===")
    if 'sector_type' in agent_data.columns:
        sector_stats = agent_data.groupby('sector_type').agg({
            'tech': ['mean', 'std'],
            'innovation_rate': ['mean', 'std'],
            'num_products': ['mean', 'std'],
            'diversification': ['mean', 'std'],
            'productivity': ['mean', 'std']
        })
        print(sector_stats.round(3))

    print("\n=== Comparación Regiones Atrapadas ===")
    if 'trapped' in agent_data.columns:
        trapped_comparison = agent_data.groupby('trapped').agg({
            'tech': 'mean',
            'innovation_rate': 'mean',
            'diversification': 'mean',
            'num_products': 'mean',
            'productivity': 'mean'
        })
        print(trapped_comparison.round(3))

# Ejecución del modelo con visualización individual
model = EconomicModel(n_regions=32)
model.run(steps=40)
model_data, agent_data = model.get_results()

# Visualización de resultados individuales
visualize_results_individual(model_data, agent_data)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import defaultdict
from matplotlib.gridspec import GridSpec

# Configuración inicial
sns.set_style('darkgrid')
sns.set_palette("viridis")
plt.rcParams['figure.figsize'] = [20, 13]

# Implementación del coeficiente Gini
def gini_coefficient(x):
    """Calcula el coeficiente de Gini para un array de valores."""
    x = np.abs(x)
    x = np.sort(x)
    n = len(x)
    cumx = np.cumsum(x)
    return (n + 1 - 2 * np.sum(cumx) / cumx[-1]) / n

# Parámetros globales
INITIAL_TECH = 0.09
PROFIT_MARGIN_IMPACT = 0.7
TECH_DEVELOPMENT_COST = 0.12
INITIAL_WORKFORCE_SKILL = 0.1
EDUCATION_INVESTMENT_RATE = 0.02
INNOVATION_BASE_RATE = 0.05
MIN_INNOVATION_THRESHOLD = 0.05
KNOWLEDGE_SPILLOVER = 0.3
INNOVATION_ACCELERATION = 0.02
WORKER_POOL_SIZE = 100000
PRODUCTIVITY_BASE_VARIABILITY = 0.15
LEARNING_RATE = 0.08
TECH_PRODUCTIVITY_IMPACT = 0.6
WORKFORCE_PRODUCTIVITY_IMPACT = 0.7
SECTOR_CHANGE_BASE_RATE = 0.03
KNOWLEDGE_INTENSITY_THRESHOLD = 0.3
SECTOR_RELATEDNESS_THRESHOLD = 0.2
EMPLOYMENT_BASE_VOLATILITY = 0.06
SKILL_MISMATCH_PENALTY = 0.2
TECH_EMPLOYMENT_IMPACT = 0.5
ECONOMIC_CYCLE_LENGTH = 20

# Sectores económicos, detalle y características específicas
SECTORS = {
    1: "Agricultura Tradicional",
    2: "Agricultura Tecnificada",
    3: "Minería Básica",
    4: "Minería Tecnológica",
    5: "Manufactura Básica",
    6: "Manufactura Avanzada",
    7: "Servicios Básicos",
    8: "Servicios Financieros",
    9: "Servicios Tecnológicos",
    10: "Turismo Masivo",
    11: "Turismo Especializado",
    12: "Industria Creativa"
}

# Categorización de sectores por tipo y nivel tecnológico
SECTOR_TYPES = {
    'Primario_Bajo': [1, 3],
    'Primario_Alto': [2, 4],
    'Manufactura_Baja': [5],
    'Manufactura_Alta': [6],
    'Servicios_Bajos': [7],
    'Servicios_Intermedios': [8],
    'Servicios_Avanzados': [9],
    'Turismo_Masivo': [10],
    'Turismo_Especializado': [11],
    'Industria_Creativa': [12]
}

# Parámetros detallados por tipo de sector
SECTOR_PARAMS = {
    'Primario_Bajo': {
        'margin_range': (0.25, 0.45),
        'tech_invest': 0.05,
        'volatility': 0.35,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.7, 0.8),
        'training_investment': 0.05,
        'innovation_capacity': 0.1,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.7,
        'productivity': 5,
        'product_range': (3, 7),
        'max_employment': 1
    },
    'Primario_Alto': {
        'margin_range': (0.35, 0.55),
        'tech_invest': 0.25,
        'volatility': 0.25,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.75, 0.85),
        'training_investment': 0.15,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9),
        'max_employment': 1
    },
    'Manufactura_Baja': {
        'margin_range': (0.15, 0.3),
        'tech_invest': 0.2,
        'volatility': 0.2,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.85),
        'training_investment': 0.1,
        'innovation_capacity': 0.25,
        'knowledge_intensity': 0.35,
        'linkages': 0.6,
        'specialization_coeff': 0.5,
        'productivity': 8,
        'product_range': (6, 10),
        'max_employment': 1
    },
    'Manufactura_Alta': {
        'margin_range': (0.25, 0.4),
        'tech_invest': 0.4,
        'volatility': 0.15,
        'skill_requirements': (0.6, 0.8),
        'employment_rate': (0.8, 0.9),
        'training_investment': 0.2,
        'innovation_capacity': 0.5,
        'knowledge_intensity': 0.7,
        'linkages': 0.8,
        'specialization_coeff': 0.4,
        'productivity': 10,
        'product_range': (8, 12),
        'max_employment': 1
    },
    'Servicios_Bajos': {
        'margin_range': (0.2, 0.4),
        'tech_invest': 0.1,
        'volatility': 0.15,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.75, 0.9),
        'training_investment': 0.08,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.3,
        'linkages': 0.4,
        'specialization_coeff': 0.3,
        'productivity': 6,
        'product_range': (4, 8),
        'max_employment': 1
    },
    'Servicios_Intermedios': {
        'margin_range': (0.3, 0.5),
        'tech_invest': 0.25,
        'volatility': 0.1,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.8, 0.95),
        'training_investment': 0.15,
        'innovation_capacity': 0.35,
        'knowledge_intensity': 0.5,
        'linkages': 0.7,
        'specialization_coeff': 0.2,
        'productivity': 9,
        'product_range': (7, 11),
        'max_employment': 1
    },
    'Servicios_Avanzados': {
        'margin_range': (0.4, 0.65),
        'tech_invest': 0.45,
        'volatility': 0.1,
        'skill_requirements': (0.7, 0.9),
        'employment_rate': (0.85, 0.8),
        'training_investment': 0.25,
        'innovation_capacity': 0.7,
        'knowledge_intensity': 0.9,
        'linkages': 0.9,
        'specialization_coeff': 0.1,
        'productivity': 12,
        'product_range': (10, 14),
        'max_employment': 1
    },
    'Turismo_Masivo': {
        'margin_range': (0.2, 0.5),
        'tech_invest': 0.05,
        'volatility': 0.4,
        'skill_requirements': (0.2, 0.4),
        'employment_rate': (0.6, 0.9),
        'training_investment': 0.03,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.8,
        'productivity': 5,
        'product_range': (3, 7),
        'max_employment': 1
    },
    'Turismo_Especializado': {
        'margin_range': (0.3, 0.6),
        'tech_invest': 0.15,
        'volatility': 0.3,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.9),
        'training_investment': 0.1,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9),
        'max_employment': 1
    },
    'Industria_Creativa': {
        'margin_range': (0.35, 0.7),
        'tech_invest': 0.3,
        'volatility': 0.25,
        'skill_requirements': (0.6, 0.9),
        'employment_rate': (0.8, 0.95),
        'training_investment': 0.2,
        'innovation_capacity': 0.6,
        'knowledge_intensity': 0.8,
        'linkages': 0.7,
        'specialization_coeff': 0.3,
        'productivity': 9,
        'product_range': (7, 11),
        'max_employment': 1
    }
}

class Product:
    """Clase para modelar productos/servicios de una región."""
    def __init__(self, sector_type, product_id):
        params = SECTOR_PARAMS[sector_type]
        self.id = product_id
        self.name = f"Product_{sector_type}_{product_id}"
        self.revenue = random.uniform(*params['product_range'])
        self.cost = random.uniform(0.4, 0.7) * self.revenue
        self.production = random.uniform(3, 16)
        self.tech_intensity = random.uniform(0.1, params['knowledge_intensity'])
        self.skill_required = random.uniform(*params['skill_requirements'])

    def calculate_margin(self):
        return (self.revenue - self.cost) / self.revenue

class Worker:
    """Clase para modelar trabajadores individuales con sus habilidades."""
    def __init__(self, sector_type=None):
        if sector_type:
            params = SECTOR_PARAMS[sector_type]
            self.skill = random.uniform(
                max(0.1, params['skill_requirements'][0] - 0.2),
                min(1.0, params['skill_requirements'][1] + 0.1)
            )
            self.specialized_skill = random.uniform(0.5, 1.1)
        else:
            self.skill = random.uniform(0.1, 0.99)
            self.specialized_skill = 0.0

        self.employed = False
        self.region_id = None
        self.sector_type = sector_type

    def improve_skills(self, training_investment, tech_exposure):
        """Mejora las habilidades del trabajador basado en entrenamiento y tecnología."""
        skill_gain = (training_investment * 0.2) + (tech_exposure * 0.3)
        self.skill = np.clip(self.skill + random.uniform(0, skill_gain), 0.1, 1.0)

        if self.sector_type:
            specialized_gain = (training_investment * 0.2) + (tech_exposure * 0.3)
            self.specialized_skill = np.clip(
                self.specialized_skill + random.uniform(0, specialized_gain),
                0.1, 1.0
            )

class Workforce:
    """Clase para modelar la fuerza laboral con mayor detalle en cualificación."""
    def __init__(self, sector_type, region_id):
        params = SECTOR_PARAMS[sector_type]
        self.workers = []
        self.sector_type = sector_type
        self.region_id = region_id
        self.training_investment = params['training_investment']
        self.skill_requirements = random.uniform(*params['skill_requirements'])
        self.min_specialized_skill = 0.3
        self.update_metrics()

    def update_metrics(self):
        """Calcula métricas basadas en la fuerza laboral actual."""
        if self.workers:
            self.avg_skill = np.mean([w.skill for w in self.workers])
            self.avg_specialized_skill = np.mean([w.specialized_skill for w in self.workers])
            self.qualification_gap = max(0, self.skill_requirements - self.avg_skill)
            self.specialization_gap = max(0, self.min_specialized_skill - self.avg_specialized_skill)
            self.wage_inequality = gini_coefficient([w.skill for w in self.workers])
        else:
            self.avg_skill = 0
            self.avg_specialized_skill = 0
            self.qualification_gap = self.skill_requirements
            self.specialization_gap = self.min_specialized_skill
            self.wage_inequality = 0

    def hire_workers(self, num_workers, worker_pool):
        """Contrata trabajadores del pool de trabajadores disponibles."""
        hired = 0
        available_workers = [w for w in worker_pool if not w.employed]

        specialized_workers = [w for w in available_workers if w.sector_type == self.sector_type]
        for worker in specialized_workers[:min(num_workers, len(specialized_workers))]:
            worker.employed = True
            worker.region_id = self.region_id
            self.workers.append(worker)
            hired += 1

        remaining = num_workers - hired
        if remaining > 0:
            general_workers = [w for w in available_workers if w not in specialized_workers]
            for worker in general_workers[:min(remaining, len(general_workers))]:
                worker.employed = True
                worker.region_id = self.region_id
                worker.sector_type = self.sector_type
                self.workers.append(worker)
                hired += 1

        self.update_metrics()
        return hired

    def fire_workers(self, num_workers):
        """Despide trabajadores, comenzando por los menos calificados."""
        if not self.workers:
            return 0

        self.workers.sort(key=lambda x: x.skill + x.specialized_skill)

        fired = 0
        for _ in range(min(num_workers, len(self.workers))):
            worker = self.workers.pop(0)
            worker.employed = False
            worker.region_id = None
            fired += 1

        self.update_metrics()
        return fired

    def adjust_workforce(self, required_workers, worker_pool):
        """Ajusta la fuerza laboral a los trabajadores requeridos."""
        current = len(self.workers)
        if current < required_workers:
            self.hire_workers(required_workers - current, worker_pool)
        elif current > required_workers:
            self.fire_workers(current - required_workers)

    def evaluate_workers(self):
        """Evalúa y posiblemente despide trabajadores que no cumplen los requisitos."""
        to_fire = []
        for worker in self.workers:
            if (worker.skill < self.skill_requirements * 0.7 or
                (worker.specialized_skill < self.min_specialized_skill * 0.7)):
                to_fire.append(worker)

        for worker in to_fire:
            self.workers.remove(worker)
            worker.employed = False
            worker.region_id = None

        self.update_metrics()
        return len(to_fire)

    def train_workers(self, tech_exposure):
        """Entrena y mejora las habilidades de los trabajadores."""
        for worker in self.workers:
            worker.improve_skills(self.training_investment, tech_exposure)
        self.update_metrics()

class Region:
    """Clase que representa una región con su economía y fuerza laboral."""
    def __init__(self, region_id, worker_pool):
        self.id = region_id
        self.worker_pool = worker_pool
        self.sector_id = random.choice(list(SECTORS.keys()))
        self.sector_type = self.get_sector_type()
        self.sector_name = SECTORS[self.sector_id]
        self.params = SECTOR_PARAMS[self.sector_type]

        # Variables económicas
        self.tech_capability = INITIAL_TECH
        self.profit_margin = random.uniform(*self.params['margin_range'])
        self.productivity = self.params['productivity']
        self.specialization = self.params['specialization_coeff']
        self.diversification = 1 - self.specialization
        self.innovation_rate = 0.0
        self.trapped = False
        self.employment_rate = random.uniform(*self.params['employment_rate'])
        self.steps = 0

        # Productos/servicios
        self.products = [
            Product(self.sector_type, i) for i in range(random.randint(2, 5))
        ]
        self.total_production = sum(p.production for p in self.products)

        # Fuerza laboral
        self.workforce = Workforce(self.sector_type, self.id)
        self.required_workers = max(1, int(self.total_production / self.productivity))
        self.workforce.hire_workers(self.required_workers, self.worker_pool)

        # Historial
        self.specialization_history = [self.specialization]
        self.diversification_history = [self.diversification]
        self.qualification_gap_history = [self.workforce.qualification_gap]

    def get_sector_type(self):
        """Determina el tipo de sector."""
        for sector_type, ids in SECTOR_TYPES.items():
            if self.sector_id in ids:
                return sector_type
        return 'Primario_Bajo'

    def consider_sector_change(self):
        """Evalúa si la región debe cambiar de sector económico."""
        if random.random() < SECTOR_CHANGE_BASE_RATE:
            # Factores que influyen en el cambio
            tech_push = max(0, self.tech_capability - self.params['knowledge_intensity'])
            margin_pull = max(0, self.params['margin_range'][1] - self.profit_margin)
            innovation_push = self.innovation_rate * 2

            change_probability = SECTOR_CHANGE_BASE_RATE + 0.3 * (tech_push + margin_pull + innovation_push)

            if random.random() < change_probability:
                # Buscar sectores relacionados pero más avanzados
                possible_sectors = [
                    k for k, v in SECTOR_PARAMS.items()
                    if v['knowledge_intensity'] > self.params['knowledge_intensity']
                    and abs(v['margin_range'][0] - self.params['margin_range'][0]) < SECTOR_RELATEDNESS_THRESHOLD
                ]

                if possible_sectors:
                    new_sector = random.choice(possible_sectors)
                    new_sector_id = random.choice(SECTOR_TYPES[new_sector])
                    self.sector_id = new_sector_id
                    self.sector_type = new_sector
                    self.sector_name = SECTORS[new_sector_id]
                    self.params = SECTOR_PARAMS[new_sector]

                    # Ajustar tecnología al nuevo sector
                    self.tech_capability = max(INITIAL_TECH, self.tech_capability * 0.8)

                    # Reemplazar algunos productos
                    if self.products:
                        num_to_replace = min(2, len(self.products))
                        for _ in range(num_to_replace):
                            self.products.pop(random.randint(0, len(self.products)-1))
                            self.products.append(Product(new_sector, len(self.products)+1))

    def update(self):
        """Actualiza el estado de la región."""
        # Perturbaciones externas
        self.external_shocks()

        # Toma de decisiones estratégicas
        self.make_strategic_decision()

        # Ajustar productos/servicios
        self.adjust_products()

        # Innovación
        self.innovate()

        # Actualizar fuerza laboral
        self.update_workforce()

        # Actualizar métricas de desempeño
        self.update_performance()

        # Verificar trampa de innovación
        self.check_innovation_trap()

        # Considerar cambio de sector
        self.consider_sector_change()

        # Registrar historial
        self.specialization_history.append(self.specialization)
        self.diversification_history.append(self.diversification)
        self.qualification_gap_history.append(self.workforce.qualification_gap)

        # Incrementar contador de pasos
        self.steps += 1
        self.innovation_rate += random.uniform(-0.02, 0.02)
        self.employment_rate = np.clip(self.employment_rate + random.uniform(-0.03, 0.03), 0.5, 1.0)

    def external_shocks(self):
        """Simula perturbaciones externas a la región."""
        # Shock general (economía, demanda)
        shock_factor = random.uniform(0.85, 1.15) ** (1 + self.params['volatility'])
        self.total_production *= shock_factor

        # Shock en márgenes (competencia, costos)
        margin_shock = random.normalvariate(0, 0.08) * self.params['volatility']
        self.profit_margin = np.clip(
             self.profit_margin + margin_shock,
             self.params['margin_range'][0] * 0.8,
             self.params['margin_range'][1] * 1.1
        )

        # Shock en productividad (innovaciones, fallas)
        productivity_shock = random.normalvariate(0, 0.1) * (1 - self.tech_capability/2)
        self.productivity = np.clip(
             self.productivity * (1 + productivity_shock),
             self.params['productivity'] * 0.5,
             self.params['productivity'] * 2.0
        )

        # Eventos raros pero impactantes (crisis, boom tecnológico)
        if random.random() < 0.02:
           big_shock = random.uniform(-0.4, 0.6)
           self.productivity *= (1 + big_shock)

    def make_strategic_decision(self):
        """Toma decisiones sobre inversión en tecnología vs márgenes."""
        if random.random() < self.params['tech_invest'] * (1 - self.profit_margin):
            tech_investment = random.uniform(0.05, 0.15) * (1 + self.diversification)
            self.tech_capability += tech_investment
            self.profit_margin = max(
                self.params['margin_range'][0],
                self.profit_margin - random.uniform(0.03, 0.08)
        )
        else:
            margin_increase = random.uniform(0, 0.05) * self.specialization
            self.profit_margin += margin_increase
            self.tech_capability = max(
                INITIAL_TECH,
                self.tech_capability - random.uniform(0, 0.03)
        )

    def adjust_products(self):
        """Ajusta la cartera de productos con dinámica mejorada de diversidad."""
        # 1. Eliminar productos no rentables con cierta probabilidad
        to_remove = []
        for product in self.products:
            if (product.calculate_margin() < self.profit_margin * 0.7 and
                random.random() < 0.3):
                to_remove.append(product)

        # Eliminar productos seleccionados
        for product in to_remove:
            self.products.remove(product)
            self.total_production -= product.production

        # 2. Innovación de productos --- tres tipos posibles
        if random.random() < self.innovation_rate:
            innovation_type = random.choices(
                ['incremental', 'sector_relacionado', 'radical'],
                weights=[0.6, 0.3, 0.1]
        )[0]

            if innovation_type == 'incremental':
                new_product = Product(self.sector_type, len(self.products) + 1)
            elif innovation_type == 'sector_relacionado':
                related_sectors = [
                    k for k, v in SECTOR_PARAMS.items()
                    if abs(v['knowledge_intensity'] - self.params['knowledge_intensity']) < 0.2
                    and k != self.sector_type
        ]
                if related_sectors:
                    new_sector = random.choice(related_sectors)
                    new_product = Product(new_sector, len(self.products) + 1)
                else:
                    new_product = Product(self.sector_type, len(self.products) + 1)
            else:
                random_sector = random.choice(list(SECTOR_PARAMS.keys()))
                new_product = Product(random_sector, len(self.products) + 1)

            self.products.append(new_product)
            self.total_production += new_product.production

        # 3. Ocasionalmente agregar producto aleatorio (diversificación espontánea)
        if random.random() < 0.03:
            random_sector = random.choice(list(SECTOR_PARAMS.keys()))
            new_product = Product(random_sector, len(self.products) + 1)
            self.products.append(new_product)
            self.total_production += new_product.production

        # Actualizar trabajadores requeridos
        self.required_workers = max(1, int(self.total_production / self.productivity))

    def innovate(self):
        """Tasas de innovación"""
        # Umbral más bajo para permitir innovación
        if self.tech_capability > MIN_INNOVATION_THRESHOLD:
           # Factores menos restrictivos
           tech_factor = 0.3 + self.tech_capability
           skill_factor = 0.1 + self.workforce.avg_skill
           diversification_factor = 0.3 + self.diversification

           self.innovation_rate = (
               INNOVATION_BASE_RATE +
               (tech_factor * skill_factor * self.params['innovation_capacity']) *
               (1 + np.log1p(self.steps * INNOVATION_ACCELERATION * 2.5))
        )
        if random.random() < 0.02:  # Probabilidad baja de evento radical
           self.innovation_rate += random.uniform(0.05, 0.15)

        # Transferencia tecnológica
        if hasattr(self, 'other_regions'):
            avg_neighbor_tech = np.mean([r.tech_capability for r in self.other_regions])
            if avg_neighbor_tech > self.tech_capability:
                tech_transfer = KNOWLEDGE_SPILLOVER * 1.5 * (avg_neighbor_tech - self.tech_capability)
                self.tech_capability = min(1.0, self.tech_capability + tech_transfer)
                self.innovation_rate = min(0.3, self.innovation_rate * 1.2)  # Bonus por transferencia

        # Evento de innovación
        if random.random() < self.innovation_rate:
            tech_gain = random.uniform(0.02, 0.15) * (1 + self.diversification)
            self.tech_capability = min(1.0, self.tech_capability + tech_gain)

            # Mayor probabilidad de nuevos productos
            if random.random() < 0.3:
                new_product = Product(self.sector_type, len(self.products) + 1)
                self.products.append(new_product)
                self.total_production += new_product.production
        else:
             self.innovation_rate = 0

    def update_workforce(self):
        """Actualización de fuerza laboral"""
        # Calcular demanda base de trabajadores
        base_demand = max(1, int(self.total_production / self.productivity))

        # Factores de ajuste
        tech_impact = TECH_EMPLOYMENT_IMPACT * (1 - self.tech_capability)
        skill_gap_impact = SKILL_MISMATCH_PENALTY * self.workforce.qualification_gap
        economic_cycle = self.economic_cycle_effect()

        # Calcular demanda ajustada
        adjusted_demand = base_demand * economic_cycle * (1 - tech_impact - skill_gap_impact)
        self.required_workers = max(1, int(adjusted_demand* random.uniform(0.9, 1.1)))

        # Ajustar fuerza laboral con inercia
        current_workers = len(self.workforce.workers)
        change = self.required_workers - current_workers
        max_change = max(1, int(current_workers * 0.25))

        if abs(change) > max_change:
           change = max_change if change > 0 else -max_change

        # Manejar contrataciones y despidos por separado
        hired = 0
        if change > 0:
           hired = self.workforce.hire_workers(change, self.worker_pool)
           if hired < change:  # Solo aplica si no se pudo contratar suficiente personal
               self.total_production *= (hired / change)
        elif change < 0:
            # En caso de despidos
            self.workforce.fire_workers(-change)

        # Entrenamiento y evaluación
        self.workforce.evaluate_workers()
        self.workforce.train_workers(self.tech_capability)
        self.compete_for_workers()

        # Calcular tasa de empleo
        if self.required_workers > 0:
           actual_workers = len(self.workforce.workers)
           self.employment_rate = actual_workers / self.required_workers

           # Añadir variabilidad realista
           employment_noise = random.uniform(1 - EMPLOYMENT_BASE_VOLATILITY,
                                         1 + EMPLOYMENT_BASE_VOLATILITY)
           self.employment_rate = np.clip(
                                         self.employment_rate * employment_noise,
                                         0.5,
                                         self.params['max_employment']
        )
        else:
            self.employment_rate = 0

    def economic_cycle_effect(self):
        """Efecto de ciclo económico en el empleo"""
        # Posición en el ciclo (0 a 1)
        cycle_pos = (self.steps % ECONOMIC_CYCLE_LENGTH) / ECONOMIC_CYCLE_LENGTH

        # Curva senoidal suavizada para ciclos económicos
        if cycle_pos < 0.25:  # Expansión
           multiplier = 0.9 + 0.1 * (cycle_pos * 4)
        elif cycle_pos < 0.5:  # Pico
           multiplier = 1.05 - 0.1 * ((cycle_pos - 0.25) * 4)
        elif cycle_pos < 0.75:  # Recesión
           multiplier = 0.8 - 0.2 * ((cycle_pos - 0.5) * 4)
        else:  # Recuperación
           multiplier = 0.7 + 0.2 * ((cycle_pos - 0.75) * 4)

        # Sector-specific volatility
        sector_volatility = self.params['volatility']

        # Añadir aleatoriedad basada en volatilidad del sector
        noise = random.uniform(-0.1, 0.1) * sector_volatility * 2

        return multiplier + noise

    def compete_for_workers(self):
        """Competencia por trabajadores calificados con otras regiones."""
        if not hasattr(self, 'other_regions'):
            return

        if self.workforce.qualification_gap > 0.1:
            for region in random.sample(self.other_regions, min(3, len(self.other_regions))):
                if region.id == self.id:
                    continue

                qualified_workers = [
                    w for w in region.workforce.workers
                    if w.skill > self.workforce.avg_skill and
                    w.specialized_skill > self.workforce.avg_specialized_skill
        ]

                if qualified_workers and len(self.workforce.workers) < self.required_workers:
                    num_to_steal = min(len(qualified_workers), max(1, int(self.required_workers * 0.1)))
                    for _ in range(num_to_steal):
                        if len(self.workforce.workers) >= self.required_workers:
                            break
                        worker = random.choice(qualified_workers)
                        region.workforce.workers.remove(worker)
                        region.workforce.update_metrics()
                        self.workforce.workers.append(worker)
                        worker.region_id = self.id
                        self.workforce.update_metrics()

    def update_performance(self):
        """Actualiza métricas de desempeño económico con mayor dinamismo."""
        # Factores que afectan la productividad
        workforce_impact = 0.5 * self.workforce.avg_skill * (1 + self.workforce.avg_specialized_skill/2)
        tech_impact = 0.6 * self.tech_capability

        # Efecto de la diversificación (curva en U invertida)
        diversification_impact = 2.5 * self.diversification * (1 - self.diversification)

        # Efecto de aprendizaje por experiencia
        learning_effect = np.log1p(self.steps) * 0.1

        # Variabilidad aleatoria (innovación, shocks)
        random_effect = random.uniform(-0.1, 0.1) * (1 - self.tech_capability/2)

        # Productividad base del sector
        sector_base = self.params['productivity']

        # Cálculo final de productividad con límites
        min_productivity = sector_base * 0.6
        max_productivity = sector_base * 1.8

        self.productivity = np.clip(
            sector_base * (1 + workforce_impact + tech_impact + diversification_impact +
                          learning_effect + random_effect),
            min_productivity,
            max_productivity
        )

        # Actualizar especialización/diversificación basado en rendimiento
        margin_factor = self.profit_margin / self.params['margin_range'][1]

        if margin_factor > 0.8:
            self.specialization = min(
                0.95,
                self.specialization + random.uniform(0, 0.09) * margin_factor
        )
        else:
            if random.random() < 0.4:
                self.specialization = max(
                    0.05,
                    self.specialization - random.uniform(0, 0.09) * (1 - margin_factor)
        )

        self.diversification = 1 - self.specialization

        # Efecto de la trampa de innovación en productividad
        if self.trapped:
            self.productivity = max(
                min_productivity,
                self.productivity * 0.98
        )
        # Efecto del empleo en la productividad
        employment_impact = 0.4 * (self.employment_rate - 0.7)
        self.productivity *= (1 + employment_impact)

        # Efecto de la tasa de empleo en los márgenes
        if self.employment_rate > 0.95:
           # Escasez de trabajadores -> mayores costos laborales
           self.profit_margin *= 0.98
        elif self.employment_rate < 0.85:
             # Desempleo -> posible reducción de costos
           self.profit_margin *= 1.02

    def check_innovation_trap(self):
        """Determina si la región cae en trampa de innovación con umbrales más bajos."""
        conditions = (
            self.tech_capability < 0.2,
            self.profit_margin > 0.4,
            self.innovation_rate < 0.03,
            self.workforce.qualification_gap > 0.2,
            self.diversification < 0.3,
            len(self.products) <= 3
        )

        self.trapped = sum(conditions) >= 4

        if self.trapped:
            self.profit_margin = min(0.9, self.profit_margin * 1.02)
            self.tech_capability = max(0.1, self.tech_capability * 0.98)
            self.diversification = max(0.05, self.diversification * 0.95)
            self.specialization = 1 - self.diversification

class EconomicModel:
    """Modelo económico completo con todas las regiones."""
    def __init__(self, n_regions=32):
        self.worker_pool = [Worker() for _ in range(WORKER_POOL_SIZE)]
        self.regions = [Region(i, self.worker_pool) for i in range(n_regions)]

        for region in self.regions:
            region.other_regions = [r for r in self.regions if r.id != region.id]

        self.steps = 0
        self.history = []

    def step(self):
        """Avanza la simulación un paso."""
        for region in random.sample(self.regions, len(self.regions)):
            region.update()

        self.record_state()
        self.steps += 1

    def run(self, steps=40):
        """Ejecuta la simulación para varios pasos."""
        for _ in range(steps):
            self.step()

    def calculate_sector_diversity(self):
        """Calcula la diversidad sectorial usando el índice de Shannon con dinámica temporal."""
        sector_counts = pd.Series([r.sector_type for r in self.regions]).value_counts()
        total = len(self.regions)

        # Calcular proporciones con suavizado para evitar log(0)
        proportions = (sector_counts + 0.0001) / (total + 0.0001*len(SECTOR_PARAMS))

        # Índice de Shannon
        shannon = -np.sum(proportions * np.log(proportions))

        # Añadir efecto de historial (promedio móvil)
        if self.steps > 0:
            prev_diversity = self.history[-1]["sector_diversity"] if self.history else 0
            return 0.7*shannon + 0.3*prev_diversity
        return shannon

    def calculate_tech_diversity(self):
        """Calcula la diversidad tecnológica usando el coeficiente de variación."""
        tech_levels = [r.tech_capability for r in self.regions]
        mean_tech = np.mean(tech_levels)

        if mean_tech == 0:
          return 0.0

        std_dev = np.std(tech_levels)
        return std_dev / mean_tech


    def record_state(self):
        """Registra el estado actual del modelo con todas las métricas."""
        current_state = {
            "step": self.steps,
            "avg_tech": np.mean([r.tech_capability for r in self.regions]),
            "avg_margin": np.mean([r.profit_margin for r in self.regions]),
            "avg_productivity": np.mean([r.productivity for r in self.regions]),
            "avg_innovation": np.mean([r.innovation_rate for r in self.regions]),
            "avg_diversification": np.mean([r.diversification for r in self.regions]),
            "avg_specialization": np.mean([r.specialization for r in self.regions]),
            "sector_diversity": self.calculate_sector_diversity(),
            "tech_diversity": self.calculate_tech_diversity(),
            "pct_trapped": np.mean([1 if r.trapped else 0 for r in self.regions]),
            "employment_rate": np.mean([r.employment_rate for r in self.regions])
        }

        # Calcular diversidad de productos
        all_products = []
        for r in self.regions:
            all_products.extend([p.name for p in r.products])
        current_state["unique_products"] = len(set(all_products)) if all_products else 0
        current_state["product_diversity"] = current_state["unique_products"] / len(self.regions) if len(self.regions) > 0 else 0

        # Agregar métricas por sector
        for sector_type in SECTOR_PARAMS.keys():
            sector_regions = [r for r in self.regions if r.sector_type == sector_type]
            if sector_regions:
                current_state[f"tech_{sector_type}"] = np.mean([r.tech_capability for r in sector_regions])
                current_state[f"innov_{sector_type}"] = np.mean([r.innovation_rate for r in sector_regions])

        self.history.append(current_state)

    def get_results(self):
        """Obtiene los resultados asegurando la estructura correcta del DataFrame."""
        # Crear DataFrame del modelo
        model_data = pd.DataFrame(self.history)

        # Datos de los agentes (regiones)
        agent_data = []
        for region in self.regions:
            agent_data.append({
                "id": region.id,
                "sector_type": region.sector_type,
                "sector_name": region.sector_name,
                "tech": region.tech_capability,
                "margin": region.profit_margin,
                "productivity": region.productivity,
                "innovation_rate": region.innovation_rate,
                "diversification": region.diversification,
                "specialization": region.specialization,
                "num_products": len(region.products),
                "qualification_gap": region.workforce.qualification_gap,
                "trapped": region.trapped,
                "employment_rate": region.employment_rate
            })

        return model_data, pd.DataFrame(agent_data)

def visualize_results_individual(model_data, agent_data):
    """Función de visualización que genera gráficas individuales."""
    # 1. Evolución de métricas principales

    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    main_metrics = ['employment_rate', 'avg_tech', 'avg_innovation']
    for metric in main_metrics:
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label=metric)
    ax2 = ax1.twinx()
    if 'avg_productivity' in model_data.columns:
      ax2.plot(model_data['step'], model_data['avg_productivity'], label='Promedio Productividad', color='black', linestyle='--')

    ax1.set_title('Evolución de Métricas Principales')
    ax1.set_xlabel('Step')
    ax1.set_ylabel('Empleo, Tecnología e Innovación')
    ax2.set_ylabel('Productividad')

    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')

    ax1.grid(True)

    plt.show()

    # 2. Diversidad sectorial y tecnológica
    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    main_metrics = ['tech_diversity']
    for metric in main_metrics:
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label=metric)
    ax2 = ax1.twinx()
    if 'sector_diversity' in model_data.columns:
      ax2.plot(model_data['step'], model_data['sector_diversity'], label='Diversidad Sectorial', color='black', linestyle='--')

    ax1.set_title('Diversidad Sectorial y Tecnológica')
    ax1.set_xlabel('Step')
    ax1.set_ylabel('Diversidad Tecnológica')
    ax2.set_ylabel('Diversidad Sectorial')

    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')

    ax1.grid(True)

    plt.show()

    # 3. Especialización vs Diversificación
    if all(col in model_data.columns for col in ['avg_specialization', 'avg_diversification']):
        plt.figure(figsize=(18, 12))
        plt.plot(model_data['step'], model_data['avg_specialization'], label='Especialización')
        plt.plot(model_data['step'], model_data['avg_diversification'], label='Diversificación')
        plt.title('Especialización vs Diversificación')
        plt.legend()
        plt.grid(True)
        plt.show()

    # 4. Productos por sector
    if all(col in agent_data.columns for col in ['sector_type', 'num_products']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='num_products')
        plt.title('Productos por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 5. Innovación por sector
    if all(col in agent_data.columns for col in ['sector_type', 'innovation_rate']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='innovation_rate')
        plt.title('Innovación por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 6. Tecnología por sector
    if all(col in agent_data.columns for col in ['sector_type', 'tech']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='tech')
        plt.title('Tecnología por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 7. Correlaciones entre variables del modelo
    numeric_cols = [col for col in model_data.columns if col != 'step' and pd.api.types.is_numeric_dtype(model_data[col])]
    if len(numeric_cols) > 1:
        plt.figure(figsize=(20, 13))
        sns.heatmap(model_data[numeric_cols].corr(), annot=True, cmap='coolwarm')
        plt.title('Correlaciones entre Variables del Modelo')
        plt.show()

    # 8. Correlaciones entre variables de agentes
    agent_numeric = agent_data.select_dtypes(include=np.number).columns.tolist()
    if len(agent_numeric) > 1:
        plt.figure(figsize=(18, 12))
        sns.heatmap(agent_data[agent_numeric].corr(), annot=True, cmap='viridis')
        plt.title('Correlaciones entre Variables de Regiones')
        plt.show()

    # 9. Regiones atrapadas vs no atrapadas
    if 'trapped' in agent_data.columns:
        trapped_vars = ['tech', 'innovation_rate', 'diversification', 'num_products']
        trapped_vars = [var for var in trapped_vars if var in agent_data.columns]
        if trapped_vars:
            plt.figure(figsize=(18, 12))
            trapped_stats = agent_data.groupby('trapped')[trapped_vars].mean().T
            trapped_stats.plot(kind='bar')
            plt.title('Comparación Regiones Atrapadas vs No Atrapadas')
            plt.grid(True)
            plt.show()

    # 10. Evolución de productividad
    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    main_metrics = ['avg_productivity']
    for metric in main_metrics:
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label=metric)
    ax2 = ax1.twinx()
    if 'avg_margin' in model_data.columns:
      ax2.plot(model_data['step'], model_data['avg_margin'], label='MBI promedio', color='black', linestyle='--')

    ax1.set_title('Productividad vs. MBI (Promedios)')
    ax1.set_xlabel('Step')
    ax1.set_ylabel('Productividad')
    ax2.set_ylabel('MBI')

    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')

    ax1.grid(True)

    plt.show()

    # 11. Porcentaje de regiones atrapadas
    if 'pct_trapped' in model_data.columns:
        plt.figure(figsize=(18, 12))
        plt.plot(model_data['step'], model_data['pct_trapped'])
        plt.title('Porcentaje de Regiones Atrapadas')
        plt.grid(True)
        plt.show()

    # 12. Factores que afectan la productividad
    plt.figure(figsize=(18, 12))
    factors = {
        'Tecnología': 'avg_tech',
        'Innovación': 'avg_innovation'
    }

    for name, col in factors.items():
        if col in model_data.columns:
            plt.plot(model_data['step'],
                    (model_data[col] - model_data[col].min()) /
                    (model_data[col].max() - model_data[col].min()),
                    label=name)

    plt.title('Factores que Afectan la Productividad (Normalizados)')
    plt.xlabel('Pasos')
    plt.ylabel('Influencia Normalizada')
    plt.legend()
    plt.grid(True)
    plt.show()

    # 14. Distribución de sectores a lo largo del tiempo (simplificada)
    if 'sector_type' in agent_data.columns and 'step' in model_data.columns:
        sector_counts = agent_data.groupby('sector_type').size().reset_index(name='count')
        plt.figure(figsize=(20, 13))
        plt.pie(sector_counts['count'], labels=sector_counts['sector_type'], autopct='%1.1f%%')
        plt.title('Distribución Actual de Sectores')
        plt.show()

    # Análisis estadístico detallado
    print("\n=== Estadísticas del Modelo ===")
    print(model_data.describe().round(3))

    print("\n=== Estadísticas por Sector ===")
    if 'sector_type' in agent_data.columns:
        sector_stats = agent_data.groupby('sector_type').agg({
            'tech': ['mean', 'std'],
            'innovation_rate': ['mean', 'std'],
            'num_products': ['mean', 'std'],
            'diversification': ['mean', 'std'],
            'productivity': ['mean', 'std']
        })
        print(sector_stats.round(3))

    print("\n=== Comparación Regiones Atrapadas ===")
    if 'trapped' in agent_data.columns:
        trapped_comparison = agent_data.groupby('trapped').agg({
            'tech': 'mean',
            'innovation_rate': 'mean',
            'diversification': 'mean',
            'num_products': 'mean',
            'productivity': 'mean'
        })
        print(trapped_comparison.round(3))

# Ejecución del modelo con visualización individual
model = EconomicModel(n_regions=32)
model.run(steps=30)
model_data, agent_data = model.get_results()

# Visualización de resultados individuales
visualize_results_individual(model_data, agent_data)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import defaultdict
from matplotlib.gridspec import GridSpec

# Configuración inicial
sns.set_style('darkgrid')
sns.set_palette("viridis")
plt.rcParams['figure.figsize'] = [20, 13]

# Implementación del coeficiente Gini
def gini_coefficient(x):
    """Coeficiente de Gini"""
    x = np.abs(x)
    x = np.sort(x)
    n = len(x)
    cumx = np.cumsum(x)
    return (n + 1 - 2 * np.sum(cumx) / cumx[-1]) / n

# Parámetros globales
INITIAL_TECH = 0.09
PROFIT_MARGIN_IMPACT = 0.65
TECH_DEVELOPMENT_COST = 0.12
INITIAL_WORKFORCE_SKILL = 0.3
EDUCATION_INVESTMENT_RATE = 0.03
INNOVATION_BASE_RATE = 0.05
MIN_INNOVATION_THRESHOLD = 0.05
KNOWLEDGE_SPILLOVER = 0.3
INNOVATION_ACCELERATION = 0.02
WORKER_POOL_SIZE = 100000
PRODUCTIVITY_BASE_VARIABILITY = 0.15
LEARNING_RATE = 0.08
TECH_PRODUCTIVITY_IMPACT = 0.6
WORKFORCE_PRODUCTIVITY_IMPACT = 0.8
SECTOR_CHANGE_BASE_RATE = 0.03
KNOWLEDGE_INTENSITY_THRESHOLD = 0.3
SECTOR_RELATEDNESS_THRESHOLD = 0.2
EMPLOYMENT_BASE_VOLATILITY = 0.06
SKILL_MISMATCH_PENALTY = 0.2
TECH_EMPLOYMENT_IMPACT = 0.5
ECONOMIC_CYCLE_LENGTH = 20

# Sectores económicos, detalle y características específicas
SECTORS = {
    1: "Agricultura Tradicional",
    2: "Agricultura Tecnificada",
    3: "Minería Básica",
    4: "Minería Tecnológica",
    5: "Manufactura Básica",
    6: "Manufactura Avanzada",
    7: "Servicios Básicos",
    8: "Servicios Financieros",
    9: "Servicios Tecnológicos",
    10: "Turismo Masivo",
    11: "Turismo Especializado"
}

# Categorización de sectores por tipo y nivel tecnológico
SECTOR_TYPES = {
    'Primario_Bajo': [1, 3],
    'Primario_Alto': [2, 4],
    'Manufactura_Baja': [5],
    'Manufactura_Alta': [6],
    'Servicios_Bajos': [7],
    'Servicios_Intermedios': [8],
    'Servicios_Avanzados': [9],
    'Turismo_Masivo': [10],
    'Turismo_Especializado': [11]
}

# Parámetros detallados por tipo de sector
SECTOR_PARAMS = {
    'Primario_Bajo': {
        'margin_range': (0.25, 0.45),
        'tech_invest': 0.05,
        'volatility': 0.35,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.7, 0.8),
        'training_investment': 0.05,
        'innovation_capacity': 0.1,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.7,
        'productivity': 5,
        'product_range': (3, 7),
        'max_employment': 1
    },
    'Primario_Alto': {
        'margin_range': (0.35, 0.55),
        'tech_invest': 0.25,
        'volatility': 0.25,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.75, 0.85),
        'training_investment': 0.15,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9),
        'max_employment': 1
    },
    'Manufactura_Baja': {
        'margin_range': (0.15, 0.3),
        'tech_invest': 0.2,
        'volatility': 0.2,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.85),
        'training_investment': 0.1,
        'innovation_capacity': 0.25,
        'knowledge_intensity': 0.35,
        'linkages': 0.6,
        'specialization_coeff': 0.5,
        'productivity': 8,
        'product_range': (6, 10),
        'max_employment': 1
    },
    'Manufactura_Alta': {
        'margin_range': (0.25, 0.4),
        'tech_invest': 0.4,
        'volatility': 0.15,
        'skill_requirements': (0.6, 0.8),
        'employment_rate': (0.8, 0.9),
        'training_investment': 0.2,
        'innovation_capacity': 0.5,
        'knowledge_intensity': 0.7,
        'linkages': 0.8,
        'specialization_coeff': 0.4,
        'productivity': 10,
        'product_range': (8, 14),
        'max_employment': 1
    },
    'Servicios_Bajos': {
        'margin_range': (0.2, 0.4),
        'tech_invest': 0.1,
        'volatility': 0.15,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.75, 0.9),
        'training_investment': 0.08,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.3,
        'linkages': 0.4,
        'specialization_coeff': 0.3,
        'productivity': 6,
        'product_range': (4, 8),
        'max_employment': 1
    },
    'Servicios_Intermedios': {
        'margin_range': (0.3, 0.5),
        'tech_invest': 0.25,
        'volatility': 0.1,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.8, 0.95),
        'training_investment': 0.15,
        'innovation_capacity': 0.35,
        'knowledge_intensity': 0.5,
        'linkages': 0.7,
        'specialization_coeff': 0.2,
        'productivity': 9,
        'product_range': (7, 11),
        'max_employment': 1
    },
    'Servicios_Avanzados': {
        'margin_range': (0.4, 0.65),
        'tech_invest': 0.45,
        'volatility': 0.1,
        'skill_requirements': (0.7, 0.9),
        'employment_rate': (0.85, 0.8),
        'training_investment': 0.25,
        'innovation_capacity': 0.7,
        'knowledge_intensity': 0.9,
        'linkages': 0.9,
        'specialization_coeff': 0.1,
        'productivity': 12,
        'product_range': (10, 14),
        'max_employment': 1
    },
    'Turismo_Masivo': {
        'margin_range': (0.2, 0.5),
        'tech_invest': 0.05,
        'volatility': 0.4,
        'skill_requirements': (0.2, 0.4),
        'employment_rate': (0.6, 0.9),
        'training_investment': 0.03,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.8,
        'productivity': 5,
        'product_range': (3, 7),
        'max_employment': 1
    },
    'Turismo_Especializado': {
        'margin_range': (0.3, 0.6),
        'tech_invest': 0.15,
        'volatility': 0.3,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.9),
        'training_investment': 0.1,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9),
        'max_employment': 1
    }
}

class Product:
    """Clase para modelar productos/servicios de una región"""
    def __init__(self, sector_type, product_id):
        params = SECTOR_PARAMS[sector_type]
        self.id = product_id
        self.name = f"Product_{sector_type}_{product_id}"
        self.revenue = random.uniform(*params['product_range'])
        self.cost = random.uniform(0.4, 0.8) * self.revenue
        self.production = random.uniform(3, 16)
        self.tech_intensity = random.uniform(0.1, params['knowledge_intensity'])
        self.skill_required = random.uniform(*params['skill_requirements'])

    def calculate_margin(self):
        return (self.revenue - self.cost) / self.revenue

class Worker:
    """Clase para modelar trabajadores individuales con sus habilidades"""
    def __init__(self, sector_type=None):
        if sector_type:
            params = SECTOR_PARAMS[sector_type]
            self.skill = random.uniform(
                max(0.1, params['skill_requirements'][0] - 0.2),
                min(1.0, params['skill_requirements'][1] + 0.1)
            )
            self.specialized_skill = random.uniform(0.5, 1.1) # Habilidad específica para el sector
        else:
            self.skill = random.uniform(0.1, 0.6) # Trabajador no especializado
            self.specialized_skill = 0.0

        self.employed = False
        self.region_id = None
        self.sector_type = sector_type

    def improve_skills(self, training_investment, tech_exposure):
        """Mejora habilidades con más variabilidad"""
        # Efecto no lineal del entrenamiento
        training_effect = 0.5 * (1 - np.exp(-2 * training_investment))

        # Efecto de la tecnología con curva de aprendizaje
        tech_effect = 0.6 * (1 - np.exp(-1.5 * tech_exposure))

        # Variabilidad individual
        individual_factor = random.uniform(0.8, 1.2)

        skill_gain = (training_effect + tech_effect) * individual_factor * 0.2
        self.skill = np.clip(self.skill + skill_gain, 0.1, 1.0)

        if self.sector_type:
           specialized_gain = (training_effect * 1.2 + tech_effect * 0.8) * individual_factor * 0.25
           self.specialized_skill = np.clip(
            self.specialized_skill + specialized_gain,
            0.1, 1.0
           )

class Workforce:
    """Clase para modelar la fuerza laboral con mayor detalle en cualificación"""
    def __init__(self, sector_type, region_id):
        self.params = SECTOR_PARAMS[sector_type]
        params = SECTOR_PARAMS[sector_type]
        self.workers = []
        self.sector_type = sector_type
        self.region_id = region_id
        self.training_investment = params['training_investment']
        self.skill_requirements = random.uniform(*params['skill_requirements'])
        self.min_specialized_skill = 0.6 # Mínimo requerido para trabajadores especializados
        self.update_metrics()

    def update_metrics(self):
        """Actualiza métricas con requisitos dinámicos"""
        # Hacer los requisitos sensibles a la tecnología
        tech_factor = 1 + (self.region.tech_capability if hasattr(self, 'region') else 0)
        self.skill_requirements = np.clip(
        random.uniform(*self.params['skill_requirements']) * tech_factor,
        self.params['skill_requirements'][0],
        self.params['skill_requirements'][1] * 1.3
    )

        # Actualizar métricas normales
        if self.workers:
           self.avg_skill = np.mean([w.skill for w in self.workers])
           self.avg_specialized_skill = np.mean([w.specialized_skill for w in self.workers])
           self.qualification_gap = max(0, self.skill_requirements - self.avg_skill)
           self.qualification_gap *= random.uniform(0.9, 1.2)
        else:
           self.avg_skill = 0
           self.avg_specialized_skill = 0
           self.qualification_gap = self.skill_requirements

    def hire_workers(self, num_workers, worker_pool):
        """Contrata trabajadores del pool de trabajadores disponibles"""
        hired = 0
        available_workers = [w for w in worker_pool if not w.employed]
        # Primero intentar contratar trabajadores con habilidades especializadas
        specialized_workers = [w for w in available_workers if w.sector_type == self.sector_type]
        for worker in specialized_workers[:min(num_workers, len(specialized_workers))]:
            worker.employed = True
            worker.region_id = self.region_id
            self.workers.append(worker)
            hired += 1
        # Luego contratar trabajadores sin habilidades especializadas
        remaining = num_workers - hired
        if remaining > 0:
            general_workers = [w for w in available_workers if w not in specialized_workers]
            for worker in general_workers[:min(remaining, len(general_workers))]:
                worker.employed = True
                worker.region_id = self.region_id
                worker.sector_type = self.sector_type
                self.workers.append(worker)
                hired += 1

        self.update_metrics()
        return hired

    def fire_workers(self, num_workers):
        """Despide trabajadores, comenzando por los menos calificados"""
        if not self.workers:
            return 0

        self.workers.sort(key=lambda x: x.skill + x.specialized_skill)

        fired = 0
        for _ in range(min(num_workers, len(self.workers))):
            worker = self.workers.pop(0)
            worker.employed = False
            worker.region_id = None
            fired += 1

        self.update_metrics()
        return fired

    def adjust_workforce(self, required_workers, worker_pool):
        """Ajusta la fuerza laboral a los trabajadores requeridos"""
        current = len(self.workers)
        if current < required_workers:
            self.hire_workers(required_workers - current, worker_pool)
        elif current > required_workers:
            self.fire_workers(current - required_workers)

    def evaluate_workers(self):
        """Evalúa y posiblemente despide trabajadores que no cumplen los requisitos"""
        to_fire = []
        for worker in self.workers:
            if (worker.skill < self.skill_requirements * 0.7 or
                (worker.specialized_skill < self.min_specialized_skill * 0.7)):
                to_fire.append(worker)

        for worker in to_fire:
            self.workers.remove(worker)
            worker.employed = False
            worker.region_id = None

        self.update_metrics()
        return len(to_fire)

    def train_workers(self, tech_exposure):
        """Entrena y mejora las habilidades de los trabajadores"""
        for worker in self.workers:
            worker.improve_skills(self.training_investment, tech_exposure)
        self.update_metrics()

    def wage_inequality(self):
        """Calcula la desigualdad salarial usando el coeficiente de Gini."""
        if not self.workers:
            return 0  # Sin trabajadores, no hay desigualdad

        # Asumiendo que la habilidad está relacionada con el salario
        wages = [worker.skill for worker in self.workers]
        return gini_coefficient(wages)

class Region:
    """Clase que representa una región con su economía y fuerza laboral"""
    def __init__(self, region_id, worker_pool):
        self.id = region_id
        self.worker_pool = worker_pool
        self.sector_id = random.choice(list(SECTORS.keys()))
        self.sector_type = self.get_sector_type()
        self.sector_name = SECTORS[self.sector_id]
        self.params = SECTOR_PARAMS[self.sector_type]

        # Variables económicas
        self.tech_capability = INITIAL_TECH
        self.profit_margin = random.uniform(*self.params['margin_range'])
        self.productivity = self.params['productivity']
        self.specialization = self.params['specialization_coeff']
        self.diversification = 1 - self.specialization
        self.innovation_rate = 0.0
        self.trapped = False
        self.employment_rate = random.uniform(*self.params['employment_rate'])
        self.steps = 0

        # Productos/servicios
        self.products = [
            Product(self.sector_type, i) for i in range(random.randint(2, 6))
        ]
        self.total_production = sum(p.production for p in self.products)

        # Fuerza laboral
        self.workforce = Workforce(self.sector_type, self.id)
        self.required_workers = max(1, int(self.total_production / self.productivity))
        self.workforce.hire_workers(self.required_workers, self.worker_pool)

        # Historial
        self.specialization_history = [self.specialization]
        self.diversification_history = [self.diversification]
        self.qualification_gap_history = [self.workforce.qualification_gap]

    def get_sector_type(self):
        """Determina el tipo de sector"""
        for sector_type, ids in SECTOR_TYPES.items():
            if self.sector_id in ids:
                return sector_type
        return 'Primario_Bajo'

    def consider_sector_change(self):
        """Evalúa si la región debe cambiar de sector económico"""
        if random.random() < SECTOR_CHANGE_BASE_RATE:
            # Factores que influyen en el cambio
            tech_push = max(0, self.tech_capability - self.params['knowledge_intensity'])
            margin_pull = max(0, self.params['margin_range'][1] - self.profit_margin)
            innovation_push = self.innovation_rate * 2

            change_probability = SECTOR_CHANGE_BASE_RATE + 0.5 * (tech_push + margin_pull + innovation_push)

            if random.random() < change_probability:
                # Buscar sectores relacionados pero más avanzados
                possible_sectors = [
                    k for k, v in SECTOR_PARAMS.items()
                    if v['knowledge_intensity'] > self.params['knowledge_intensity']
                    and abs(v['margin_range'][0] - self.params['margin_range'][0]) < SECTOR_RELATEDNESS_THRESHOLD
                ]

                if possible_sectors:
                    new_sector = random.choice(possible_sectors)
                    new_sector_id = random.choice(SECTOR_TYPES[new_sector])
                    self.sector_id = new_sector_id
                    self.sector_type = new_sector
                    self.sector_name = SECTORS[new_sector_id]
                    self.params = SECTOR_PARAMS[new_sector]

                    # Ajustar tecnología al nuevo sector
                    self.tech_capability = max(INITIAL_TECH, self.tech_capability * 0.8)

                    # Reemplazar algunos productos
                    if self.products:
                        num_to_replace = min(2, len(self.products))
                        for _ in range(num_to_replace):
                            self.products.pop(random.randint(0, len(self.products)-1))
                            self.products.append(Product(new_sector, len(self.products)+1))

    def update(self):
        """Actualiza el estado de la región"""
        # Perturbaciones externas
        self.external_shocks()

        # Toma de decisiones estratégicas
        self.make_strategic_decision()

        # Ajustar productos/servicios
        self.adjust_products()

        # Innovación
        self.innovate()

        # Actualizar fuerza laboral
        self.update_workforce()

        # Actualizar métricas de desempeño
        self.update_performance()

        # Verificar trampa de innovación
        self.check_innovation_trap()

        # Considerar cambio de sector
        self.consider_sector_change()

        # Registrar historial
        self.specialization_history.append(self.specialization)
        self.diversification_history.append(self.diversification)
        self.qualification_gap_history.append(self.workforce.qualification_gap)

        # Incrementar contador de pasos
        self.steps += 1
        self.innovation_rate += random.uniform(-0.02, 0.03)
        self.employment_rate = np.clip(self.employment_rate + random.uniform(-0.03, 0.03), 0.5, 1.0)

    def external_shocks(self):
        """Simula perturbaciones externas a la región"""
        # Shock general (economía, demanda)
        shock_factor = random.uniform(0.85, 1.15) ** (1 + self.params['volatility'])
        self.total_production *= shock_factor

        # Shock en márgenes (competencia, costos)
        margin_shock = random.normalvariate(0, 0.09) * self.params['volatility']
        self.profit_margin = np.clip(
             self.profit_margin + margin_shock,
             self.params['margin_range'][0] * 0.8,
             self.params['margin_range'][1] * 1.1
        )

        # Shock en productividad (innovaciones, fallas)
        productivity_shock = random.normalvariate(0, 0.1) * (1 - self.tech_capability/2)
        self.productivity = np.clip(
             self.productivity * (1 + productivity_shock),
             self.params['productivity'] * 0.5,
             self.params['productivity'] * 2.0
        )

        # Eventos raros pero impactantes (crisis, boom tecnológico)
        if random.random() < 0.02:
           big_shock = random.uniform(-0.4, 0.6)
           self.productivity *= (1 + big_shock)

        # Evento sectorial con baja probabilidad (1%)
        if random.random() < 0.01:
           shock_magnitude = random.uniform(-0.4, 0.5)

        # Afectar productividad
        self.productivity *= (1 + productivity_shock/2)

    def make_strategic_decision(self):
        """Toma decisiones sobre inversión en tecnología vs márgenes"""
        if random.random() < self.params['tech_invest'] * (1 - self.profit_margin):
            tech_investment = random.uniform(0.05, 0.15) * (1 + self.diversification)
            self.tech_capability += tech_investment
            self.profit_margin = max(
                self.params['margin_range'][0],
                self.profit_margin - random.uniform(0.03, 0.09)
        )
        else:
            margin_increase = random.uniform(0, 0.05) * self.specialization
            self.profit_margin += margin_increase
            self.tech_capability = max(
                INITIAL_TECH,
                self.tech_capability - random.uniform(0, 0.03)
        )

    def adjust_products(self):
        """Ajusta la cartera de productos/servicios de la región"""
        # 1. Eliminar productos no rentables con cierta probabilidad
        to_remove = []
        for product in self.products:
            if (product.calculate_margin() < self.profit_margin * 0.7 and
                random.random() < 0.3):
                to_remove.append(product)

        # Eliminar productos seleccionados
        for product in to_remove:
            self.products.remove(product)
            self.total_production -= product.production

        # 2. Innovación de productos --- tres tipos posibles
        if random.random() < self.innovation_rate:
            innovation_type = random.choices(
                ['incremental', 'sector_relacionado', 'radical'],
                weights=[0.6, 0.3, 0.1]
        )[0]

            if innovation_type == 'incremental':
                new_product = Product(self.sector_type, len(self.products) + 1)
            elif innovation_type == 'sector_relacionado':
                related_sectors = [
                    k for k, v in SECTOR_PARAMS.items()
                    if abs(v['knowledge_intensity'] - self.params['knowledge_intensity']) < 0.2
                    and k != self.sector_type
        ]
                if related_sectors:
                    new_sector = random.choice(related_sectors)
                    new_product = Product(new_sector, len(self.products) + 1)
                else:
                    new_product = Product(self.sector_type, len(self.products) + 1)
            else:
                random_sector = random.choice(list(SECTOR_PARAMS.keys()))
                new_product = Product(random_sector, len(self.products) + 1)

            self.products.append(new_product)
            self.total_production += new_product.production

        # 3. Ocasionalmente agregar producto aleatorio (diversificación espontánea)
        if random.random() < 0.03:
            random_sector = random.choice(list(SECTOR_PARAMS.keys()))
            new_product = Product(random_sector, len(self.products) + 1)
            self.products.append(new_product)
            self.total_production += new_product.production

        # Actualizar trabajadores requeridos
        self.required_workers = max(1, int(self.total_production / self.productivity))

    def innovate(self):
        """Tasas de innovación"""
        if self.tech_capability > MIN_INNOVATION_THRESHOLD:
           tech_factor = 0.3 + self.tech_capability
           skill_factor = 0.1 + self.workforce.avg_skill
           diversification_factor = 0.3 + self.diversification

           self.innovation_rate = (
               INNOVATION_BASE_RATE +
               (tech_factor * skill_factor * self.params['innovation_capacity']) *
               (1 + np.log1p(self.steps * INNOVATION_ACCELERATION * 2.5))
        )
        if random.random() < 0.02:  # Probabilidad baja de evento radical
           self.innovation_rate += random.uniform(0.05, 0.15)

        # Transferencia tecnológica
        if hasattr(self, 'other_regions'):
            avg_neighbor_tech = np.mean([r.tech_capability for r in self.other_regions])
            if avg_neighbor_tech > self.tech_capability:
                tech_transfer = KNOWLEDGE_SPILLOVER * 1.5 * (avg_neighbor_tech - self.tech_capability)
                self.tech_capability = min(1.0, self.tech_capability + tech_transfer)
                self.innovation_rate = min(0.3, self.innovation_rate * 1.2)  # Bonus por transferencia

        # Evento de innovación
        if random.random() < self.innovation_rate:
            tech_gain = random.uniform(0.02, 0.15) * (1 + self.diversification)
            self.tech_capability = min(1.0, self.tech_capability + tech_gain)

            if random.random() < 0.3:
                new_product = Product(self.sector_type, len(self.products) + 1)
                self.products.append(new_product)
                self.total_production += new_product.production
        else:
             self.innovation_rate = 0

    def update_workforce(self):
        """Actualización de fuerza laboral"""
        # Calcular demanda base de trabajadores
        base_demand = max(1, int(self.total_production / self.productivity))

        # Factores de ajuste
        tech_impact = TECH_EMPLOYMENT_IMPACT * (1 - self.tech_capability)
        skill_gap_impact = SKILL_MISMATCH_PENALTY * self.workforce.qualification_gap
        economic_cycle = self.economic_cycle_effect()

        # Calcular demanda ajustada
        adjusted_demand = base_demand * economic_cycle * (1 - tech_impact - skill_gap_impact)
        self.required_workers = max(1, int(adjusted_demand* random.uniform(0.9, 1.1)))

        # Ajustar fuerza laboral con inercia
        current_workers = len(self.workforce.workers)
        change = self.required_workers - current_workers
        max_change = max(1, int(current_workers * 0.25))

        if abs(change) > max_change:
           change = max_change if change > 0 else -max_change

        # Manejar contrataciones y despidos por separado
        hired = 0
        if change > 0:
           hired = self.workforce.hire_workers(change, self.worker_pool)
           if hired < change:  # Solo aplica si no se pudo contratar suficiente personal
               self.total_production *= (hired / change)
        elif change < 0:
            # En caso de despidos
            self.workforce.fire_workers(-change)

        # Entrenamiento y evaluación
        self.workforce.evaluate_workers()
        self.workforce.train_workers(self.tech_capability)
        self.compete_for_workers()

        # Calcular tasa de empleo
        if self.required_workers > 0:
           actual_workers = len(self.workforce.workers)
           self.employment_rate = actual_workers / self.required_workers

           # Añadir variabilidad realista
           employment_noise = random.uniform(1 - EMPLOYMENT_BASE_VOLATILITY,
                                         1 + EMPLOYMENT_BASE_VOLATILITY)
           self.employment_rate = np.clip(
                                         self.employment_rate * employment_noise,
                                         0.5,
                                         self.params['max_employment']
        )
        else:
            self.employment_rate = 0

    def economic_cycle_effect(self):
        """Efecto de ciclo económico en el empleo"""
        # Posición en el ciclo (0 a 1)
        cycle_pos = (self.steps % ECONOMIC_CYCLE_LENGTH) / ECONOMIC_CYCLE_LENGTH

        # Curva senoidal suavizada para ciclos económicos
        if cycle_pos < 0.25:  # Expansión
           multiplier = 0.9 + 0.1 * (cycle_pos * 4)
        elif cycle_pos < 0.5:  # Pico
           multiplier = 1.05 - 0.1 * ((cycle_pos - 0.25) * 4)
        elif cycle_pos < 0.75:  # Recesión
           multiplier = 0.8 - 0.2 * ((cycle_pos - 0.5) * 4)
        else:  # Recuperación
           multiplier = 0.7 + 0.2 * ((cycle_pos - 0.75) * 4)

        # Sector-specific volatility
        sector_volatility = self.params['volatility']

        # Añadir aleatoriedad basada en volatilidad del sector
        noise = random.uniform(-0.1, 0.1) * sector_volatility * 2

        return multiplier + noise

    def compete_for_workers(self):
        """Competencia por trabajadores calificados con otras regiones"""
        if not hasattr(self, 'other_regions'):
            return

        if self.workforce.qualification_gap > 0.1:
            for region in random.sample(self.other_regions, min(3, len(self.other_regions))):
                if region.id == self.id:
                    continue

                qualified_workers = [
                    w for w in region.workforce.workers
                    if w.skill > self.workforce.avg_skill and
                    w.specialized_skill > self.workforce.avg_specialized_skill
        ]

                if qualified_workers and len(self.workforce.workers) < self.required_workers:
                    num_to_steal = min(len(qualified_workers), max(1, int(self.required_workers * 0.1)))
                    for _ in range(num_to_steal):
                        if len(self.workforce.workers) >= self.required_workers:
                            break
                        worker = random.choice(qualified_workers)
                        region.workforce.workers.remove(worker)
                        region.workforce.update_metrics()
                        self.workforce.workers.append(worker)
                        worker.region_id = self.id
                        self.workforce.update_metrics()

    def update_performance(self):
        """Actualiza métricas de desempeño económico con mayor dinamismo."""
        # Factores que afectan la productividad
        workforce_impact = 0.5 * self.workforce.avg_skill * (1 + self.workforce.avg_specialized_skill/2)
        tech_impact = 0.6 * self.tech_capability

        # Efecto de la diversificación (curva en U invertida)
        diversification_impact = 2.5 * self.diversification * (1 - self.diversification)

        # Efecto de aprendizaje por experiencia
        learning_effect = np.log1p(self.steps) * 0.1

        # Variabilidad aleatoria (innovación, shocks)
        random_effect = random.uniform(-0.1, 0.1) * (1 - self.tech_capability/2)

        # Productividad base del sector
        sector_base = self.params['productivity']

        # Cálculo final de productividad con límites
        min_productivity = sector_base * 0.6
        max_productivity = sector_base * 1.8

        self.productivity = np.clip(
            sector_base * (1 + workforce_impact + tech_impact + diversification_impact +
                          learning_effect + random_effect),
            min_productivity,
            max_productivity
        )

        # Actualizar especialización/diversificación basado en rendimiento
        margin_factor = self.profit_margin / self.params['margin_range'][1]

        if margin_factor > 0.8:
            self.specialization = min(
                0.95,
                self.specialization + random.uniform(0, 0.09) * margin_factor
        )
        else:
            if random.random() < 0.4:
                self.specialization = max(
                    0.05,
                    self.specialization - random.uniform(0, 0.09) * (1 - margin_factor)
        )

        self.diversification = 1 - self.specialization

        # Efecto de la trampa de innovación en productividad
        if self.trapped:
            self.productivity = max(
                min_productivity,
                self.productivity * 0.98
        )
        # Efecto del empleo en la productividad
        employment_impact = 0.4 * (self.employment_rate - 0.8)
        self.productivity *= (1 + employment_impact)

        # Efecto de la tasa de empleo en los márgenes
        if self.employment_rate > 0.95:
           # Escasez de trabajadores -> mayores costos laborales
           self.profit_margin *= 0.98
        elif self.employment_rate < 0.85:
             # Desempleo -> posible reducción de costos
           self.profit_margin *= 1.02

    def check_innovation_trap(self):
        """Determina si la región cae en trampa de innovación"""
        conditions = (
            self.tech_capability < 0.3,
            self.profit_margin > 0.5,
            self.innovation_rate < 0.03,
            self.workforce.qualification_gap > 0.3,
            self.diversification < 0.3,
            len(self.products) <= 3
        )

        self.trapped = sum(conditions) >= 4

        if self.trapped:
            self.profit_margin = min(0.9, self.profit_margin * 1.02)
            self.tech_capability = max(0.1, self.tech_capability * 0.98)
            self.diversification = max(0.05, self.diversification * 0.95)
            self.specialization = 1 - self.diversification

class EconomicModel:
    """Modelo económico completo con todas las regiones."""
    def __init__(self, n_regions=32):
        self.worker_pool = [Worker() for _ in range(WORKER_POOL_SIZE)]
        self.regions = [Region(i, self.worker_pool) for i in range(n_regions)]

        for region in self.regions:
            region.other_regions = [r for r in self.regions if r.id != region.id]

        self.steps = 0
        self.history = []

    def step(self):
        """Avanza la simulación un paso"""
        for region in random.sample(self.regions, len(self.regions)):
            region.update()

        self.record_state()
        self.steps += 1

    def run(self, steps=40):
        """Ejecuta la simulación para varios pasos"""
        for _ in range(steps):
            self.step()

    def calculate_sector_diversity(self):
        """Calcula la diversidad sectorial con más dinamismo"""
        sector_counts = pd.Series([r.sector_type for r in self.regions]).value_counts()
        total = len(self.regions)

        # Suavizado más agresivo y ponderación por tecnología
        proportions = (sector_counts + 0.001) / (total + 0.001*len(SECTOR_PARAMS))

        # Índice de Shannon modificado con influencia tecnológica
        avg_tech_by_sector = {sector_type: np.mean([r.tech_capability for r in self.regions if r.sector_type == sector_type])
                          for sector_type in proportions.index}

        tech_weights = [avg_tech_by_sector[sector_type] for sector_type in proportions.index]

        weighted_proportions = proportions * (1 + np.array(tech_weights))/10

        shannon = -np.sum(weighted_proportions * np.log(weighted_proportions))

         # Añadir ruido controlado
        noise = random.uniform(-0.05, 0.05) * (1 - np.mean(tech_weights))
        return np.clip(shannon + noise, 0, np.log(len(SECTOR_PARAMS)))

    def calculate_tech_diversity(self):
        """Calcula la diversidad tecnológica usando el coeficiente de variación."""
        tech_levels = [r.tech_capability for r in self.regions]
        return np.std(tech_levels) / np.mean(tech_levels) if np.mean(tech_levels) != 0 else 0

    def record_state(self):
        """Registra el estado actual del modelo con todas las métricas."""
        current_state = {
            "step": self.steps,
            "avg_tech": np.mean([r.tech_capability for r in self.regions]),
            "avg_margin": np.mean([r.profit_margin for r in self.regions]),
            "avg_productivity": np.mean([r.productivity for r in self.regions]),
            "avg_innovation": np.mean([r.innovation_rate for r in self.regions]),
            "avg_diversification": np.mean([r.diversification for r in self.regions]),
            "avg_specialization": np.mean([r.specialization for r in self.regions]),
            "sector_diversity": self.calculate_sector_diversity(),
            "tech_diversity": self.calculate_tech_diversity(),
            "pct_trapped": np.mean([1 if r.trapped else 0 for r in self.regions]),
            "employment_rate": np.mean([r.employment_rate for r in self.regions]),
            "tech_inequality": gini_coefficient([r.tech_capability for r in self.regions]),
            "skill_inequality": np.mean([r.workforce.wage_inequality() for r in self.regions]),
            "qualification_gap": np.mean([r.workforce.qualification_gap for r in self.regions])
        }

        # Calcular diversidad de productos
        all_products = []
        for r in self.regions:
            all_products.extend([p.name for p in r.products])
        current_state["unique_products"] = len(set(all_products)) if all_products else 0
        current_state["product_diversity"] = current_state["unique_products"] / len(self.regions) if len(self.regions) > 0 else 0

        # Agregar métricas por sector
        for sector_type in SECTOR_PARAMS.keys():
            sector_regions = [r for r in self.regions if r.sector_type == sector_type]
            if sector_regions:
                current_state[f"tech_{sector_type}"] = np.mean([r.tech_capability for r in sector_regions])
                current_state[f"innov_{sector_type}"] = np.mean([r.innovation_rate for r in sector_regions])

        self.history.append(current_state)

    def get_results(self):
        """Obtiene los resultados asegurando la estructura correcta del DataFrame."""
        # Crear DataFrame del modelo
        model_data = pd.DataFrame(self.history)

        # Datos de los agentes (regiones)
        agent_data = []
        for region in self.regions:
            agent_data.append({
                "id": region.id,
                "sector_type": region.sector_type,
                "sector_name": region.sector_name,
                "tech": region.tech_capability,
                "margin": region.profit_margin,
                "productivity": region.productivity,
                "innovation_rate": region.innovation_rate,
                "diversification": region.diversification,
                "specialization": region.specialization,
                "num_products": len(region.products),
                "qualification_gap": region.workforce.qualification_gap,
                "trapped": region.trapped,
                "employment_rate": region.employment_rate
            })

        return model_data, pd.DataFrame(agent_data)

def visualize_results_individual(model_data, agent_data):
    """Función de visualización que genera gráficas individuales."""
    # 1. Evolución de métricas principales

    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    main_metrics = [ 'avg_tech']
    for metric in main_metrics:
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label='Promedio Tecnología')
    ax2 = ax1.twinx()
    if 'avg_innovation' in model_data.columns:
      ax2.plot(model_data['step'], model_data['avg_innovation'], label='Promedio Innovación', color='black', linestyle='--')

    ax1.set_title('Evolución Tecnología e Innovación')
    ax1.set_xlabel('Step')
    ax1.set_ylabel('Tecnología')
    ax2.set_ylabel('Innovación')

    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')

    ax1.grid(True)

    plt.show()

    # 2. Diversidad sectorial y tecnológica
    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    main_metrics = ['tech_diversity']
    for metric in main_metrics:
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label=metric)
    ax2 = ax1.twinx()
    if 'sector_diversity' in model_data.columns:
      ax2.plot(model_data['step'], model_data['sector_diversity'], label='Diversidad Sectorial', color='black', linestyle='--')

    ax1.set_title('Diversidad Sectorial y Tecnológica')
    ax1.set_xlabel('Step')
    ax1.set_ylabel('Diversidad Tecnológica')
    ax2.set_ylabel('Diversidad Sectorial')

    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')

    ax1.grid(True)

    plt.show()

    # 3. Evolución desigualdades
    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    main_metrics = [ 'tech_inequality']
    for metric in main_metrics:
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label='Brecha Tecnología')
    ax2 = ax1.twinx()
    if 'skill_inequality' in model_data.columns:
      ax2.plot(model_data['step'], model_data['skill_inequality'], label='Brecha calificación', color='black', linestyle='--')

    ax1.set_title('Evolución Brechas')
    ax1.set_xlabel('Step')
    ax1.set_ylabel('Tecnología')
    ax2.set_ylabel('Calificación')

    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')

    ax1.grid(True)

    plt.show()

    # 4. Productos por sector
    if all(col in agent_data.columns for col in ['sector_type', 'num_products']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='num_products')
        plt.title('Productos por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 5. Innovación por sector
    if all(col in agent_data.columns for col in ['sector_type', 'innovation_rate']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='innovation_rate')
        plt.title('Innovación por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 6. Tecnología por sector
    if all(col in agent_data.columns for col in ['sector_type', 'tech']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='tech')
        plt.title('Tecnología por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 7. Correlaciones entre variables del modelo
    numeric_cols = [col for col in model_data.columns if col != 'step' and pd.api.types.is_numeric_dtype(model_data[col])]
    if len(numeric_cols) > 1:
        plt.figure(figsize=(20, 13))
        sns.heatmap(model_data[numeric_cols].corr(), annot=True, cmap='coolwarm')
        plt.title('Correlaciones entre Variables del Modelo')
        plt.show()

    # 8. Correlaciones entre variables de agentes
    agent_numeric = agent_data.select_dtypes(include=np.number).columns.tolist()
    if len(agent_numeric) > 1:
        plt.figure(figsize=(18, 12))
        sns.heatmap(agent_data[agent_numeric].corr(), annot=True, cmap='viridis')
        plt.title('Correlaciones entre Variables de Regiones')
        plt.show()

    # 9. Regiones atrapadas vs no atrapadas
    if 'trapped' in agent_data.columns:
        trapped_vars = ['tech', 'innovation_rate', 'diversification', 'num_products']
        trapped_vars = [var for var in trapped_vars if var in agent_data.columns]
        if trapped_vars:
            plt.figure(figsize=(18, 12))
            trapped_stats = agent_data.groupby('trapped')[trapped_vars].mean().T
            trapped_stats.plot(kind='bar')
            plt.title('Comparación Regiones Atrapadas vs No Atrapadas')
            plt.grid(True)
            plt.show()

    # 10. Evolución de productividad vs MBI
    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    main_metrics = ['avg_productivity']
    for metric in main_metrics:
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label=metric)
    ax2 = ax1.twinx()
    if 'avg_margin' in model_data.columns:
      ax2.plot(model_data['step'], model_data['avg_margin'], label='MBI promedio', color='black', linestyle='--')

    ax1.set_title('Productividad vs. MBI (Promedios)')
    ax1.set_xlabel('Step')
    ax1.set_ylabel('Productividad')
    ax2.set_ylabel('MBI')

    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')

    ax1.grid(True)

    plt.show()

    # 11. Porcentaje de regiones atrapadas
    if 'pct_trapped' in model_data.columns:
        plt.figure(figsize=(18, 12))
        plt.plot(model_data['step'], model_data['pct_trapped'])
        plt.title('Porcentaje de Regiones Atrapadas')
        plt.grid(True)
        plt.show()

    # 12. Factores que afectan la productividad
    plt.figure(figsize=(18, 12))
    factors = {
        'Tecnología': 'avg_tech',
        'Innovación': 'avg_innovation',
        'Tasa de empleo': 'employment_rate'
    }

    for name, col in factors.items():
        if col in model_data.columns:
            plt.plot(model_data['step'],
                    (model_data[col] - model_data[col].min()) /
                    (model_data[col].max() - model_data[col].min()),
                    label=name)

    plt.title('Factores que Afectan la Productividad (Normalizados)')
    plt.xlabel('Pasos')
    plt.ylabel('Influencia Normalizada')
    plt.legend()
    plt.grid(True)
    plt.show()

    # 14. Distribución de sectores a lo largo del tiempo (simplificada)
    if 'sector_type' in agent_data.columns and 'step' in model_data.columns:
        sector_counts = agent_data.groupby('sector_type').size().reset_index(name='count')
        plt.figure(figsize=(20, 13))
        plt.pie(sector_counts['count'], labels=sector_counts['sector_type'], autopct='%1.1f%%')
        plt.title('Distribución Actual de Sectores')
        plt.show()

    # Análisis estadístico detallado
    print("\n=== Estadísticas del Modelo ===")
    print(model_data.describe().round(3))

    print("\n=== Estadísticas por Sector ===")
    if 'sector_type' in agent_data.columns:
        sector_stats = agent_data.groupby('sector_type').agg({
            'tech': ['mean', 'std'],
            'innovation_rate': ['mean', 'std'],
            'num_products': ['mean', 'std'],
            'diversification': ['mean', 'std'],
            'productivity': ['mean', 'std']
        })
        print(sector_stats.round(3))

    print("\n=== Comparación Regiones Atrapadas ===")
    if 'trapped' in agent_data.columns:
        trapped_comparison = agent_data.groupby('trapped').agg({
            'tech': 'mean',
            'innovation_rate': 'mean',
            'diversification': 'mean',
            'num_products': 'mean',
            'productivity': 'mean'
        })
        print(trapped_comparison.round(3))

# Ejecución del modelo con visualización individual
model = EconomicModel(n_regions=32)
model.run(steps=30)
model_data, agent_data = model.get_results()

# Visualización de resultados individuales
visualize_results_individual(model_data, agent_data)