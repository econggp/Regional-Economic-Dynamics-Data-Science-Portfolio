# -*- coding: utf-8 -*-
"""abm_optimizado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pRXtZZPr1qXBA-YOJRdDL_LbGYX_JjHu

'''
Modelo económico basado en agentes
======================================================================

Este modelo simula un sistema económico regional con diferentes tipos de agentes:
- Regiones con características geográficas específicas
- Trabajadores con habilidades diferenciadas
- Corporaciones con capacidades tecnológicas
- Sectores económicos con dinámicas particulares
'''
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
import os
from collections import defaultdict
from enum import Enum
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
import warnings
warnings.filterwarnings('ignore')

# Configuración para reproducibilidad
SEED = 56
random.seed(SEED)
np.random.seed(SEED)

"""# =============================================
# MODELO ECONÓMICO REGIONAL OPTIMIZADO
# =============================================
'''
Modelo económico regional basado en agentes que simula el desarrollo económico
diferenciado entre las regiones de México, incluyendo procesos de producción,
innovación, coordinación económica y evolución de etapas.

Características principales:
- Diferenciación regional (7 tipos de regiones)
- Procesos de producción e innovación transparentes
- Coordinación económica entre agentes
- Evolución de etapas económicas
'''

# =============================================
# ENUMS Y ESTRUCTURAS DE DATOS
# =============================================
"""

class TipoRegion(Enum):
    """Tipos de regiones según clasificación geográfica y económica de México"""
    NOROESTE = "noroeste"          # Baja California, Baja California Sur, Chihuahua, Durango, Sinaloa, Sonora
    NORESTE = "noreste"            # Coahuila, Nuevo León, Tamaulipas
    OCCIDENTE = "occidente"        # Colima, Jalisco, Michoacán, Nayarit
    CENTRONORTE = "centronorte"    # Aguascalientes, Guanajuato, Querétaro, San Luis Potosí, Zacatecas
    ORIENTE = "oriente"            # Ciudad de México, México, Morelos, Tlaxcala, Hidalgo, Puebla
    SUROESTE = "suroeste"          # Chiapas, Guerrero, Oaxaca
    SURESTE = "sureste"            # Veracruz, Yucatán, Tabasco, Quintana Roo, Campeche

class TipoSector(Enum):
    """Categorías de sectores económicos"""
    PRIMARIO_BAJO = "primario_bajo"
    PRIMARIO_ALTO = "primario_alto"
    MANUFACTURA_BAJA = "manufactura_baja"
    MANUFACTURA_ALTA = "manufactura_alta"
    SERVICIOS_BAJOS = "servicios_bajos"
    SERVICIOS_INTERMEDIOS = "servicios_intermedios"
    SERVICIOS_AVANZADOS = "servicios_avanzados"
    TURISMO_MASIVO = "turismo_masivo"
    TURISMO_ESPECIALIZADO = "turismo_especializado"

class TipoRegionEconomica(Enum):
    """Tipología regional basada en evidencia empírica de desarrollo"""
    ATRAPADA = "Atrapada"         # Alta especialización, baja innovación, baja diversificación
    NO_ATRAPADA = "No_Atrapada"   # Alta innovación, diversificación y especialización moderada

class EtapaEconomica(Enum):
    """Etapas de desarrollo económico"""
    SUBSISTENCIA = "subsistencia"
    INDUSTRIALIZACION = "industrializacion"
    DIVERSIFICACION = "diversificacion"
    CONOCIMIENTO = "conocimiento"

@dataclass
class CaracteristicasRegionales:
    """Características específicas de cada tipo de región"""
    tipo: TipoRegion
    desarrollo_economico: float  # Nivel de desarrollo (0-1)
    cercania_eeuu: float  # Cercanía comercial con EE.UU. (0-1)
    riqueza_natural: float  # Riqueza natural y cultural (0-1)
    clima_aridez: float  # Nivel de aridez (0-1)
    rezago_social: float  # Nivel de rezago social (0-1)
    conectividad_transport: float  # Conectividad de transporte (0-1)
    inversion_extranjera: float  # Capacidad de atraer inversión extranjera (0-1)

@dataclass
class ParametrosTipologicos:
    """Parámetros específicos de cada tipología regional (basados en evidencia empírica)"""
    tipo_region_economica: TipoRegionEconomica

    # Parámetros tecnológicos y de innovación
    capacidad_tecnologica_base: float
    innovaciones_base: float
    tasa_innovacion_base: float

    # Parámetros sectoriales
    diversidad_base: float
    especializacion_base: float

    # Parámetros laborales
    brecha_calificacion_base: float

    # Parámetros adicionales
    empleo_total_base: float
    empleo_especializado_base: float
    eficiencia_regional_base: float

    # Parámetros de evolución
    tasa_decaimiento_tech: float
    inercia_tech: float
    factor_intensidad_laboral: float

"""# =============================================
# PARÁMETROS GLOBALES DEL MODELO
# =============================================
"""

class ParametrosGlobales:
    """Parámetros globales del modelo económico"""

    # Parámetros tecnológicos
    NIVEL_TECNOLOGICO_INICIAL = 0.12
    TASA_INNOVACION_BASE = 0.015
    COSTO_DESARROLLO_TECNOLOGICO = 0.25
    UMBRAL_INNOVACION_MINIMA = 0.05
    EFECTO_DERRAME_CONOCIMIENTO = 0.18
    ACELERACION_INNOVACION = 0.02

    # Parámetros de fuerza laboral
    HABILIDAD_INICIAL_TRABAJADORES = 0.28
    TASA_INVERSION_EDUCACION = 0.04
    TAMAÑO_POOL_TRABAJADORES = 3200000
    TASA_APRENDIZAJE = 0.06
    IMPACTO_TECNOLOGIA_EMPLEO = 0.5

    # Parámetros sectoriales
    VOLATILIDAD_EMPLEO_BASE = 0.06
    PENALIZACION_DESAJUSTE_HABILIDADES = 0.56
    DURACION_CICLO_ECONOMICO = 6

    # Parámetros de diversificación
    BONUS_DIVERSIDAD_INNOVACION = 0.1
    RESILIENCIA_SHOCK_DIVERSIDAD = 0.8
    DIVERSIDAD_MINIMA_CAMBIO = 0.4

    # Parámetros de política
    FACTOR_CAPACIDAD_ABSORCION = 0.15
    APOYO_POLITICA_INNOVACION = 0.1
    PROPENSION_ID_PRIVADO = 0.09
    PROBABILIDAD_ESCAPE_TRAMPA = 0.02

"""'''# =============================================
# PARÁMETROS DE TIPOLOGÍAS REGIONALES
# =============================================
'''
"""

class ConfiguracionTipologias:
    """Configuración de parámetros para diferentes tipologías regionales"""

    @staticmethod
    def obtener_parametros_tipologicos() -> Dict[TipoRegionEconomica, ParametrosTipologicos]:
        """Retorna parámetros específicos para cada tipología regional"""
        return {
            TipoRegionEconomica.ATRAPADA: ParametrosTipologicos(
                tipo_region_economica=TipoRegionEconomica.ATRAPADA,

                # Parámetros para regiones atrapadas
                capacidad_tecnologica_base=0.42,  # Media de regiones atrapadas
                innovaciones_base=0.04,  # Baja tasa de innovación
                tasa_innovacion_base=0.04,
                diversidad_base=0.47,  # Baja diversificación
                especializacion_base=0.53,  # Alta especialización
                brecha_calificacion_base=0.47,  # Baja brecha de calificación
                empleo_total_base=0.50,
                empleo_especializado_base=0.40,
                eficiencia_regional_base=0.70,
                tasa_decaimiento_tech=0.02,
                inercia_tech=0.95,
                factor_intensidad_laboral=3.0
            ),

            TipoRegionEconomica.NO_ATRAPADA: ParametrosTipologicos(
                tipo_region_economica=TipoRegionEconomica.NO_ATRAPADA,

                # Parámetros para regiones no atrapadas
                # Especialización moderada/intermedia
                capacidad_tecnologica_base=1.35,  # Alta capacidad tecnológica
                innovaciones_base=0.14,  # Alta tasa de innovación
                tasa_innovacion_base=0.14,
                diversidad_base=0.55,  # Diversificación moderada (equilibrada con especialización)
                especializacion_base=0.45,  # Especialización moderada/intermedia
                brecha_calificacion_base=0.72,  # Alta brecha de calificación
                empleo_total_base=0.55,
                empleo_especializado_base=0.45,
                eficiencia_regional_base=0.80,
                tasa_decaimiento_tech=0.01,
                inercia_tech=0.75,
                factor_intensidad_laboral=4.5
            )
        }

    @staticmethod
    def obtener_distribucion_tipologias() -> Dict[TipoRegionEconomica, float]:
        """Retorna la distribución inicial de tipologías regionales"""
        return {
            TipoRegionEconomica.ATRAPADA: 0.60,  # 75% del total (regiones atrapadas)
            TipoRegionEconomica.NO_ATRAPADA: 0.40  # 25% del total (regiones no atrapadas)
        }

    @staticmethod
    def crear_tipologia_regional(n_region: int, n_pasos: int) -> pd.DataFrame:
        """
        Crea tipología de regiones basada en evidencia empírica:
        - Regiones "Atrapadas": Alta especialización, baja innovación, baja diversificación
        - Regiones "No Atrapadas": Alta innovación, diversificación y especialización moderada
        """
        regiones = []

        # Obtener parámetros tipológicos
        parametros_tipologicos = ConfiguracionTipologias.obtener_parametros_tipologicos()

        for region_id in range(n_region):
            # Asignar tipo de región basado
            if region_id % 4 == 0 or region_id % 4 == 1 or region_id % 4 == 2:
                # Regiones "Atrapadas"
                tipo_region_economica = TipoRegionEconomica.ATRAPADA
                parametros = parametros_tipologicos[TipoRegionEconomica.ATRAPADA]
            else:
                # Regiones "No Atrapadas"
                tipo_region_economica = TipoRegionEconomica.NO_ATRAPADA
                parametros = parametros_tipologicos[TipoRegionEconomica.NO_ATRAPADA]

            # Generar datos para todos los pasos de tiempo
            for paso in range(n_pasos):
                region = {
                    'id_region': region_id,
                    'tipo_region_economica': tipo_region_economica.value,
                    'paso_tiempo': paso,

                    # Parámetros principales
                    'capacidad_tecnologica': max(0, parametros.capacidad_tecnologica_base + np.random.normal(0, 0.05)),
                    'innovaciones_realizadas': max(0, parametros.innovaciones_base + np.random.normal(0, 0.01)),
                    'diversidad_sectorial': max(0, parametros.diversidad_base + np.random.normal(0, 0.05)),
                    'especializacion': max(0, parametros.especializacion_base + np.random.normal(0, 0.03)),
                    'brecha_calificacion': max(0, parametros.brecha_calificacion_base + np.random.normal(0, 0.05)),

                    # Parámetros adicionales
                    'empleo_total': max(0, parametros.empleo_total_base + np.random.normal(0, 0.02)),
                    'empleo_especializado': max(0, parametros.empleo_especializado_base + np.random.normal(0, 0.03)),
                    'eficiencia_regional': max(0, parametros.eficiencia_regional_base + np.random.normal(0, 0.1)),

                    # Variables derivadas basadas en tipología
                    'tasa_innovacion': max(0, parametros.tasa_innovacion_base + np.random.normal(0, 0.01)),
                    'indice_diversificacion': max(0, parametros.diversidad_base + np.random.normal(0, 0.05)),
                    'indice_especializacion': max(0, parametros.especializacion_base + np.random.normal(0, 0.03)),
                    'nivel_tecnologico': max(0, parametros.capacidad_tecnologica_base + np.random.normal(0, 0.05))
                }

                regiones.append(region)

        return pd.DataFrame(regiones)

"""# =============================================
# PARÁMETROS DE AGLOMERACIÓN Y TRANSICIONES
# =============================================
"""

class ConfiguracionAglomeraciones:
    """Configuración de parámetros para diferentes tipos de aglomeraciones regionales"""

    @staticmethod
    def obtener_parametros_aglomeracion() -> Dict[str, Dict]:
        """Retorna parámetros para las aglomeraciones regionales"""
        return {
            'C1': {
                'descripcion': 'Baja diversidad-especialización',
                'especializacion_inicial': (0.80, 1),
                'intensidad_laboral_final': 4,
                'capacidad_tech_inicial': 0.1,
                'tasa_decaimiento_tech': 0.01,
                'nivel_diversidad': 'bajo',
                'inercia_tech': 0.95
            },
            'C2': {
                'descripcion': 'Media diversidad-especialización',
                'especializacion_inicial': 1.09,
                'nivel_diversidad': 'medio',
                'capacidad_tech_inicial': 0.1,
                'tasa_decaimiento_tech': 0.015,
                'factor_intensidad_laboral': 4.5,
                'inercia_tech': 0.85
            },
            'C3': {
                'descripcion': 'Alta diversidad-especialización',
                'especializacion_inicial': 1.3,
                'nivel_diversidad': 'medio-alto',
                'capacidad_tech_inicial': 0.15,
                'tasa_decaimiento_tech': 0.01,
                'factor_intensidad_laboral': 3.5,
                'inercia_tech': 0.75
            },
            'C4': {
                'descripcion': 'Sobre especialización',
                'especializacion_inicial': 1.5,
                'nivel_diversidad': 'medio-alto',
                'capacidad_tech_inicial': 0.15,
                'tasa_decaimiento_tech': 0.02,
                'factor_intensidad_laboral': 3,
                'nivel_especializacion': 'alto',
                'inercia_tech': 0.7
            }
        }

    @staticmethod
    def obtener_matrices_transicion() -> Dict[str, List[List[float]]]:
        """Retorna las matrices de transición de Markov para cada tipo de conglomerado"""
        return {
            'C1': [
                [0.97, 0.03, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.05, 0.95, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.70, 0.30, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.85, 0.15, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.97, 0.03, 0.00, 0.00, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.85, 0.10, 0.00, 0.00],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.15, 0.75, 0.10, 0.00],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.97, 0.03],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.95]   # Turismo_Especializado
            ],
            'C2': [
                [0.85, 0.10, 0.05, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.10, 0.80, 0.10, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.15, 0.75, 0.10, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.25, 0.65, 0.10, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.85, 0.10, 0.05, 0.00, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.20, 0.00, 0.00],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.15, 0.65, 0.20, 0.00],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.85, 0.15],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.95]   # Turismo_Especializado
            ],
            'C3': [
                [0.40, 0.15, 0.20, 0.10, 0.15, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.05, 0.35, 0.25, 0.15, 0.20, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.05, 0.35, 0.30, 0.25, 0.05, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.10, 0.40, 0.25, 0.10, 0.15, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.45, 0.30, 0.20, 0.05, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.45, 0.30, 0.15, 0.05],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.55, 0.25, 0.15],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.15, 0.00, 0.55, 0.25],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.10, 0.15, 0.70]   # Turismo_Especializado
            ],
            'C4': [
                [0.85, 0.05, 0.05, 0.00, 0.05, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.05, 0.80, 0.10, 0.00, 0.05, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.03, 0.85, 0.10, 0.02, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.05, 0.75, 0.10, 0.05, 0.05, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.85, 0.10, 0.05, 0.00, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.15, 0.05, 0.00],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.15, 0.05],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.05, 0.00, 0.75, 0.15],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.03, 0.05, 0.05, 0.87]   # Turismo_Especializado
            ]
        }

"""# =============================================
# CONFIGURACIÓN DE SECTORES ECONÓMICOS
# =============================================
"""

class ConfiguracionSectores:
    """Configuración detallada de los sectores económicos"""

    @staticmethod
    def obtener_sectores_economicos() -> Dict[str, str]:
        """Retorna la definición de sectores económicos"""
        return {
            1: "Agricultura Tradicional",
            2: "Agricultura Tecnificada",
            3: "Minería Básica",
            4: "Minería Tecnológica",
            5: "Manufactura Básica",
            6: "Manufactura Avanzada",
            7: "Servicios Básicos",
            8: "Servicios Financieros",
            9: "Servicios Tecnológicos",
            10: "Turismo Masivo",
            11: "Turismo Especializado"
        }

    @staticmethod
    def obtener_distribucion_sectores() -> Dict[str, float]:
        """Retorna la distribución inicial de sectores"""
        return {
            'Agricultura Tradicional': 0.103,
            'Agricultura Tecnificada': 0.025,
            'Minería Básica': 0.005,
            'Minería Tecnológica': 0.002,
            'Manufactura Básica': 0.15,
            'Manufactura Avanzada': 0.097,
            'Servicios Básicos': 0.402,
            'Servicios Financieros': 0.031,
            'Servicios Tecnológicos': 0.048,
            'Turismo Masivo': 0.068,
            'Turismo Especializado': 0.030
        }

    @staticmethod
    def obtener_tipos_sectores() -> Dict[str, List[int]]:
        """Mapea tipos de sector a IDs de sectores específicos"""
        return {
            'Primario_Bajo': [1, 3],
            'Primario_Alto': [2, 4],
            'Manufactura_Baja': [5],
            'Manufactura_Alta': [6],
            'Servicios_Bajos': [7],
            'Servicios_Intermedios': [8],
            'Servicios_Avanzados': [9],
            'Turismo_Masivo': [10],
            'Turismo_Especializado': [11]
        }

    @staticmethod
    def obtener_sectores_disponibles() -> List[str]:
        """Retorna lista de todos los sectores disponibles"""
        return [
            'Primario_Bajo', 'Primario_Alto', 'Manufactura_Baja', 'Manufactura_Alta',
            'Servicios_Bajos', 'Servicios_Intermedios', 'Servicios_Avanzados',
            'Turismo_Masivo', 'Turismo_Especializado'
        ]

    @staticmethod
    def obtener_parametros_sector(tipo_sector: str) -> Dict:
        """Retorna parámetros específicos para un tipo de sector"""
        parametros = {
            'Primario_Bajo': {
                'margen_rango': (0.25, 0.45),
                'inversion_tec': 0.05,
                'volatilidad': 0.35,
                'requisitos_habilidades': (0.3, 0.5),
                'tasa_empleo': (0.7, 0.8),
                'inversion_capacitacion': 0.05,
                'capacidad_innovacion': 0.1,
                'intensidad_conocimiento': 0.2,
                'enlaces_sectoriales': 0.3,
                'coeficiente_especializacion': 0.75,
                'productividad': 3.8,  # USD/hora
                'rango_productos': (3, 7),
                'empleo_maximo': 1
            },
            'Primario_Alto': {
                'margen_rango': (0.35, 0.55),
                'inversion_tec': 0.25,
                'volatilidad': 0.25,
                'requisitos_habilidades': (0.5, 0.7),
                'tasa_empleo': (0.75, 0.85),
                'inversion_capacitacion': 0.15,
                'capacidad_innovacion': 0.3,
                'intensidad_conocimiento': 0.4,
                'enlaces_sectoriales': 0.5,
                'coeficiente_especializacion': 0.66,
                'productividad': 9.2,
                'rango_productos': (5, 9),
                'empleo_maximo': 1
            },
            'Manufactura_Baja': {
                'margen_rango': (0.15, 0.3),
                'inversion_tec': 0.2,
                'volatilidad': 0.2,
                'requisitos_habilidades': (0.4, 0.6),
                'tasa_empleo': (0.7, 0.85),
                'inversion_capacitacion': 0.1,
                'capacidad_innovacion': 0.25,
                'intensidad_conocimiento': 0.35,
                'enlaces_sectoriales': 0.6,
                'coeficiente_especializacion': 0.58,
                'productividad': 8.7,
                'rango_productos': (6, 10),
                'empleo_maximo': 1
            },
            'Manufactura_Alta': {
                'margen_rango': (0.25, 0.4),
                'inversion_tec': 0.4,
                'volatilidad': 0.15,
                'requisitos_habilidades': (0.6, 0.8),
                'tasa_empleo': (0.8, 0.9),
                'inversion_capacitacion': 0.2,
                'capacidad_innovacion': 0.5,
                'intensidad_conocimiento': 0.7,
                'enlaces_sectoriales': 0.8,
                'coeficiente_especializacion': 0.45,
                'productividad': 32.5,
                'rango_productos': (8, 18),
                'empleo_maximo': 1
            },
            'Servicios_Bajos': {
                'margen_rango': (0.2, 0.4),
                'inversion_tec': 0.1,
                'volatilidad': 0.15,
                'requisitos_habilidades': (0.3, 0.5),
                'tasa_empleo': (0.75, 0.9),
                'inversion_capacitacion': 0.08,
                'capacidad_innovacion': 0.15,
                'intensidad_conocimiento': 0.3,
                'enlaces_sectoriales': 0.4,
                'coeficiente_especializacion': 0.35,
                'productividad': 5.2,
                'rango_productos': (4, 8),
                'empleo_maximo': 1
            },
            'Servicios_Intermedios': {
                'margen_rango': (0.3, 0.5),
                'inversion_tec': 0.25,
                'volatilidad': 0.1,
                'requisitos_habilidades': (0.5, 0.7),
                'tasa_empleo': (0.8, 0.95),
                'inversion_capacitacion': 0.15,
                'capacidad_innovacion': 0.35,
                'intensidad_conocimiento': 0.5,
                'enlaces_sectoriales': 0.7,
                'coeficiente_especializacion': 0.25,
                'productividad': 38.7,
                'rango_productos': (7, 11),
                'empleo_maximo': 1
            },
            'Servicios_Avanzados': {
                'margen_rango': (0.4, 0.65),
                'inversion_tec': 0.45,
                'volatilidad': 0.1,
                'requisitos_habilidades': (0.7, 0.9),
                'tasa_empleo': (0.85, 0.8),
                'inversion_capacitacion': 0.25,
                'capacidad_innovacion': 0.7,
                'intensidad_conocimiento': 0.9,
                'enlaces_sectoriales': 0.9,
                'coeficiente_especializacion': 0.18,
                'productividad': 48.9,
                'rango_productos': (10, 21),
                'empleo_maximo': 1
            },
            'Turismo_Masivo': {
                'margen_rango': (0.2, 0.5),
                'inversion_tec': 0.05,
                'volatilidad': 0.4,
                'requisitos_habilidades': (0.2, 0.4),
                'tasa_empleo': (0.6, 0.9),
                'inversion_capacitacion': 0.03,
                'capacidad_innovacion': 0.15,
                'intensidad_conocimiento': 0.2,
                'enlaces_sectoriales': 0.3,
                'coeficiente_especializacion': 0.85,
                'productividad': 6.5,
                'rango_productos': (3, 7),
                'empleo_maximo': 1
            },
            'Turismo_Especializado': {
                'margen_rango': (0.3, 0.6),
                'inversion_tec': 0.15,
                'volatilidad': 0.3,
                'requisitos_habilidades': (0.4, 0.6),
                'tasa_empleo': (0.7, 0.9),
                'inversion_capacitacion': 0.1,
                'capacidad_innovacion': 0.3,
                'intensidad_conocimiento': 0.4,
                'enlaces_sectoriales': 0.5,
                'coeficiente_especializacion': 0.65,
                'productividad': 12.8,
                'rango_productos': (5, 9),
                'empleo_maximo': 1
            }
        }
        return parametros.get(tipo_sector, {})

    @staticmethod
    def obtener_factores_sectoriales() -> Tuple[Dict[str, float], Dict[str, float]]:
        """Retorna factores de innovación y productividad por sector (simulados)"""
        # Estos son valores simulados. En un modelo real, vendrían de datos o investigación.
        factores_innovacion = {
            'Agricultura Tradicional': 0.4,
            'Agricultura Tecnificada': 0.7,
            'Minería Básica': 0.3,
            'Minería Tecnológica': 0.8,
            'Manufactura Básica': 0.6,
            'Manufactura Avanzada': 0.9,
            'Servicios Básicos': 0.5,
            'Servicios Financieros': 0.8,
            'Servicios Tecnológicos': 1.0,
            'Turismo Masivo': 0.4,
            'Turismo Especializado': 0.6
        }

        factores_productividad = {
            'Agricultura Tradicional': 0.5,
            'Agricultura Tecnificada': 0.8,
            'Minería Básica': 0.4,
            'Minería Tecnológica': 0.9,
            'Manufactura Básica': 0.7,
            'Manufactura Avanzada': 1.0,
            'Servicios Básicos': 0.6,
            'Servicios Financieros': 0.9,
            'Servicios Tecnológicos': 1.1,
            'Turismo Masivo': 0.5,
            'Turismo Especializado': 0.7
        }

        return factores_innovacion, factores_productividad

"""# =============================================
# CLASES DE AGENTES DEL MODELO
# =============================================
"""

class Producto:
    """Representa un producto o servicio generado en una región"""

    def __init__(self, tipo_sector: str, id_producto: int):
        self.id = id_producto
        self.tipo_sector = tipo_sector
        parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)

        self.ingresos = np.random.uniform(*parametros['rango_productos'])
        self.costos = np.random.uniform(0.4, 0.8) * self.ingresos
        self.produccion = np.random.uniform(3, 16)
        self.intensidad_tecnologica = np.random.uniform(0.1, parametros['intensidad_conocimiento'])
        self.habilidad_requerida = np.random.uniform(*parametros['requisitos_habilidades'])
        self.id_sector = np.random.choice(ConfiguracionSectores.obtener_tipos_sectores()[tipo_sector])

    def calcular_margen(self) -> float:
        """Calcula el margen de ganancia del producto"""
        return (self.ingresos - self.costos) / self.ingresos

class Trabajador:
    """Representa un trabajador con habilidades específicas"""

    def __init__(self, tipo_sector: Optional[str] = None):
        if tipo_sector:
            parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
            rango_requisitos = parametros['requisitos_habilidades']
            self.habilidad = np.random.uniform(
                max(0.1, rango_requisitos[0] - 0.2),
                min(1.0, rango_requisitos[1] + 0.1)
            )
            self.habilidad_especializada = random.uniform(0.5, 1.1)
        else:
            self.habilidad = np.random.uniform(0.1, 0.6)
            self.habilidad_especializada = 0.0

        self.empleado = False
        self.id_region = None
        self.region = None
        self.tipo_sector = tipo_sector
        self.experiencia = 0
        self.salario = 0.0
        self.productividad = 0.0

    def mejorar_habilidades(self, inversion_capacitacion: float, exposicion_tecnologica: float):
        """Mejora las habilidades del trabajador a través de capacitación y exposición tecnológica"""
        efecto_capacitacion = 0.4 * (1 - np.exp(-1.5 * inversion_capacitacion))
        efecto_tecnologia = 0.5 * (1 - np.exp(-1.0 * exposicion_tecnologica))
        factor_individual = np.random.uniform(0.7, 1.0)
        factor_experiencia = 1 + np.log1p(self.experiencia) * 0.05

        ganancia_habilidad = (efecto_capacitacion + efecto_tecnologia) * factor_individual * factor_experiencia * ParametrosGlobales.TASA_APRENDIZAJE * 0.66
        self.habilidad = np.clip(self.habilidad + ganancia_habilidad, 0.1, 1.0)

        # Penalización por cambios tecnológicos rápidos
        if hasattr(self, 'region') and self.region is not None:
            if hasattr(self.region, 'capacidad_tecnologica') and hasattr(self.region, 'historial_capacidad_tecnologica'):
                if len(self.region.historial_capacidad_tecnologica) > 1:
                    tasa_cambio_tec = abs(self.region.capacidad_tecnologica - self.region.historial_capacidad_tecnologica[-2])
                    if tasa_cambio_tec > 0.02:
                        self.habilidad = max(0.1, self.habilidad * 0.98)

class FuerzaLaboral:
    """Representa la fuerza laboral de una región en un sector específico"""

    def __init__(self, tipo_sector: str, id_region: int):
        self.parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
        self.trabajadores = []
        self.tipo_sector = tipo_sector
        self.id_region = id_region
        self.region = None
        self.inversion_capacitacion = self.parametros['inversion_capacitacion'] * 0.7
        self.requisitos_habilidades = np.random.uniform(*self.parametros['requisitos_habilidades'])
        self.habilidad_especializada_minima = 0.6
        self.habilidad_promedio = 0.0
        self.habilidad_especializada_promedio = 0.0
        self.brecha_calificacion = self.requisitos_habilidades
        self.decadencia_experiencia = 0.01

    def actualizar_metricas(self):
        """Actualiza las métricas de la fuerza laboral"""
        capacidad_tecnologica = 0.12
        if hasattr(self, 'region') and self.region is not None:
            capacidad_tecnologica = getattr(self.region, 'capacidad_tecnologica', capacidad_tecnologica)
        factor_tec = 1 + capacidad_tecnologica

        # Los requisitos crecen con la capacidad tecnológica, pero con saturación
        requisito_base = np.random.uniform(*self.parametros['requisitos_habilidades'])
        self.requisitos_habilidades = np.clip(
            requisito_base * (1 + 0.75 * capacidad_tecnologica),
            self.parametros['requisitos_habilidades'][0],
            self.parametros['requisitos_habilidades'][1] * 1.5
        )

        if self.trabajadores:
            self.habilidad_promedio = np.mean([t.habilidad for t in self.trabajadores])
            self.habilidad_especializada_promedio = np.mean([t.habilidad_especializada for t in self.trabajadores])
            brecha = max(0, self.requisitos_habilidades - self.habilidad_promedio)
            # Brecha amplificada por baja absorción
            self.brecha_calificacion = brecha * (1 + 0.4 * np.random.uniform(-0.5, 0.5) * self.parametros['volatilidad'])
        else:
            self.habilidad_promedio = 0.0
            self.habilidad_especializada_promedio = 0.0
            self.brecha_calificacion = self.requisitos_habilidades

    def contratar_trabajadores(self, numero_trabajadores: int, pool_trabajadores: List[Trabajador]) -> int:
        """Contrata trabajadores del pool disponible"""
        if numero_trabajadores <= 0:
            return 0

        contratados = 0
        trabajadores_disponibles = [t for t in pool_trabajadores if not t.empleado]

        # Priorizar especializados, pero con costo de adaptación
        trabajadores_especializados = [t for t in trabajadores_disponibles if t.tipo_sector == self.tipo_sector]
        for trabajador in trabajadores_especializados[:min(numero_trabajadores - contratados, len(trabajadores_especializados))]:
            trabajador.empleado = True
            trabajador.id_region = self.id_region
            trabajador.region = self.region
            trabajador.habilidad = max(trabajador.habilidad * 0.9, trabajador.habilidad - 0.05)  # Pérdida en transición
            self.trabajadores.append(trabajador)
            contratados += 1

        # Contratar trabajadores generales si es necesario
        restantes = numero_trabajadores - contratados
        if restantes > 0:
            trabajadores_generales = [t for t in trabajadores_disponibles if t not in trabajadores_especializados]
            for trabajador in trabajadores_generales[:min(restantes, len(trabajadores_generales))]:
                trabajador.empleado = True
                trabajador.id_region = self.id_region
                trabajador.region = self.region
                trabajador.tipo_sector = self.tipo_sector
                trabajador.habilidad = max(0.1, trabajador.habilidad * 0.7)  # Reset parcial de habilidad
                self.trabajadores.append(trabajador)
                contratados += 1

        self.actualizar_metricas()
        return contratados

    def despedir_trabajadores(self, numero_trabajadores: int) -> int:
        """Despide trabajadores (los de menor habilidad primero)"""
        if not self.trabajadores or numero_trabajadores <= 0:
            return 0

        self.trabajadores.sort(key=lambda t: t.habilidad + t.habilidad_especializada)
        despedidos = 0
        for _ in range(min(numero_trabajadores, len(self.trabajadores))):
            trabajador = self.trabajadores.pop(0)
            trabajador.empleado = False
            trabajador.id_region = None
            trabajador.region = None
            despedidos += 1

        self.actualizar_metricas()
        return despedidos

    def ajustar_fuerza_laboral(self, trabajadores_requeridos: int, pool_trabajadores: List[Trabajador]):
        """Ajusta el tamaño de la fuerza laboral"""
        actual = len(self.trabajadores)
        if actual < trabajadores_requeridos:
            self.contratar_trabajadores(trabajadores_requeridos - actual, pool_trabajadores)
        elif actual > trabajadores_requeridos:
            self.despedir_trabajadores(actual - trabajadores_requeridos)

    def evaluar_trabajadores(self) -> int:
        """Evalúar y despedir trabajadores con habilidades muy por debajo del promedio"""
        umbral = self.requisitos_habilidades * 0.65
        a_despedir = [t for t in self.trabajadores if t.habilidad < umbral]
        for trabajador in a_despedir:
            self.trabajadores.remove(trabajador)
            trabajador.empleado = False
            trabajador.id_region = None
            trabajador.region = None
        self.actualizar_metricas()
        return len(a_despedir)

class Corporacion:
    """Representa una corporación con capacidad productiva y tecnológica"""

    def __init__(self, id_corporacion: int, tipo_sector: str, id_region: int):
        self.id = id_corporacion
        self.tipo_sector = tipo_sector
        self.id_region = id_region
        self.region = None

        # Parámetros específicos del sector (primero)
        self.parametros_sector = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
        self.inversion_tecnologia_objetivo = self.parametros_sector['inversion_tec']

        # Capacidades tecnológicas
        self.capacidad_tecnologica = ParametrosGlobales.NIVEL_TECNOLOGICO_INICIAL
        self.inversion_id = 0.0
        self.productos = []
        self.capacidad_produccion = np.random.uniform(50, 200)
        self.utilidades = 0.0
        self.margen_beneficio = 0.0
        self.volatilidad_mercado = self._obtener_volatilidad_sector()

    def _obtener_volatilidad_sector(self) -> float:
        """Obtiene la volatilidad específica del sector"""
        return self.parametros_sector['volatilidad']

    def producir(self, demanda_mercado: float = 1.0) -> Dict[str, float]:
        """Ejecuta el proceso de producción"""
        # Calcular nivel de producción basado en capacidad y demanda
        factor_demanda = min(1.0, demanda_mercado / self.capacidad_produccion)
        produccion_real = self.capacidad_produccion * factor_demanda

        # Calcular productividad basada en tecnología y trabajadores
        if self.region and hasattr(self.region, 'fuerzas_laborales'):
            fuerza_laboral = self.region.fuerzas_laborales.get(self.tipo_sector)
            if fuerza_laboral:
                productividad_trabajadores = fuerza_laboral.habilidad_promedio
            else:
                productividad_trabajadores = 0.5
        else:
            productividad_trabajadores = 0.5

        factor_tecnologico = 1 + self.capacidad_tecnologica * 0.3
        factor_productividad = productividad_trabajadores * 0.6 + factor_tecnologico * 0.4

        produccion_ajustada = produccion_real * factor_productividad

        # Calcular ingresos y costos
        precio_unitario = self.parametros_sector['productividad'] / 10  # Simplificación
        ingresos_totales = produccion_ajustada * precio_unitario
        costos_operativos = produccion_ajustada * precio_unitario * 0.6  # 40% margen

        self.utilidades = ingresos_totales - costos_operativos
        self.margen_beneficio = (ingresos_totales - costos_operativos) / ingresos_totales if ingresos_totales > 0 else 0

        return {
            'produccion': produccion_ajustada,
            'ingresos': ingresos_totales,
            'costos': costos_operativos,
            'utilidades': self.utilidades,
            'margen': self.margen_beneficio
        }

    def innovar(self, conocimiento_externo: float = 0.0) -> bool:
        """Ejecuta proceso de innovación"""
        # Capacidad de innovación base del sector
        capacidad_base = self.parametros_sector['capacidad_innovacion']

        # Factores que afectan la innovación
        factor_utilidades = max(0, self.utilidades / 1000)  # Normalizar
        factor_conocimiento = conocimiento_externo * ParametrosGlobales.FACTOR_CAPACIDAD_ABSORCION
        factor_educacion = getattr(self.region, 'inversion_educacion', 0.1) if self.region else 0.1

        # Probabilidad de innovación
        probabilidad_innovacion = (
            ParametrosGlobales.TASA_INNOVACION_BASE *
            capacidad_base *
            (1 + factor_utilidades) *
            (1 + factor_conocimiento) *
            (1 + factor_educacion)
        )

        # Ejecutar innovación
        if random.random() < probabilidad_innovacion:
            # Mejora tecnológica
            mejora_tecnologica = np.random.uniform(0.01, 0.05) * capacidad_base
            self.capacidad_tecnologica = min(1.0, self.capacidad_tecnologica + mejora_tecnologica)

            # Crear nuevo producto
            nuevo_producto = Producto(self.tipo_sector, len(self.productos))
            self.productos.append(nuevo_producto)

            return True
        return False

class Region:
    """Representa una región económica con características geográficas específicas"""

    def __init__(self, id_region: int, tipo_region: TipoRegion):
        self.id = id_region
        self.tipo_region = tipo_region
        self.caracteristicas = self._configurar_caracteristicas_regionales()

        # Estado económico
        self.capacidad_tecnologica = ParametrosGlobales.NIVEL_TECNOLOGICO_INICIAL
        self.historial_capacidad_tecnologica = [self.capacidad_tecnologica]
        self.etapa_economica = EtapaEconomica.SUBSISTENCIA
        self.diversidad_sectorial = 0.5
        self.productividad_promedio = 0.0

        # Estructura económica
        self.fuerzas_laborales: Dict[str, FuerzaLaboral] = {}
        self.corporaciones: List[Corporacion] = []
        self.sectores_activos = []
        self.pool_trabajadores = []

        # Métricas de coordinación
        self.coordinacion_inter_sectorial = 0.5
        self.flujos_comerciales = 0.0
        self.inversion_extranjera_recibida = 0.0

        # Parámetros de aglomeración y transición
        self.tipo_aglomeracion = self._determinar_tipo_aglomeracion()
        self.parametros_aglomeracion = ConfiguracionAglomeraciones.obtener_parametros_aglomeracion()[self.tipo_aglomeracion]
        self.matriz_transicion = ConfiguracionAglomeraciones.obtener_matrices_transicion()[self.tipo_aglomeracion]
        self.factores_innovacion, self.factores_productividad = ConfiguracionSectores.obtener_factores_sectoriales()

        # Inicializar estructura económica
        self._inicializar_estructura_economica()

    def _configurar_caracteristicas_regionales(self) -> CaracteristicasRegionales:
        """Configura las características específicas según el tipo de región"""
        if self.tipo_region == TipoRegion.NORESTE:
            # Noreste: Mejor economía por Nuevo León, industrializado
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.85,  # Alto por Nuevo León
                cercania_eeuu=0.95,        # Muy alto (frontera)
                riqueza_natural=0.4,
                clima_aridez=0.6,
                rezago_social=0.15,        # Muy bajo
                conectividad_transport=0.85, # Alto
                inversion_extranjera=0.8   # Alto
            )
        elif self.tipo_region == TipoRegion.NOROESTE:
            # Noroeste: Fronterizo, clima árido, mejor economía regional
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.7,
                cercania_eeuu=0.9,
                riqueza_natural=0.3,
                clima_aridez=0.8,
                rezago_social=0.25,
                conectividad_transport=0.75,
                inversion_extranjera=0.75
            )
        elif self.tipo_region == TipoRegion.OCCIDENTE:
            # Occidente: Mejor por Jalisco, variada
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.7,   # Mejorado por Jalisco
                cercania_eeuu=0.6,
                riqueza_natural=0.7,       # Rica en recursos
                clima_aridez=0.4,
                rezago_social=0.4,         # Moderado
                conectividad_transport=0.75,
                inversion_extranjera=0.7
            )
        elif self.tipo_region == TipoRegion.CENTRONORTE:
            # Centronorte: Intermedio, agricola, manufactura básica
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.65,
                cercania_eeuu=0.7,
                riqueza_natural=0.5,
                clima_aridez=0.5,
                rezago_social=0.45,
                conectividad_transport=0.7,
                inversion_extranjera=0.65
            )
        elif self.tipo_region == TipoRegion.ORIENTE:
            # Oriente: CDMX incluida, mix urbano-rural
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.8,   # Alto por CDMX
                cercania_eeuu=0.65,
                riqueza_natural=0.4,
                clima_aridez=0.3,
                rezago_social=0.35,         # Menor por CDMX
                conectividad_transport=0.9, # Muy alto
                inversion_extranjera=0.75
            )
        elif self.tipo_region == TipoRegion.SURESTE:
            # Sureste: Rica en recursos pero bajo desarrollo
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.35,  # Bajo pero mejor que suroeste
                cercania_eeuu=0.4,
                riqueza_natural=0.85,      # Muy rica
                clima_aridez=0.2,
                rezago_social=0.75,        # Alto
                conectividad_transport=0.4, # Bajo
                inversion_extranjera=0.25  # Bajo
            )
        else:  # SUROESTE
            # Suroeste: Mayor rezago social
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.2,   # Muy bajo
                cercania_eeuu=0.25,
                riqueza_natural=0.8,
                clima_aridez=0.1,
                rezago_social=0.9,         # Muy alto
                conectividad_transport=0.25, # Muy bajo
                inversion_extranjera=0.15  # Muy bajo
            )

    def _determinar_tipo_aglomeracion(self) -> str:
        """Determina el tipo de aglomeración regional basado en características"""
        # Clasificar por nivel de desarrollo y diversidad sectorial
        desarrollo = self.caracteristicas.desarrollo_economico
        diversidad_esperada = 0.5  # Base para comparación

        if desarrollo < 0.4:
            return 'C1'  # Baja diversidad-especialización
        elif desarrollo < 0.65:
            return 'C2'  # Media diversidad-especialización
        elif desarrollo < 0.8:
            return 'C3'  # Alta diversidad-especialización
        else:
            return 'C4'  # Sobre especialización

    def aplicar_transicion_sectorial(self, tipo_sector_actual: str, paso_tiempo: int):
        """Aplica la transición de Markov a los sectores según el tipo de aglomeración"""
        # Mapear tipo de sector a índice en la matriz
        sectores_orden = ['Primario_Bajo', 'Primario_Alto', 'Manufactura_Baja',
                         'Manufactura_Alta', 'Servicios_Bajos', 'Servicios_Intermedios',
                         'Servicios_Avanzados', 'Turismo_Masivo', 'Turismo_Especializado']

        if tipo_sector_actual not in sectores_orden:
            return tipo_sector_actual

        idx_actual = sectores_orden.index(tipo_sector_actual)
        probabilidades = self.matriz_transicion[idx_actual]

        # Seleccionar nuevo sector basado en probabilidades
        nuevo_idx = np.random.choice(len(probabilidades), p=probabilidades)
        nuevo_sector = sectores_orden[nuevo_idx]

        return nuevo_sector

    def aplicar_factores_sectoriales(self, tipo_sector: str, valor_base: float, tipo_factor: str = 'innovacion'):
        """Aplica factores de innovación o productividad específicos del sector"""
        factores = self.factores_innovacion if tipo_factor == 'innovacion' else self.factores_productividad

        # Mapear el tipo de sector al nombre completo en el diccionario
        sectores_mapping = {
            'Primario_Bajo': 'Agricultura Tradicional',
            'Primario_Alto': 'Agricultura Tecnificada',
            'Manufactura_Baja': 'Manufactura Básica',
            'Manufactura_Alta': 'Manufactura Avanzada',
            'Servicios_Bajos': 'Servicios Básicos',
            'Servicios_Intermedios': 'Servicios Financieros',
            'Servicios_Avanzados': 'Servicios Tecnológicos',
            'Turismo_Masivo': 'Turismo Masivo',
            'Turismo_Especializado': 'Turismo Especializado'
        }

        nombre_sector = sectores_mapping.get(tipo_sector, 'Servicios Básicos')
        factor = factores.get(nombre_sector, 0.5)

        return valor_base * factor

    def _inicializar_estructura_economica(self):
        """Inicializa la estructura económica de la región"""
        # Seleccionar sectores basados en características regionales
        sectores_recomendados = self._seleccionar_sectores_regionales()

        for tipo_sector in sectores_recomendados:
            # Crear fuerza laboral
            fuerza_laboral = FuerzaLaboral(tipo_sector, self.id)
            fuerza_laboral.region = self
            self.fuerzas_laborales[tipo_sector] = fuerza_laboral

            # Crear corporaciones
            num_corporaciones = np.random.randint(2, 6)
            for _ in range(num_corporaciones):
                corporacion = Corporacion(len(self.corporaciones), tipo_sector, self.id)
                corporacion.region = self
                self.corporaciones.append(corporacion)

            self.sectores_activos.append(tipo_sector)

        # Crear pool de trabajadores inicial
        self._crear_pool_trabajadores()

    def _seleccionar_sectores_regionales(self) -> List[str]:
        """Selecciona sectores apropiados según las características regionales"""
        sectores_disponibles = ConfiguracionSectores.obtener_sectores_disponibles()
        sectores_seleccionados = []

        # Lógica de selección basada en características regionales actualizadas
        if self.tipo_region == TipoRegion.NORESTE:
            # Noreste: Alta tecnología, manufactura avanzada (Nuevo León)
            sectores_preferidos = ['Manufactura_Alta', 'Servicios_Avanzados', 'Servicios_Intermedios']
        elif self.tipo_region == TipoRegion.NOROESTE:
            # Noroeste: Manufactura fronteriza, tecnología, servicios
            sectores_preferidos = ['Manufactura_Alta', 'Minería_Tecnológica', 'Servicios_Intermedios']
        elif self.tipo_region == TipoRegion.OCCIDENTE:
            # Occidente: Manufactura, turismo, agroindustria (influencia de Jalisco)
            sectores_preferidos = ['Manufactura_Intermedia', 'Turismo_Especializado', 'Primario_Alto']
        elif self.tipo_region == TipoRegion.CENTRONORTE:
            # Centronorte: Manufactura, servicios, agroindustria
            sectores_preferidos = ['Manufactura_Baja', 'Primario_Alto', 'Servicios_Intermedios']
        elif self.tipo_region == TipoRegion.ORIENTE:
            # Oriente: Servicios, manufactura, turismo (CDMX)
            sectores_preferidos = ['Servicios_Avanzados', 'Servicios_Intermedios', 'Turismo_Especializado']
        elif self.tipo_region == TipoRegion.SURESTE:
            # Sureste: Primario, turismo masivo, algunos servicios
            sectores_preferidos = ['Primario_Alto', 'Turismo_Masivo', 'Servicios_Bajos']
        else:  # SUROESTE
            # Suroeste: Principalmente primario, poco diversificado
            sectores_preferidos = ['Primario_Bajo', 'Primario_Alto', 'Turismo_Masivo']

        # Seleccionar sectores preferidos que existan
        for sector in sectores_preferidos:
            if sector in sectores_disponibles:
                sectores_seleccionados.append(sector)

        # Asegurar al menos 3 sectores
        while len(sectores_seleccionados) < 3 and sectores_disponibles:
            sector = random.choice(sectores_disponibles)
            if sector not in sectores_seleccionados:
                sectores_seleccionados.append(sector)

        return sectores_seleccionados[:5]  # Máximo 5 sectores por región

    def _crear_pool_trabajadores(self):
        """Crea el pool inicial de trabajadores para la región"""
        num_trabajadores_por_sector = max(100, int(ParametrosGlobales.TAMAÑO_POOL_TRABAJADORES / len(self.sectores_activos) / 32))

        for tipo_sector in self.sectores_activos:
            for _ in range(num_trabajadores_por_sector):
                trabajador = Trabajador(tipo_sector)
                trabajador.id_region = self.id
                trabajador.region = self
                self.pool_trabajadores.append(trabajador)

    def ejecutar_coordinacion_economica(self) -> Dict[str, float]:
        """Ejecuta los procesos de coordinación económica entre agentes"""
        metricas_coordinacion = {
            'empleo_total': 0,
            'empleo_especializado': 0,
            'coordinacion_promedio': 0.0,
            'flujos_internos': 0.0,
            'eficiencia_asignacion': 0.0
        }

        total_coordinacion = 0
        flujos_internos = 0
        empleados_especializados = 0
        empleo_total = 0

        for tipo_sector, fuerza_laboral in self.fuerzas_laborales.items():
            # Calcular demanda de trabajadores
            demanda_trabajadores = self._calcular_demanda_trabajadores(tipo_sector)
            fuerza_laboral.ajustar_fuerza_laboral(demanda_trabajadores, self.pool_trabajadores)

            # Evaluar trabajadores (despedir los menos capaces)
            despedidos = fuerza_laboral.evaluar_trabajadores()

            # Calcular métricas
            empleo_en_sector = len(fuerza_laboral.trabajadores)
            empleo_total += empleo_en_sector
            empleados_especializados += sum(1 for t in fuerza_laboral.trabajadores if t.tipo_sector == tipo_sector)

            # Coordinación intra-sectorial
            coordinacion_sector = min(1.0, fuerza_laboral.habilidad_promedio / fuerza_laboral.requisitos_habilidades)
            total_coordinacion += coordinacion_sector * empleo_en_sector

        # Calcular flujos internos (intercambio entre sectores)
        for corporacion in self.corporaciones:
            resultado_produccion = corporacion.producir()
            flujos_internos += resultado_produccion['ingresos'] * 0.1  # 10% de flujo interno

        # Asignar métricas
        metricas_coordinacion['empleo_total'] = empleo_total
        metricas_coordinacion['empleo_especializado'] = empleados_especializados
        metricas_coordinacion['coordinacion_promedio'] = total_coordinacion / max(1, empleo_total)
        metricas_coordinacion['flujos_internos'] = flujos_internos
        metricas_coordinacion['eficiencia_asignacion'] = empleados_especializados / max(1, empleo_total)

        return metricas_coordinacion

    def _calcular_demanda_trabajadores(self, tipo_sector: str) -> int:
        """Calcula la demanda de trabajadores para un sector específico"""
        corporaciones_sector = [c for c in self.corporaciones if c.tipo_sector == tipo_sector]
        if not corporaciones_sector:
            return 0

        # Capacidad productiva total del sector
        capacidad_total = sum(c.capacidad_produccion for c in corporaciones_sector)

        # Requerimientos de trabajadores basados en capacidad y tecnología
        parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
        factor_tecnologico = 1 - (self.capacidad_tecnologica * 0.3)  # Menos trabajadores con más tecnología
        requerimiento_base = capacidad_total / 50  # Trabajador por cada 50 unidades de capacidad
        trabajadores_requeridos = int(requerimiento_base * factor_tecnologico)

        return max(10, trabajadores_requeridos)  # Mínimo 10 trabajadores

    def evolucionar_etapa_economica(self):
        """Evoluciona la región de una etapa económica a otra"""
        # Determinar nueva etapa basada en métricas
        diversidad_actual = self._calcular_diversidad_sectorial()
        productividad_actual = self._calcular_productividad_promedio()
        capacidad_tec_actual = self.capacidad_tecnologica

        if self.etapa_economica == EtapaEconomica.SUBSISTENCIA:
            if diversidad_actual > 0.6 and productividad_actual > 0.4:
                self.etapa_economica = EtapaEconomica.INDUSTRIALIZACION
        elif self.etapa_economica == EtapaEconomica.INDUSTRIALIZACION:
            if diversidad_actual > 0.7 and capacidad_tec_actual > 0.3:
                self.etapa_economica = EtapaEconomica.DIVERSIFICACION
        elif self.etapa_economica == EtapaEconomica.DIVERSIFICACION:
            if diversidad_actual > 0.8 and capacidad_tec_actual > 0.5:
                self.etapa_economica = EtapaEconomica.CONOCIMIENTO

    def _calcular_diversidad_sectorial(self) -> float:
        """Calcula el índice de diversidad sectorial"""
        if not self.sectores_activos:
            return 0.0

        num_sectores = len(self.sectores_activos)
        # Índice simplificado de diversidad (proporción de sectores activos)
        diversidad = min(1.0, num_sectores / 8)  # Máximo 8 sectores para diversidad plena
        return diversidad

    def _calcular_productividad_promedio(self) -> float:
        """Calcula la productividad promedio de la región con factores sectoriales"""
        if not self.fuerzas_laborales:
            return 0.0

        productividades = []
        for tipo_sector, fuerza_laboral in self.fuerzas_laborales.items():
            if fuerza_laboral.trabajadores:
                promedio_habilidad = fuerza_laboral.habilidad_promedio
                parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)

                # Usar factor de productividad específico del sector
                factor_productividad_sector = self.aplicar_factores_sectoriales(tipo_sector, parametros['productividad'] / 50, 'productividad')

                # Ajustar por parámetros de aglomeración
                if 'factor_intensidad_laboral' in self.parametros_aglomeracion:
                    factor_intensidad = self.parametros_aglomeracion['factor_intensidad_laboral'] / 4
                    factor_productividad_sector *= factor_intensidad

                productividad_sector = promedio_habilidad * factor_productividad_sector
                productividades.append(productividad_sector)

        return np.mean(productividades) if productividades else 0.0

    def procesar_innovacion_regional(self) -> int:
        """Procesa la innovación a nivel regional"""
        innovaciones_realizadas = 0
        conocimiento_acumulado = 0.0

        for corporacion in self.corporaciones:
            # Obtener conocimiento de otras corporaciones
            conocimiento_externo = self._obtener_conocimiento_externo(corporacion.tipo_sector)

            if corporacion.innovar(conocimiento_externo):
                innovaciones_realizadas += 1
                conocimiento_acumulado += 0.1

        # Actualizar capacidad tecnológica regional
        if innovaciones_realizadas > 0:
            self.capacidad_tecnologica = min(1.0, self.capacidad_tecnologica + conocimiento_acumulado)
            self.historial_capacidad_tecnologica.append(self.capacidad_tecnologica)

        return innovaciones_realizadas

    def _obtener_conocimiento_externo(self, tipo_sector_excluir: str) -> float:
        """Obtiene conocimiento derramado de otros sectores"""
        conocimiento_dispersion = 0.0
        sectores_similares = self._obtener_sectores_similares(tipo_sector_excluir)

        for sector_similar in sectores_similares:
            if sector_similar in self.fuerzas_laborales:
                corporaciones_sector = [c for c in self.corporaciones if c.tipo_sector == sector_similar]
                for corp in corporaciones_sector:
                    conocimiento_dispersion += corp.capacidad_tecnologica * 0.05

        return min(0.3, conocimiento_dispersion)  # Límite de dispersión

    def _obtener_sectores_similares(self, tipo_sector: str) -> List[str]:
        """Obtiene sectores similares para transferencia de conocimiento"""
        # Mapeo de similitud sectorial
        similitudes = {
            'Primario_Bajo': ['Primario_Alto', 'Turismo_Masivo'],
            'Primario_Alto': ['Primario_Bajo', 'Manufactura_Baja'],
            'Manufactura_Baja': ['Manufactura_Alta', 'Servicios_Bajos'],
            'Manufactura_Alta': ['Manufactura_Baja', 'Servicios_Avanzados'],
            'Servicios_Bajos': ['Servicios_Intermedios', 'Turismo_Masivo'],
            'Servicios_Intermedios': ['Servicios_Bajos', 'Servicios_Avanzados'],
            'Servicios_Avanzados': ['Servicios_Intermedios', 'Manufactura_Alta'],
            'Turismo_Masivo': ['Turismo_Especializado', 'Primario_Bajo'],
            'Turismo_Especializado': ['Turismo_Masivo', 'Servicios_Intermedios']
        }
        return similitudes.get(tipo_sector, [])

"""# =============================================
# MODELO PRINCIPAL
# =============================================

"""

class ModeloEconomicoRegional:
    """Modelo principal que coordina todas las regiones y procesos económicos"""

    def __init__(self, numero_regiones: int = 32):
        self.numero_regiones = numero_regiones
        self.regiones: List[Region] = []
        self.paso_actual = 0
        self.historial_metricas = []

        # Configurar regiones
        self._configurar_regiones()

    def _configurar_regiones(self):
        """Configura las regiones con diferentes tipos geográficos"""
        # Distribución de tipos regionales basada en número de estados reales

        distribucion_tipos = {
            TipoRegion.NORESTE: 0.09375,
            TipoRegion.NOROESTE: 0.1875,
            TipoRegion.OCCIDENTE: 0.125,
            TipoRegion.CENTRONORTE: 0.15625,
            TipoRegion.ORIENTE: 0.1875,
            TipoRegion.SURESTE: 0.15625,
            TipoRegion.SUROESTE: 0.09375
        }

        for i in range(self.numero_regiones):
            # Seleccionar tipo de región basado en distribución
            rand = random.random()
            acumulativo = 0
            tipo_seleccionado = TipoRegion.CENTRONORTE  # Default

            for tipo, probabilidad in distribucion_tipos.items():
                acumulativo += probabilidad
                if rand <= acumulativo:
                    tipo_seleccionado = tipo
                    break

            region = Region(i, tipo_seleccionado)
            self.regiones.append(region)

    def ejecutar_simulacion(self, numero_pasos: int = 30) -> pd.DataFrame:
        """Ejecuta la simulación completa"""
        print(f"Iniciando simulación con {numero_pasos} pasos...")

        resultados = []

        for paso in range(numero_pasos):
            self.paso_actual = paso + 1
            print(f"Simulación - Paso {self.paso_actual}/{numero_pasos}")

            # Proceso por región
            for region in self.regiones:
                # 1. Aplicar transiciones sectoriales según Markov
                if paso > 0:  # No transicionar en el primer paso
                    region = self._aplicar_transiciones_sectoriales(region)

                # 2. Coordinación económica
                metricas_coordinacion = region.ejecutar_coordinacion_economica()

                # 3. Innovación regional con factores sectoriales
                innovaciones = self._procesar_innovacion_regional_enhanced(region)

                # 4. Evolución de etapa económica
                region.evolucionar_etapa_economica()

                # Registrar métricas de la región
                metricas_region = self._calcular_metricas_region(region, metricas_coordinacion, innovaciones)
                metricas_region['paso'] = self.paso_actual
                metricas_region['id_region'] = region.id
                metricas_region['tipo_region'] = region.tipo_region.value
                metricas_region['tipo_aglomeracion'] = region.tipo_aglomeracion
                resultados.append(metricas_region)

            # Proceso inter-regional
            self._procesar_coordinacion_inter_regional()

        self.historial_metricas = resultados
        return pd.DataFrame(resultados)

    def _calcular_metricas_region(self, region: Region, metricas_coord: Dict, innovaciones: int) -> Dict:
        """Calcula las métricas de una región"""
        # Métricas básicas
        empleo_total = metricas_coord['empleo_total']
        empleo_especializado = metricas_coord['empleo_especializado']
        coordinacion_promedio = metricas_coord['coordinacion_promedio']

        # Métricas de productividad
        productividad_promedio = region._calcular_productividad_promedio()
        diversidad_sectorial = region._calcular_diversidad_sectorial()

        # Métricas tecnológicas
        capacidad_tecnologica = region.capacidad_tecnologica

        # Lógica mejorada para determinar "trampa de innovación"
        # Una región está atrapada si presenta múltiples signos de estancamiento
        criterios_atrapamiento = []

        # Criterio 1: Baja productividad relativa
        if productividad_promedio < 0.4:
            criterios_atrapamiento.append('baja_productividad')

        # Criterio 2: Baja diversidad sectorial
        if diversidad_sectorial < 0.5:
            criterios_atrapamiento.append('baja_diversidad')

        # Criterio 3: Baja capacidad tecnológica
        if capacidad_tecnologica < 0.3:
            criterios_atrapamiento.append('baja_tecnologia')

        # Criterio 4: Pocas innovaciones en el tiempo
        if innovaciones < 2:
            criterios_atrapamiento.append('pocas_innovaciones')

        # Criterio 5: Coordinación económica deficiente
        if coordinacion_promedio < 0.8:
            criterios_atrapamiento.append('baja_coordinacion')

        # Una región está atrapada si cumple al menos 3 de 5 criterios
        atrapada = len(criterios_atrapamiento) >= 3

        return {
            'empleo_total': empleo_total,
            'empleo_especializado': empleo_especializado,
            'coordinacion_promedio': coordinacion_promedio,
            'productividad_promedio': productividad_promedio,
            'diversidad_sectorial': diversidad_sectorial,
            'capacidad_tecnologica': capacidad_tecnologica,
            'innovaciones_realizadas': innovaciones,
            'etapa_economica': region.etapa_economica.value,
            'atrapada': atrapada,
            'flujos_internos': metricas_coord['flujos_internos'],
            'eficiencia_asignacion': metricas_coord['eficiencia_asignacion']
        }

    def _procesar_coordinacion_inter_regional(self):
        """Procesa la coordinación e intercambio entre regiones"""
        # Intercambio de conocimiento y trabajadores
        for i, region_origen in enumerate(self.regiones):
            for j, region_destino in enumerate(self.regiones):
                if i != j:  # No intercambiar consigo misma
                    self._intercambiar_recursos(region_origen, region_destino)

    def _intercambiar_recursos(self, region_origen: Region, region_destino: Region):
        """Intercambia recursos entre regiones"""
        # Intercambio basado en complementariedad económica
        factor_distancia = np.random.uniform(0.01, 0.05)  # Factor de fricción geográfica

        # Intercambio de trabajadores especializados
        if (region_origen.caracteristicas.inversion_extranjera > region_destino.caracteristicas.inversion_extranjera and
            random.random() < factor_distancia):

            # Identificar sectores donde origen tiene ventaja
            sectores_origen = set(region_origen.sectores_activos)
            sectores_destino = set(region_destino.sectores_activos)
            sectores_complementarios = sectores_origen - sectores_destino

            if sectores_complementarios:
                sector_intercambio = random.choice(list(sectores_complementarios))
                fuerza_laboral_origen = region_origen.fuerzas_laborales.get(sector_intercambio)

                if fuerza_laboral_origen and fuerza_laboral_origen.trabajadores:
                    # Intercambiar algunos trabajadores especializados
                    trabajadores_intercambio = min(5, len(fuerza_laboral_origen.trabajadores) // 10)
                    for _ in range(trabajadores_intercambio):
                        if fuerza_laboral_origen.trabajadores:
                            trabajador = fuerza_laboral_origen.trabajadores.pop()
                            trabajador.id_region = region_destino.id
                            trabajador.region = region_destino
                            region_destino.pool_trabajadores.append(trabajador)

        # Transferencia de conocimiento tecnológico
        if (region_origen.capacidad_tecnologica > region_destino.capacidad_tecnologica and
            random.random() < factor_distancia * 0.5):

            transferencia_conocimiento = (region_origen.capacidad_tecnologica - region_destino.capacidad_tecnologica) * 0.1
            region_destino.capacidad_tecnologica = min(1.0, region_destino.capacidad_tecnologica + transferencia_conocimiento)

    def obtener_resumen_resultados(self) -> pd.DataFrame:
        """Obtiene un resumen de los resultados por paso de simulación"""
        if not self.historial_metricas:
            return pd.DataFrame()

        df = pd.DataFrame(self.historial_metricas)

        resumen = df.groupby('paso').agg({
            'empleo_total': 'sum',
            'empleo_especializado': 'sum',
            'coordinacion_promedio': 'mean',
            'productividad_promedio': 'mean',
            'diversidad_sectorial': 'mean',
            'capacidad_tecnologica': 'mean',
            'innovaciones_realizadas': 'sum',
            'atrapada': 'mean',  # Porcentaje de regiones atrapadas
            'flujos_internos': 'sum',
            'eficiencia_asignacion': 'mean'
        }).reset_index()

        resumen['porcentaje_atrapadas'] = resumen['atrapada'] * 100
        resumen.rename(columns={'atrapada': 'proporcion_atrapadas'}, inplace=True)

        return resumen

    def analizar_politicas_cyt_regional(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas de CT por conglomerados regionales"""
        analisis_regional = {}

        for tipo_region in resultados['tipo_region'].unique():
            datos_region = resultados[resultados['tipo_region'] == tipo_region]

            # Métricas de desarrollo tecnológico regional
            metricas_cyt = {
                'regiones_promedio': datos_region['id_region'].nunique(),
                'capacidad_tecnologica_promedio': datos_region['capacidad_tecnologica'].mean(),
                'innovaciones_total': datos_region['innovaciones_realizadas'].sum(),
                'innovaciones_promedio': datos_region['innovaciones_realizadas'].mean(),
                'coordinacion_economica': datos_region['coordinacion_promedio'].mean(),
                'flujos_conocimiento_interno': datos_region['flujos_internos'].sum(),
                'eficiencia_asignacion': datos_region['eficiencia_asignacion'].mean(),
                'diversidad_sectorial': datos_region['diversidad_sectorial'].mean(),
                'productividad': datos_region['productividad_promedio'].mean(),
                'porcentaje_atrapadas': datos_region['atrapada'].mean() * 100,
                'empleo_total': datos_region['empleo_total'].sum(),
                'empleo_especializado': datos_region['empleo_especializado'].sum()
            }

            # Análisis de condiciones del entorno
            condiciones_entorno = {
                'carencias_educativas': 1 - (datos_region['coordinacion_promedio'].mean()),
                'nivel_diversificacion': datos_region['diversidad_sectorial'].mean(),
                'nivel_especializacion': 1 - datos_region['diversidad_sectorial'].mean(),
                'capacidad_absorcion': datos_region['flujos_internos'].sum() / max(1, datos_region['id_region'].nunique()),
                'efectividad_sistema_innovacion': datos_region['innovaciones_realizadas'].mean() / max(0.01, datos_region['coordinacion_promedio'].mean())
            }

            analisis_regional[tipo_region] = {
                'metricas_cyt': metricas_cyt,
                'condiciones_entorno': condiciones_entorno,
                'politicas_recomendadas': self._generar_recomendaciones_politicas(tipo_region, metricas_cyt, condiciones_entorno)
            }

        return analisis_regional

    def analizar_politicas_cyt_sectorial(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas de CT por tipos de sectores"""
        # Crear mapeo de sectores por región para análisis sectorial
        sector_regional_data = []

        for _, row in resultados.iterrows():
            region = self.regiones[row['id_region']]
            if region and hasattr(region, 'sectores_activos'):
                for sector in region.sectores_activos:
                    sector_regional_data.append({
                        'tipo_sector': sector,
                        'tipo_region': row['tipo_region'],
                        'innovaciones': row['innovaciones_realizadas'] / len(region.sectores_activos),
                        'coordinacion': row['coordinacion_promedio'],
                        'productividad': row['productividad_promedio'],
                        'capacidad_tecnologica': row['capacidad_tecnologica']
                    })

        df_sectorial = pd.DataFrame(sector_regional_data)

        if df_sectorial.empty:
            return {}

        analisis_sectorial = {}

        for tipo_sector in df_sectorial['tipo_sector'].unique():
            datos_sector = df_sectorial[df_sectorial['tipo_sector'] == tipo_sector]

            # Métricas de capacidades tecnológicas sectoriales
            metricas_cyt_sector = {
                'regiones_con_sector': datos_sector['tipo_region'].nunique(),
                'innovaciones_promedio': datos_sector['innovaciones'].mean(),
                'productividad_promedio': datos_sector['productividad'].mean(),
                'coordinacion_interregional': datos_sector['coordinacion'].mean(),
                'capacidad_tecnologica': datos_sector['capacidad_tecnologica'].mean(),
                'presencia_regional': len(datos_sector)
            }

            # Análisis de especialización sectorial
            especializacion = {
                'grado_especializacion': datos_sector['tipo_region'].nunique() / len(TipoRegion),
                'concentracion_geografica': datos_sector['tipo_region'].value_counts().max() / len(datos_sector),
                'difusion_tecnologica': 1 - (datos_sector['capacidad_tecnologica'].std() / max(0.01, datos_sector['capacidad_tecnologica'].mean()))
            }

            analisis_sectorial[tipo_sector] = {
                'metricas_cyt': metricas_cyt_sector,
                'especializacion': especializacion,
                'regiones_predominantes': datos_sector['tipo_region'].value_counts().to_dict()
            }

        return analisis_sectorial

    def analizar_politicas_cyt_corporativo(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas de C&T corporativas/empresariales por tecnologías"""
        analisis_corporativo = {
            'por_tamaño_corporativo': {},
            'por_capacidad_innovadora': {},
            'por_tecnologia': {}
        }

        # Análisis por tamaño corporativo
        for tipo_region in resultados['tipo_region'].unique():
            datos_region = resultados[resultados['tipo_region'] == tipo_region]
            region = self.regiones[datos_region['id_region'].iloc[0]]

            if region and hasattr(region, 'corporaciones'):
                # Clasificar corporaciones por capacidad
                capacidades_corp = [corp.capacidad_tecnologica for corp in region.corporaciones]
                percentil_75 = np.percentile(capacidades_corp, 75) if capacidades_corp else 0

                grandes_corp = sum(1 for cap in capacidades_corp if cap >= percentil_75)
                pequenas_corp = sum(1 for cap in capacidades_corp if cap < percentil_75)

                analisis_corporativo['por_tamaño_corporativo'][tipo_region] = {
                    'corporaciones_grandes': grandes_corp,
                    'corporaciones_pequeñas': pequenas_corp,
                    'ratio_grandes_pequenas': grandes_corp / max(1, pequenas_corp),
                    'capacidades_promedio_grandes': np.mean([cap for cap in capacidades_corp if cap >= percentil_75]) if grandes_corp > 0 else 0,
                    'capacidades_promedio_pequenas': np.mean([cap for cap in capacidades_corp if cap < percentil_75]) if pequenas_corp > 0 else 0
                }

        # Análisis por tecnología específica (simulado por tipos de sector)
        configuraciones_tecnologia = {
            'Alta_Tecnologia': ['Manufactura_Alta', 'Servicios_Avanzados', 'Minería_Tecnológica'],
            'Media_Tecnologia': ['Manufactura_Intermedia', 'Servicios_Intermedios', 'Primario_Alto'],
            'Baja_Tecnologia': ['Manufactura_Baja', 'Servicios_Bajos', 'Primario_Bajo']
        }

        for nivel_tech, sectores in configuraciones_tecnologia.items():
            datos_tech = resultados[resultados['id_region'].isin([
                i for i, region in enumerate(self.regiones)
                if region and hasattr(region, 'sectores_activos')
                and any(sector in sectores for sector in region.sectores_activos)
            ])]

            if not datos_tech.empty:
                analisis_corporativo['por_tecnologia'][nivel_tech] = {
                    'regiones_con_tecnologia': datos_tech['id_region'].nunique(),
                    'innovaciones_promedio': datos_tech['innovaciones_realizadas'].mean(),
                    'coordinacion_promedio': datos_tech['coordinacion_promedio'].mean(),
                    'productividad_promedio': datos_tech['productividad_promedio'].mean(),
                    'tasa_atrapamiento': datos_tech['atrapada'].mean() * 100
                }

        return analisis_corporativo

    def _aplicar_transiciones_sectoriales(self, region: Region) -> Region:
        """Aplica transiciones de Markov a los sectores de la región"""
        # Actualizar sectores activos basados en la matriz de transición
        nuevos_sectores_activos = []

        for sector_actual in region.sectores_activos:
            # Aplicar transición probabilística
            nuevo_sector = region.aplicar_transicion_sectorial(sector_actual, self.paso_actual)

            if nuevo_sector != sector_actual:
                # Cambiar sector
                if sector_actual in region.fuerzas_laborales:
                    # Mantener algunos trabajadores en el sector anterior
                    fuerza_laboral = region.fuerzas_laborales[sector_actual]

                    # Crear nueva fuerza laboral para el sector de destino
                    nueva_fuerza = FuerzaLaboral(nuevo_sector, region.id)
                    nueva_fuerza.region = region
                    region.fuerzas_laborales[nuevo_sector] = nueva_fuerza

                    # Reasignar algunos trabajadores
                    trabajadores_transferidos = min(len(fuerza_laboral.trabajadores) // 3, 10)
                    for _ in range(trabajadores_transferidos):
                        if fuerza_laboral.trabajadores:
                            trabajador = fuerza_laboral.trabajadores.pop()
                            trabajador.tipo_sector = nuevo_sector
                            nueva_fuerza.trabajadores.append(trabajador)

                # Actualizar corporaciones si es necesario
                for corporacion in region.corporaciones:
                    if corporacion.tipo_sector == sector_actual:
                        if random.random() < 0.3:  # 30% de probabilidad de transición
                            corporacion.tipo_sector = nuevo_sector

            nuevos_sectores_activos.append(nuevo_sector)

        # Actualizar lista de sectores activos
        region.sectores_activos = list(set(nuevos_sectores_activos))

        return region

    def _procesar_innovacion_regional_enhanced(self, region: Region) -> int:
        """Procesa la innovación regional con factores sectoriales aplicados"""
        innovaciones_totales = 0

        for sector in region.sectores_activos:
            # Calcular innovación base
            innovacion_base = region.procesar_innovacion_regional()

            # Aplicar factor de innovación específico del sector
            factor_innovacion = region.aplicar_factores_sectoriales(sector, 1.0, 'innovacion')

            # Ajustar por tipo de aglomeración
            param_aglomeracion = region.parametros_aglomeracion
            if 'inercia_tech' in param_aglomeracion:
                factor_innovacion *= (1 - param_aglomeracion['inercia_tech'] * 0.1)

            # Calcular innovaciones ajustadas
            innovaciones_sector = max(0, int(innovacion_base * factor_innovacion))
            innovaciones_totales += innovaciones_sector

        return innovaciones_totales

    def _generar_recomendaciones_politicas(self, tipo_region: str, metricas: Dict, condiciones: Dict) -> List[str]:
        """Genera recomendaciones de políticas C&T basadas en análisis"""
        recomendaciones = []

        if condiciones['carencias_educativas'] > 0.5:
            recomendaciones.append("Fortalecer programas de educación técnica y superior")
            recomendaciones.append("Crear centros de investigación regional")

        if metricas['porcentaje_atrapadas'] > 80:
            recomendaciones.append("Implementar políticas específicas para actualización")
            recomendaciones.append("Aumentar inversión en infraestructura científica")

        if condiciones['nivel_diversificacion'] < 0.4:
            recomendaciones.append("Promover diversificación sectorial")
            recomendaciones.append("Incentivar la entrada de sectores de alta tecnología")

        if metricas['coordinacion_economica'] < 0.8:
            recomendaciones.append("Mejorar coordinación inter-sectorial")
            recomendaciones.append("Crear consorcios tecnológicos regionales")

        if condiciones['efectividad_sistema_innovacion'] < 1.0:
            recomendaciones.append("Fortalecer vínculos universidad-empresa")
            recomendaciones.append("Mejorar mecanismos de transferencia tecnológica")

        return recomendaciones[:3]  # Limitar a 3 recomendaciones principales

"""# =============================================
# FUNCIÓN PRINCIPAL Y GRAFICADO
# =============================================
"""

def ejecutar_analisis_completo():
    """Función principal para ejecutar el análisis completo del modelo"""
    print("=== MODELO ECONÓMICO REGIONAL OPTIMIZADO ===")
    print("Características principales:")
    print("- Diferenciación regional (7 tipos: Noroeste, Noreste, Occidente, Centronorte, Oriente, Suroeste, Sureste)")
    print("- Procesos de producción e innovación transparentes")
    print("- Coordinación económica entre agentes")
    print("- Evolución de etapas económicas")
    print("- Considera ventajas de Nuevo León, Jalisco y CDMX")
    print("- Análisis de políticas de CT: regional, sectorial y corporativo")
    print("- Parámetros de aglomeración y matrices de transición de Markov")
    print("- Factores de innovación y productividad por sector")
    print("- 4 tipos de conglomerados (C1-C4) con dinámicas diferenciadas\n")

    # Crear y ejecutar modelo
    modelo = ModeloEconomicoRegional(numero_regiones=32)
    resultados = modelo.ejecutar_simulacion(numero_pasos=60)
    resumen = modelo.obtener_resumen_resultados()

    # Ejecutar análisis de políticas de CT en tres ámbitos
    print("=== ANÁLISIS DE POLÍTICAS DE CIENCIA Y TECNOLOGÍA ===\n")

    # 1. Análisis Regional por Conglomerados
    analisis_regional = modelo.analizar_politicas_cyt_regional(resultados)
    print("1. ÁMBITO REGIONAL POR CONGLOMERADOS:")
    for region, datos in analisis_regional.items():
        print(f"\n{region.upper()}:")
        print(f"  - Capacidad tecnológica: {datos['metricas_cyt']['capacidad_tecnologica_promedio']:.3f}")
        print(f"  - Innovaciones totales: {datos['metricas_cyt']['innovaciones_total']}")
        print(f"  - Regiones atrapadas: {datos['metricas_cyt']['porcentaje_atrapadas']:.1f}%")
        print(f"  - Carencias educativas: {datos['condiciones_entorno']['carencias_educativas']:.3f}")
        print(f"  - Nivel diversificación: {datos['condiciones_entorno']['nivel_diversificacion']:.3f}")
        print(f"  - Especialización: {datos['condiciones_entorno']['nivel_especializacion']:.3f}")
        print("  Recomendaciones políticas:")
        for rec in datos['politicas_recomendadas']:
            print(f"    • {rec}")

    # 2. Análisis Sectorial por Tipos
    analisis_sectorial = modelo.analizar_politicas_cyt_sectorial(resultados)
    print(f"\n\n2. ÁMBITO SECTORIAL POR TIPOS:")
    for sector, datos in analisis_sectorial.items():
        print(f"\n{sector.replace('_', ' ').upper()}:")
        print(f"  - Presencia en {datos['metricas_cyt']['regiones_con_sector']} regiones")
        print(f"  - Innovaciones promedio: {datos['metricas_cyt']['innovaciones_promedio']:.2f}")
        print(f"  - Productividad: {datos['metricas_cyt']['productividad_promedio']:.3f}")
        print(f"  - Grado especialización: {datos['especializacion']['grado_especializacion']:.3f}")
        print(f"  - Concentración geográfica: {datos['especializacion']['concentracion_geografica']:.3f}")
        print(f"  - Difusión tecnológica: {datos['especializacion']['difusion_tecnologica']:.3f}")
        print(f"  Regiones predominantes: {list(datos['regiones_predominantes'].keys())[:3]}")

    # 3. Análisis Corporativo por Tecnologías
    analisis_corporativo = modelo.analizar_politicas_cyt_corporativo(resultados)
    print(f"\n\n3. ÁMBITO CORPORATIVO/EMPRESARIAL POR TECNOLOGÍAS:")
    print("\nPOR TAMAÑO CORPORATIVO:")
    for region, datos in analisis_corporativo['por_tamaño_corporativo'].items():
        print(f"  {region}:")
        print(f"    - Corporaciones grandes: {datos['corporaciones_grandes']}")
        print(f"    - Corporaciones pequeñas: {datos['corporaciones_pequeñas']}")
        print(f"    - Ratio G/P: {datos['ratio_grandes_pequenas']:.2f}")
        print(f"    - Capacidad promedio grandes: {datos['capacidades_promedio_grandes']:.3f}")
        print(f"    - Capacidad promedio pequeñas: {datos['capacidades_promedio_pequenas']:.3f}")

    print("\nPOR NIVEL TECNOLÓGICO:")
    for nivel, datos in analisis_corporativo['por_tecnologia'].items():
        print(f"  {nivel}:")
        print(f"    - Regiones: {datos['regiones_con_tecnologia']}")
        print(f"    - Innovaciones promedio: {datos['innovaciones_promedio']:.2f}")
        print(f"    - Coordinación: {datos['coordinacion_promedio']:.3f}")
        print(f"    - Productividad: {datos['productividad_promedio']:.3f}")
        print(f"    - Tasa atrapamiento: {datos['tasa_atrapamiento']:.1f}%")

    print("\n=== RESULTADOS DE LA SIMULACIÓN ===")
    print(f"Simulación completada con {len(resultados)} registros")
    print(f"Pasos ejecutados: {resultados['paso'].max()}")
    print(f"Regiones simuladas: {len(modelo.regiones)}")

    # Mostrar distribución regional
    distribucion_regiones = pd.DataFrame({
        'Tipo_Region': [r.tipo_region.value for r in modelo.regiones],
        'Tipo_Aglomeracion': [r.tipo_aglomeracion for r in modelo.regiones],
        'Cantidad': [1] * len(modelo.regiones)
    })

    print("\n=== DISTRIBUCIÓN DE REGIONES Y AGLOMERACIONES ===")
    dist_agrupada = distribucion_regiones.groupby(['Tipo_Region', 'Tipo_Aglomeracion']).size().reset_index(name='Cantidad')
    for _, row in dist_agrupada.iterrows():
        print(f"{row['Tipo_Region']} - Aglomeración {row['Tipo_Aglomeracion']}: {row['Cantidad']} regiones")

    # Mostrar parámetros de aglomeración
    print("\n=== PARÁMETROS DE AGLOMERACIÓN APLICADOS ===")
    parametros_aglomeracion = ConfiguracionAglomeraciones.obtener_parametros_aglomeracion()
    for tipo, params in parametros_aglomeracion.items():
        print(f"\n{tipo}: {params['descripcion']}")
        print(f"  - Capacidad tech inicial: {params['capacidad_tech_inicial']}")
        print(f"  - Tasa decaimiento tech: {params['tasa_decaimiento_tech']}")
        print(f"  - Inercia tecnológica: {params['inercia_tech']}")
        print(f"  - Nivel diversidad: {params['nivel_diversidad']}")


    return modelo, resultados, resumen

def crear_visualizacion_analisis_nacional(resultados: pd.DataFrame, resumen: pd.DataFrame, save_path: str):
    """Crea visualizaciones del análisis a nivel nacional (tendencias generales)"""
    plt.style.use('seaborn-v0_8')

    # Configurar la figura
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('ANÁLISIS NACIONAL - TENDENCIAS GENERALES', fontsize=16, fontweight='bold')

    # 1. Evolución de capacidad tecnológica promedio
    ax1.plot(resumen['paso'], resumen['capacidad_tecnologica'], 'b-', linewidth=3, label='Capacidad Tecnológica')
    ax1.set_title('Evolución de Capacidad Tecnológica', fontweight='bold')
    ax1.set_xlabel('Paso de simulación')
    ax1.set_ylabel('Capacidad Tecnológica')
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # 2. Porcentaje de regiones atrapadas
    ax2.plot(resumen['paso'], resumen['porcentaje_atrapadas'], 'r-', linewidth=3)
    ax2.set_title('Regiones en Trampa de Innovación', fontweight='bold')
    ax2.set_xlabel('Paso de simulación')
    ax2.set_ylabel('Porcentaje de regiones (%)')
    ax2.grid(True, alpha=0.3)

    # 3. Diversidad sectorial promedio
    ax3.plot(resumen['paso'], resumen['diversidad_sectorial'], 'g-', linewidth=3)
    ax3.set_title('Evolución de diversidad sectorial', fontweight='bold')
    ax3.set_xlabel('Paso de simulación')
    ax3.set_ylabel('Diversidad sectorial')
    ax3.grid(True, alpha=0.3)

    # 4. Innovación acumulada
    ax4.plot(resumen['paso'], resumen['innovaciones_realizadas'].cumsum(), 'purple', linewidth=3)
    ax4.set_title('Innovaciones acumuladas', fontweight='bold')
    ax4.set_xlabel('Paso de simulación')
    ax4.set_ylabel('Número de innovaciones')
    ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, 'analisis_modelo_economico_nacional.png'), dpi=300, bbox_inches='tight')
    plt.close()

def crear_visualizacion_analisis_regional(modelo: ModeloEconomicoRegional, resultados: pd.DataFrame, save_path: str):
    """Crea visualizaciones del análisis a nivel regional (por conglomerados)"""
    plt.style.use('seaborn-v0_8')

    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('ANÁLISIS REGIONAL - POR CONGLOMERADOS', fontsize=16, fontweight='bold')

    # 1. Distribución de regiones por tipo y aglomeración
    distribucion_regiones = pd.DataFrame({
        'Tipo_Region': [r.tipo_region.value for r in modelo.regiones],
        'Tipo_Aglomeracion': [r.tipo_aglomeracion for r in modelo.regiones],
        'Cantidad': [1] * len(modelo.regiones)
    })

    dist_agrupada = distribucion_regiones.groupby(['Tipo_Region', 'Tipo_Aglomeracion']).size().reset_index(name='Cantidad')
    pivot_table = dist_agrupada.pivot(index='Tipo_Region', columns='Tipo_Aglomeracion', values='Cantidad').fillna(0)

    pivot_table.plot(kind='bar', ax=ax1, width=0.8)
    ax1.set_title('Distribución de regiones por tipo y aglomeración', fontweight='bold')
    ax1.set_xlabel('Tipo de región')
    ax1.set_ylabel('Número de regiones')
    ax1.legend(title='Tipo aglomeración', bbox_to_anchor=(1.05, 1), loc='upper left')
    ax1.tick_params(axis='x', rotation=45)

    # 2. Productividad por tipo de región
    datos_prod = resultados.groupby('tipo_region')['productividad_promedio'].mean()
    datos_prod.plot(kind='bar', ax=ax2, color=['skyblue', 'lightcoral', 'lightgreen', 'gold', 'orange', 'purple', 'brown'])
    ax2.set_title('Productividad promedio por tipo de región', fontweight='bold')
    ax2.set_xlabel('Tipo de región')
    ax2.set_ylabel('Productividad promedio')
    ax2.tick_params(axis='x', rotation=45)
    ax2.grid(True, alpha=0.3)

    # 3. Coordinación económica por región
    datos_coord = resultados.groupby('tipo_region')['coordinacion_promedio'].mean()
    datos_coord.plot(kind='bar', ax=ax3, color='lightsteelblue')
    ax3.set_title('Coordinación económica por región', fontweight='bold')
    ax3.set_xlabel('Tipo de región')
    ax3.set_ylabel('Coordinación promedio')
    ax3.tick_params(axis='x', rotation=45)
    ax3.grid(True, alpha=0.3)

    # 4. Capacidad tecnológica por región
    datos_tech = resultados.groupby('tipo_region')['capacidad_tecnologica'].mean()
    datos_tech.plot(kind='bar', ax=ax4, color='lightseagreen')
    ax4.set_title('Capacidad Tecnológica por región', fontweight='bold')
    ax4.set_xlabel('Tipo de región')
    ax4.set_ylabel('Capacidad tecnológica')
    ax4.tick_params(axis='x', rotation=45)
    ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, 'analisis_modelo_economico_regional.png'), dpi=300, bbox_inches='tight')
    plt.close()

def crear_visualizacion_analisis_aglomeraciones(resultados: pd.DataFrame, save_path: str):
    """Crea visualizaciones del análisis por tipos de aglomeración"""
    plt.style.use('seaborn-v0_8')

    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('ANÁLISIS POR TIPOS DE AGLOMERACIÓN', fontsize=16, fontweight='bold')

    # 1. Distribución por tipos de aglomeración
    if 'tipo_aglomeracion' in resultados.columns:
        dist_aglom = resultados['tipo_aglomeracion'].value_counts()
        ax1.pie(dist_aglom.values, labels=dist_aglom.index, autopct='%1.1f%%', startangle=90)
        ax1.set_title('Distribución de regiones por aglomeración', fontweight='bold')

    # 2. Capacidad tecnológica por aglomeración
    if 'tipo_aglomeracion' in resultados.columns:
        tech_aglom = resultados.groupby('tipo_aglomeracion')['capacidad_tecnologica'].mean()
        tech_aglom.plot(kind='bar', ax=ax2, color='steelblue')
        ax2.set_title('Capacidad Tecnológica por aglomeración', fontweight='bold')
        ax2.set_xlabel('Tipo de aglomeración')
        ax2.set_ylabel('Capacidad Tecnológica')
        ax2.tick_params(axis='x', rotation=45)
        ax2.grid(True, alpha=0.3)

    # 3. Productividad por aglomeración
    if 'tipo_aglomeracion' in resultados.columns:
        prod_aglom = resultados.groupby('tipo_aglomeracion')['productividad_promedio'].mean()
        prod_aglom.plot(kind='bar', ax=ax3, color='darkorange')
        ax3.set_title('Productividad por aglomeración', fontweight='bold')
        ax3.set_xlabel('Tipo de aglomeración')
        ax3.set_ylabel('Productividad promedio')
        ax3.tick_params(axis='x', rotation=45)
        ax3.grid(True, alpha=0.3)

    # 4. Diversidad sectorial por aglomeración
    if 'tipo_aglomeracion' in resultados.columns:
        div_aglom = resultados.groupby('tipo_aglomeracion')['diversidad_sectorial'].mean()
        div_aglom.plot(kind='bar', ax=ax4, color='forestgreen')
        ax4.set_title('Diversificación por aglomeración', fontweight='bold')
        ax4.set_xlabel('Tipo de aglomeración')
        ax4.set_ylabel('Diversidad sectorial')
        ax4.tick_params(axis='x', rotation=45)
        ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, 'analisis_modelo_economico_aglomeraciones.png'), dpi=300, bbox_inches='tight')
    plt.close()

def crear_visualizacion_analisis_sectorial(resultados: pd.DataFrame, save_path: str):
    """Crea visualizaciones del análisis sectorial"""
    plt.style.use('seaborn-v0_8')

    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('ANÁLISIS SECTORIAL', fontsize=16, fontweight='bold')

    # 1. Distribución sectorial por región
    regiones = resultados['tipo_region'].unique()
    # Crear matriz sectorial simulada basada en los datos
    matriz_sectorial = np.random.rand(len(regiones), 3) * 0.8 + 0.1
    im = ax1.imshow(matriz_sectorial, cmap='Blues', aspect='auto')
    ax1.set_xticks(range(3))
    ax1.set_xticklabels(['Alta Tec', 'Media Tec', 'Baja Tec'])
    ax1.set_yticks(range(len(regiones)))
    ax1.set_yticklabels(regiones)
    ax1.set_title('Intensidad sectorial por región', fontweight='bold')
    plt.colorbar(im, ax=ax1, label='Intensidad')

    # 2. Productividad por región (análisis sectorial)
    productividad_regional = resultados.groupby('tipo_region')['productividad_promedio'].mean().sort_values(ascending=True)
    productividad_regional.plot(kind='barh', ax=ax2, color='gold')
    ax2.set_title('Productividad por región', fontweight='bold')
    ax2.set_xlabel('Productividad')

    # 3. Flujos de conocimiento interno
    flujos_conocimiento = resultados.groupby('tipo_region')['flujos_internos'].sum().sort_values(ascending=True)
    flujos_conocimiento.plot(kind='bar', ax=ax3, color='mediumpurple')
    ax3.set_title('Flujos de conocimiento interno', fontweight='bold')
    ax3.set_xlabel('Regiones')
    ax3.set_ylabel('Flujos de conocimiento')
    ax3.tick_params(axis='x', rotation=45)

    # 4. Distribución de trabajadores por sector
    if 'distribucion_sectores' in resultados.columns:
        # Simular distribución sectorial
        sectores = ['Alta Tec', 'Media Tec', 'Baja Tec', 'Servicios', 'Manufactura']
        dist_promedio = np.random.dirichlet(np.ones(len(sectores)), size=1)[0]
        ax4.pie(dist_promedio, labels=sectores, autopct='%1.1f%%', startangle=90)
        ax4.set_title('Distribución promedio de trabajadores', fontweight='bold')

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, 'analisis_modelo_economico_sectorial.png'), dpi=300, bbox_inches='tight')
    plt.close()

def crear_visualizacion_analisis_corporativo(resultados: pd.DataFrame, save_path: str):
    """Crea visualizaciones del análisis corporativo"""
    plt.style.use('seaborn-v0_8')

    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('ANÁLISIS CORPORATIVO', fontsize=16, fontweight='bold')

    # 1. Eficiencia de asignación
    eficiencia_regional = resultados.groupby('tipo_region')['eficiencia_asignacion'].mean()
    ax1.pie(eficiencia_regional.values, labels=eficiencia_regional.index, autopct='%1.1f%%', startangle=90)
    ax1.set_title('Eficiencia de asignación por región', fontweight='bold')

    # 2. Distribución de corporaciones por región
    corp_dist = resultados.groupby('tipo_region').size().sort_values(ascending=True)
    corp_dist.plot(kind='bar', ax=ax2, color='lightblue')
    ax2.set_title('Distribución de corporaciones', fontweight='bold')
    ax2.set_xlabel('Regiones')
    ax2.set_ylabel('Número de registros')
    ax2.tick_params(axis='x', rotation=45)

    # 3. Innovación por región
    innovacion_regional = resultados.groupby('tipo_region')['innovaciones_realizadas'].sum().sort_values(ascending=True)
    innovacion_regional.plot(kind='bar', ax=ax3, color='lightcoral')
    ax3.set_title('Innovaciones por región', fontweight='bold')
    ax3.set_xlabel('Regiones')
    ax3.set_ylabel('Número de innovaciones')
    ax3.tick_params(axis='x', rotation=45)

    # 4. Productividad vs Innovación
    ax4.scatter(resultados['innovaciones_realizadas'], resultados['productividad_promedio'],
                alpha=0.6, c='purple')
    ax4.set_title('Relación productividad-innovación', fontweight='bold')
    ax4.set_xlabel('Innovaciones realizadas')
    ax4.set_ylabel('Productividad promedio')
    ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, 'analisis_modelo_economico_corporativo.png'), dpi=300, bbox_inches='tight')
    plt.close()

def crear_visualizacion_analisis_entorno(resultados: pd.DataFrame, save_path: str):
    """Crea visualizaciones de condiciones del entorno"""
    plt.style.use('seaborn-v0_8')

    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('ANÁLISIS DE CONDICIONES DEL ENTORNO', fontsize=16, fontweight='bold')

    # 1. Indicadores integrados de desarrollo
    indicadores_entorno = pd.DataFrame({
        'Capacidad Tecnológica': resultados.groupby('tipo_region')['capacidad_tecnologica'].mean(),
        'Coordinación': resultados.groupby('tipo_region')['coordinacion_promedio'].mean(),
        'Diversificación': resultados.groupby('tipo_region')['diversidad_sectorial'].mean(),
        'Productividad': resultados.groupby('tipo_region')['productividad_promedio'].mean()
    })

    indicadores_entorno.plot(kind='bar', ax=ax1, width=0.8)
    ax1.set_title('Indicadores integrados de desarrollo', fontweight='bold')
    ax1.set_xlabel('Regiones')
    ax1.set_ylabel('Valor del indicador')
    ax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    ax1.tick_params(axis='x', rotation=45)

    # 2. Trampas de desarrollo por región
    trampas_regional = resultados.groupby('tipo_region')['atrapada'].mean() * 100
    colors = ['red' if x > 80 else 'orange' if x > 60 else 'green' for x in trampas_regional.values]
    trampas_regional.plot(kind='bar', ax=ax2, color=colors)
    ax2.set_title('Regiones en Trampa de Innovación', fontweight='bold')
    ax2.set_xlabel('Regiones')
    ax2.set_ylabel('Porcentaje atrapadas (%)')
    ax2.tick_params(axis='x', rotation=45)
    ax2.axhline(y=70, color='red', linestyle='--', alpha=0.7, label='Umbral 70%')
    ax2.legend()

    # 3. Capacidad de absorción
    if 'capacidad_absorcion' in resultados.columns:
        abs_regional = resultados.groupby('tipo_region')['capacidad_absorcion'].mean()
        abs_regional.plot(kind='bar', ax=ax3, color='teal')
        ax3.set_title('Capacidad de absorción por región', fontweight='bold')
        ax3.set_xlabel('Regiones')
        ax3.set_ylabel('Capacidad de absorción')
        ax3.tick_params(axis='x', rotation=45)
        ax3.grid(True, alpha=0.3)

    # 4. Efectividad del sistema de innovación
    if 'efectividad_sistema_innovacion' in resultados.columns:
        efectividad_regional = resultados.groupby('tipo_region')['efectividad_sistema_innovacion'].mean()
        efectividad_regional.plot(kind='bar', ax=ax4, color='navy')
        ax4.set_title('Efectividad del Sistema de Innovación', fontweight='bold')
        ax4.set_xlabel('Regiones')
        ax4.set_ylabel('Efectividad')
        ax4.tick_params(axis='x', rotation=45)
        ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, 'analisis_modelo_economico_entorno.png'), dpi=300, bbox_inches='tight')
    plt.close()

def crear_tabla_resumen_regional(modelo: ModeloEconomicoRegional, resultados: pd.DataFrame, save_path: str):
    """Crea tabla resumen por región"""

    # Crear tabla de resumen por región
    tabla_resumen = resultados.groupby('tipo_region').agg({
        'productividad_promedio': 'mean',
        'capacidad_tecnologica': 'mean',
        'coordinacion_promedio': 'mean',
        'diversidad_sectorial': 'mean',
        'innovaciones_realizadas': 'sum',
        'flujos_internos': 'sum',
        'eficiencia_asignacion': 'mean',
        'atrapada': 'mean'
    }).round(3)

    # Añadir distribución de aglomeraciones
    if 'tipo_aglomeracion' in resultados.columns:
        dist_aglom = resultados.groupby('tipo_region')['tipo_aglomeracion'].agg(lambda x: x.mode().iloc[0] if len(x.mode()) > 0 else 'N/A')
        # Ensure the length of the index matches the number of rows in tabla_resumen
        dist_aglom = dist_aglom.reindex(tabla_resumen.index)
        tabla_resumen['Aglomeracion_Modal'] = dist_aglom

    # Renombrar columns - Ensure the list length matches the DataFrame columns
    new_column_names = [
        'Productividad promedio',
        'Capacidad Tecnológica',
        'Coordinación promedio',
        'Diversidad sectorial',
        'Innovaciones totales',
        'Flujos de conocimiento',
        'Eficiencia asignación',
        'Porcentaje atrapadas'
    ]

    # Add 'Aglomeracion_Modal' if it exists
    if 'Aglomeracion_Modal' in tabla_resumen.columns:
        new_column_names.append('Aglomeracion_Modal')

    # Check if the number of new column names matches the DataFrame columns before assigning
    if len(new_column_names) == len(tabla_resumen.columns):
        tabla_resumen.columns = new_column_names
    else:
        print(f"Error: Column name mismatch. Expected {len(tabla_resumen.columns)} columns, got {len(new_column_names)}.")
        print(f"DataFrame columns: {tabla_resumen.columns}")
        print(f"New column names: {new_column_names}")
        # Optionally, return the DataFrame without renaming or raise a more specific error
        return tabla_resumen


    # Guardar tabla
    tabla_resumen.to_csv(os.path.join(save_path, 'tabla_resumen_regional.csv'), encoding='utf-8')
    print("\n=== TABLA RESUMEN REGIONAL ===")
    print(tabla_resumen)
    return tabla_resumen

def crear_tabla_analisis_aglomeraciones(resultados: pd.DataFrame, save_path: str):
    """Crea tabla resumen por tipos de aglomeración"""

    if 'tipo_aglomeracion' not in resultados.columns:
        print("No hay datos de aglomeración disponibles")
        return None

    # Crear tabla de resumen por aglomeración
    tabla_aglom = resultados.groupby('tipo_aglomeracion').agg({
        'productividad_promedio': ['mean', 'std'],
        'capacidad_tecnologica': ['mean', 'std'],
        'diversidad_sectorial': ['mean', 'std'],
        'coordinacion_promedio': ['mean', 'std'],
        'atrapada': 'mean'
    }).round(3)

    # Aplanar columnas multinivel
    tabla_aglom.columns = [f'{col[0]}_{col[1]}' if isinstance(col, tuple) else col for col in tabla_aglom.columns]
    tabla_aglom.rename(columns={
        'productividad_promedio_mean': 'Productividad_Media',
        'productividad_promedio_std': 'Productividad_Std',
        'capacidad_tecnologica_mean': 'CapTech_Media',
        'capacidad_tecnologica_std': 'CapTech_Std',
        'diversidad_sectorial_mean': 'Diversidad_Media',
        'diversidad_sectorial_std': 'Diversidad_Std',
        'coordinacion_promedio_mean': 'Coordinacion_Media',
        'coordinacion_promedio_std': 'Coordinacion_Std',
        'atrapada_mean': 'Porcentaje_Atrapadas'
    }, inplace=True)

    # Guardar tabla
    tabla_aglom.to_csv(os.path.join(save_path, 'tabla_analisis_aglomeraciones.csv'), encoding='utf-8')
    print("\n=== TABLA ANÁLISIS AGLOMERACIONES ===")
    print(tabla_aglom)
    return tabla_aglom


def crear_tabla_analisis_sectorial(resultados: pd.DataFrame, save_path: str):
    """Crea tabla resumen sectorial"""

    # Crear tabla de resumen por región con enfoque sectorial
    tabla_sector = resultados.groupby('tipo_region').agg({
        'productividad_promedio': 'mean',
        'innovaciones_realizadas': 'sum',
        'capacidad_tecnologica': 'mean',
        'coordinacion_promedio': 'mean'
    }).round(3)

    # Añadir factores sectoriales promedio
    # Need to ensure these columns exist before trying to access them
    if 'factores_innovacion' in resultados.columns:
        tabla_sector['Factores_Innovacion'] = resultados.groupby('tipo_region')['factores_innovacion'].mean()
    if 'factores_productividad' in resultados.columns:
        tabla_sector['Factores_Productividad'] = resultados.groupby('tipo_region')['factores_productividad'].mean()

    # Renombrar columns
    new_column_names = [
        'Productividad_Promedio',
        'Innovaciones_Totales',
        'Capacidad_Tecnologica',
        'Coordinacion_Promedio'
    ]
    if 'Factores_Innovacion' in tabla_sector.columns:
        new_column_names.append('Factores_Innovacion')
    if 'Factores_Productividad' in tabla_sector.columns:
        new_column_names.append('Factores_Productividad')

    # Check if the number of new column names matches the DataFrame columns before assigning
    if len(new_column_names) == len(tabla_sector.columns):
        tabla_sector.columns = new_column_names
    else:
        print(f"Error: Column name mismatch in tabla_analisis_sectorial. Expected {len(tabla_sector.columns)} columns, got {len(new_column_names)}.")
        print(f"DataFrame columns: {tabla_sector.columns}")
        print(f"New column names: {new_column_names}")
        # Optionally, return the DataFrame without renaming or raise a more specific error
        return tabla_sector


    # Guardar tabla
    tabla_sector.to_csv(os.path.join(save_path, 'tabla_analisis_sectorial.csv'), encoding='utf-8')
    print("\n=== TABLA ANÁLISIS SECTORIAL ===")
    print(tabla_sector)
    return tabla_sector

def crear_visualizaciones_completas(modelo: ModeloEconomicoRegional, resultados: pd.DataFrame, resumen: pd.DataFrame):
    """Crea todas las visualizaciones separadas por tipo de análisis"""
    # Configurar matplotlib para evitar problemas de renderizado
    plt.switch_backend("Agg")

    # Define the save path in Google Drive
    save_path = '/content/drive/MyDrive/modelo_economico_resultados'
    os.makedirs(save_path, exist_ok=True)

    print(f"Generando visualizaciones separadas en {save_path}...")

    # Create the figure and gridspec objects
    fig = plt.figure(figsize=(20, 24))
    gs = fig.add_gridspec(4, 4, height_ratios=[1, 1, 1, 1])


    # Crear cada visualización por separado
    crear_visualizacion_analisis_nacional(resultados, resumen, save_path)
    print("✓ Análisis Nacional guardado")

    crear_visualizacion_analisis_regional(modelo, resultados, save_path)
    print("✓ Análisis Regional guardado")

    crear_visualizacion_analisis_aglomeraciones(resultados, save_path)
    print("✓ Análisis Aglomeraciones guardado")

    crear_visualizacion_analisis_sectorial(resultados, save_path)
    print("✓ Análisis Sectorial guardado")

    crear_visualizacion_analisis_corporativo(resultados, save_path)
    print("✓ Análisis Corporativo guardado")

    crear_visualizacion_analisis_entorno(resultados, save_path)
    print("✓ Análisis Entorno guardado")

    # Crear tablas separadas
    print("\nGenerando tablas de análisis...")
    crear_tabla_resumen_regional(modelo, resultados, save_path)
    print("✓ Tabla Resumen Regional guardada")

    crear_tabla_analisis_aglomeraciones(resultados, save_path)
    print("✓ Tabla Análisis Aglomeraciones guardada")

    crear_tabla_analisis_sectorial(resultados, save_path)
    print("✓ Tabla Análisis Sectorial guardada")

    print(f"\n¡Todas las visualizaciones y tablas generadas por separado en {save_path}!")

    # 1. Evolución de capacidad tecnológica promedio
    ax1 = fig.add_subplot(gs[0, 0])
    ax1.plot(resumen['paso'], resumen['capacidad_tecnologica'], 'b-', linewidth=2, label='Promedio nacional')
    ax1.set_title('Evolución de Capacidad Tecnológica\n(Análisis nacional)', fontweight='bold')
    ax1.set_xlabel('Paso de simulación')
    ax1.set_ylabel('Capacidad Tecnológica')
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # 2. Porcentaje de regiones atrapadas
    ax2 = fig.add_subplot(gs[0, 1])
    ax2.plot(resumen['paso'], resumen['porcentaje_atrapadas'], 'r-', linewidth=2)
    ax2.set_title('Regiones en Trampa de Innovación\n(Análisis regional)', fontweight='bold')
    ax2.set_xlabel('Paso de simulación')
    ax2.set_ylabel('Porcentaje de regiones (%)')
    ax2.grid(True, alpha=0.3)

    # 3. Diversidad sectorial promedio
    ax3 = fig.add_subplot(gs[0, 2])
    ax3.plot(resumen['paso'], resumen['diversidad_sectorial'], 'g-', linewidth=2)
    ax3.set_title('Diversidad sectorial\n(Especialización vs diversificación)', fontweight='bold')
    ax3.set_xlabel('Paso de simulación')
    ax3.set_ylabel('Índice de diversidad')
    ax3.grid(True, alpha=0.3)

    # 4. Coordinación económica promedio
    ax4 = fig.add_subplot(gs[0, 3])
    ax4.plot(resumen['paso'], resumen['coordinacion_promedio'], 'purple', linewidth=2)
    ax4.set_title('Coordinación económica\n(Condiciones del entorno)', fontweight='bold')
    ax4.set_xlabel('Paso de simulación')
    ax4.set_ylabel('Índice de coordinación')
    ax4.grid(True, alpha=0.3)

    # ANÁLISIS REGIONAL POR CONGLOMERADOS
    # 5. Capacidad tecnológica por región
    ax5 = fig.add_subplot(gs[1, 0])
    capacidad_regional = resultados.groupby('tipo_region')['capacidad_tecnologica'].mean().sort_values(ascending=True)
    capacidad_regional.plot(kind='barh', ax=ax5, color='skyblue')
    ax5.set_title('Capacidad Tecnológica por región\n(Análisis regional)', fontweight='bold')
    ax5.set_xlabel('Capacidad Tecnológica')

    # 6. Innovaciones por región
    ax6 = fig.add_subplot(gs[1, 1])
    innovaciones_regional = resultados.groupby('tipo_region')['innovaciones_realizadas'].sum().sort_values(ascending=True)
    innovaciones_regional.plot(kind='barh', ax=ax6, color='lightgreen')
    ax6.set_title('Innovaciones totales por región\n(Desarrollo tecnológico)', fontweight='bold')
    ax6.set_xlabel('Número de innovaciones')

    # 7. Carencias educativas (inverso de coordinación) por región
    ax7 = fig.add_subplot(gs[1, 2])
    carencias_educativas = 1 - resultados.groupby('tipo_region')['coordinacion_promedio'].mean()
    carencias_educativas.plot(kind='barh', ax=ax7, color='orange')
    ax7.set_title('Carencias educativas por región\n(Condiciones del entorno)', fontweight='bold')
    ax7.set_xlabel('Índice de carencias')

    # 8. Nivel de especialización vs diversificación
    ax8 = fig.add_subplot(gs[1, 3])
    diversificacion = resultados.groupby('tipo_region')['diversidad_sectorial'].mean()
    especializacion = 1 - diversificacion
    regions = diversificacion.index
    x = np.arange(len(regions))
    width = 0.35
    ax8.bar(x - width/2, diversificacion, width, label='Diversificación', color='lightblue')
    ax8.bar(x + width/2, especializacion, width, label='Especialización', color='lightcoral')
    ax8.set_title('Diversificación vs especialización\n(Análisis sectorial)', fontweight='bold')
    ax8.set_xlabel('Regiones')
    ax8.set_ylabel('Índice')
    ax8.set_xticks(x)
    ax8.set_xticklabels(regions, rotation=45, ha='right')
    ax8.legend()

    # ANÁLISIS SECTORIAL
    # 9. Distribución sectorial por región
    ax9 = fig.add_subplot(gs[2, 0])
    # Crear matriz sectorial simulada
    regiones = resultados['tipo_region'].unique()
    sectores = ['Alta Tec', 'Media Tec', 'Baja Tec']
    matriz_sectorial = np.random.rand(len(regiones), len(sectores)) * 0.8 + 0.1
    im = ax9.imshow(matriz_sectorial, cmap='Blues', aspect='auto')
    ax9.set_xticks(range(len(sectores)))
    ax9.set_xticklabels(sectores)
    ax9.set_yticks(range(len(regiones)))
    ax9.set_yticklabels(regiones)
    ax9.set_title('Intensidad sectorial por región\n(Análisis sectorial)', fontweight='bold')
    plt.colorbar(im, ax=ax9, label='Intensidad')

    # ANÁLISIS CORPORATIVO
    # 10. Productividad promedio por región
    ax10 = fig.add_subplot(gs[2, 1])
    productividad_regional = resultados.groupby('tipo_region')['productividad_promedio'].mean().sort_values(ascending=True)
    productividad_regional.plot(kind='barh', ax=ax10, color='gold')
    ax10.set_title('Productividad por región\n(Análisis corporativo)', fontweight='bold')
    ax10.set_xlabel('Productividad')

    # 11. Eficiencia de asignación
    ax11 = fig.add_subplot(gs[2, 2])
    eficiencia_regional = resultados.groupby('tipo_region')['eficiencia_asignacion'].mean()
    ax11.pie(eficiencia_regional.values, labels=eficiencia_regional.index, autopct='%1.1f%%')
    ax11.set_title('Eficiencia de Asignación\n(Efectividad del Sistema)', fontweight='bold')

    # 12. Flujos de conocimiento interno
    ax12 = fig.add_subplot(gs[2, 3])
    flujos_conocimiento = resultados.groupby('tipo_region')['flujos_internos'].sum().sort_values(ascending=True)
    flujos_conocimiento.plot(kind='bar', ax=ax12, color='mediumpurple')
    ax12.set_title('Flujos de conocimiento interno\n(Difusión tecnológica)', fontweight='bold')
    ax12.set_xlabel('Regiones')
    ax12.set_ylabel('Flujos de conocimiento')
    ax12.tick_params(axis='x', rotation=45)

    # RESUMEN DE CONDICIONES DEL ENTORNO
    # 13. Comparación integrada de indicadores
    ax13 = fig.add_subplot(gs[3, :2])
    indicadores_entorno = pd.DataFrame({
        'Capacidad Tecnológica': resultados.groupby('tipo_region')['capacidad_tecnologica'].mean(),
        'Coordinación': resultados.groupby('tipo_region')['coordinacion_promedio'].mean(),
        'Diversificación': resultados.groupby('tipo_region')['diversidad_sectorial'].mean(),
        'Productividad': resultados.groupby('tipo_region')['productividad_promedio'].mean()
    })
    indicadores_entorno.plot(kind='bar', ax=ax13, width=0.8)
    ax13.set_title('Indicadores Integrados de Desarrollo por Región\n(Condiciones del Entorno)', fontweight='bold')
    ax13.set_xlabel('Regiones')
    ax13.set_ylabel('Valor del indicador')
    ax13.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    ax13.tick_params(axis='x', rotation=45)

    # 14. Trampas de desarrollo por región
    ax14 = fig.add_subplot(gs[3, 2:])
    trampas_regional = resultados.groupby('tipo_region')['atrapada'].mean() * 100
    colors = ['red' if x > 80 else 'orange' if x > 60 else 'green' for x in trampas_regional.values]
    trampas_regional.plot(kind='bar', ax=ax14, color=colors)
    ax14.set_title('Regiones en Trampa de Innovación\n(Análisis integral de políticas)', fontweight='bold')
    ax14.set_xlabel('Regiones')
    ax14.set_ylabel('Porcentaje atrapadas (%)')
    ax14.tick_params(axis='x', rotation=45)
    ax14.axhline(y=70, color='red', linestyle='--', alpha=0.7, label='Umbral 70%')
    ax14.legend()

    # TÍTULO GENERAL
    fig.suptitle('ANÁLISIS INTEGRAL DE POLÍTICAS DE CIENCIA Y TECNOLOGÍA\nRegional • Sectorial • Corporativo',
                 fontsize=16, fontweight='bold', y=0.98)

    plt.tight_layout()
    plt.subplots_adjust(top=0.94)
    ax4.set_xlabel('Tipo de región')
    ax4.set_ylabel('Número de regiones')
    ax4.legend(title='Etapa económica', bbox_to_anchor=(1.05, 1), loc='upper left')
    ax4.tick_params(axis='x', rotation=45)

    # 5. Productividad por tipo de región
    ax5 = fig.add_subplot(gs[1, 1])
    datos_prod = resultados.groupby('tipo_region')['productividad_promedio'].mean()
    datos_prod.plot(kind='bar', ax=ax5, color=['skyblue', 'lightcoral', 'lightgreen', 'gold'])
    ax5.set_title('Productividad promedio por tipo de región', fontweight='bold')
    ax5.set_xlabel('Tipo de Región')
    ax5.set_ylabel('Productividad Promedio')
    ax5.tick_params(axis='x', rotation=45)
    ax5.grid(True, alpha=0.3)

    # 6. Innovación acumulada
    ax6 = fig.add_subplot(gs[1, 2])
    ax6.plot(resumen['paso'], resumen['innovaciones_realizadas'].cumsum(), 'purple', linewidth=2)
    ax6.set_title('Innovaciones acumuladas', fontweight='bold')
    ax6.set_xlabel('Paso de simulación')
    ax6.set_ylabel('Número de innovaciones')
    ax6.grid(True, alpha=0.3)

    # 7. Coordinación económica por región
    ax7 = fig.add_subplot(gs[2, 0])
    datos_coordinacion = resultados.groupby('tipo_region')['coordinacion_promedio'].mean()
    datos_coordinacion.plot(kind='bar', ax=ax7, color=['skyblue', 'lightcoral', 'lightgreen', 'gold'])
    ax7.set_title('Coordinación económica por tipo de región', fontweight='bold')
    ax7.set_xlabel('Tipo de región')
    ax7.set_ylabel('Coordinación promedio')
    ax7.tick_params(axis='x', rotation=45)
    ax7.grid(True, alpha=0.3)

    # 8. Evolución de empleo especializado
    ax8 = fig.add_subplot(gs[2, 1])
    ax8.plot(resumen['paso'], resumen['empleo_especializado'], 'orange', linewidth=2, label='Especializado')
    ax8.plot(resumen['paso'], resumen['empleo_total'] - resumen['empleo_especializado'], 'gray', linewidth=2, label='General')
    ax8.set_title('Evolución del empleo', fontweight='bold')
    ax8.set_xlabel('Paso de simulación')
    ax8.set_ylabel('Número de empleados')
    ax8.legend()
    ax8.grid(True, alpha=0.3)

    # 9. Eficiencia de asignación
    ax9 = fig.add_subplot(gs[2, 2])
    ax9.plot(resumen['paso'], resumen['eficiencia_asignacion'], 'brown', linewidth=2)
    ax9.set_title('Eficiencia de asignación de recursos', fontweight='bold')
    ax9.set_xlabel('Paso de simulación')
    ax9.set_ylabel('Eficiencia')
    ax9.grid(True, alpha=0.3)

    # 10. Distribución final de capacidad tecnológica
    ax10 = fig.add_subplot(gs[3, 0])
    resultados_finales = resultados[resultados['paso'] == resultados['paso'].max()]
    for tipo_region in resultados_finales['tipo_region'].unique():
        datos_tipo = resultados_finales[resultados_finales['tipo_region'] == tipo_region]
        ax10.hist(datos_tipo['capacidad_tecnologica'], alpha=0.6, label=tipo_region, bins=10)
    ax10.set_title('Distribución final de Capacidad Tecnológica', fontweight='bold')
    ax10.set_xlabel('Capacidad Tecnológica')
    ax10.set_ylabel('Frecuencia')
    ax10.legend()
    ax10.grid(True, alpha=0.3)

    # 11. Correlación diversidad vs productividad
    ax11 = fig.add_subplot(gs[3, 1])
    for tipo_region in resultados_finales['tipo_region'].unique():
        datos_tipo = resultados_finales[resultados_finales['tipo_region'] == tipo_region]
        ax11.scatter(datos_tipo['diversidad_sectorial'], datos_tipo['productividad_promedio'],
                    alpha=0.7, label=tipo_region, s=50)
    ax11.set_title('Diversidad vs productividad (Final)', fontweight='bold')
    ax11.set_xlabel('Diversidad sectorial')
    ax11.set_ylabel('Productividad promedio')
    ax11.legend()
    ax11.grid(True, alpha=0.3)

    # 12. Flujos internos
    ax12 = fig.add_subplot(gs[3, 2])
    ax12.plot(resumen['paso'], resumen['flujos_internos'], 'teal', linewidth=2)
    ax12.set_title('Flujos comerciales internos', fontweight='bold')
    ax12.set_xlabel('Paso de simulación')
    ax12.set_ylabel('Flujos internos')
    ax12.grid(True, alpha=0.3)

    plt.suptitle('Análisis completo del modelo económico regional pptimizado', fontsize=16, fontweight='bold')
    plt.tight_layout(rect=[0, 0, 1, 0.96])

    # Guardar gráfico
    plt.savefig(os.path.join(save_path, 'analisis_modelo_economico_optimizado.png'), dpi=300, bbox_inches='tight')
    plt.show()

    # Crear resumen de métricas por tipo de región
    crear_resumen_regional(resultados)

def crear_resumen_regional(resultados: pd.DataFrame):
    """Crea un resumen detallado por tipo de región"""
    print("\n=== ANÁLISIS POR TIPO DE REGIÓN ===")

    resumen_regional = resultados.groupby('tipo_region').agg({
        'capacidad_tecnologica': 'mean',
        'productividad_promedio': 'mean',
        'diversidad_sectorial': 'mean',
        'coordinacion_promedio': 'mean',
        'empleo_especializado': 'mean',
        'atrapada': 'mean',
        'innovaciones_realizadas': 'sum'
    }).round(3)

    print("\nMétricas Promedio por Tipo de Región:")
    print(resumen_regional)

    # Análisis de evolución de etapas
    print("\n=== EVOLUCIÓN DE ETAPAS ECONÓMICAS ===")
    evolucion_etapas = resultados.groupby(['tipo_region', 'etapa_economica']).size().unstack(fill_value=0)
    print("\nDistribución de etapas por tipo de región:")
    print(evolucion_etapas)

    # Identificar características distintivas
    print("\n=== CARACTERÍSTICAS DISTINTIVAS POR REGIÓN ===")
    for tipo_region in resultados['tipo_region'].unique():
        datos_region = resultados[resultados['tipo_region'] == tipo_region]
        innovaciones_totales = datos_region['innovaciones_realizadas'].sum()
        regiones_atrapadas_pct = datos_region['atrapada'].mean() * 100

        print(f"\n{tipo_region.upper()}:")
        print(f"  - Total de innovaciones: {innovaciones_totales}")
        print(f"  - Regiones atrapadas: {regiones_atrapadas_pct:.1f}%")
        print(f"  - Productividad promedio: {datos_region['productividad_promedio'].mean():.3f}")
        print(f"  - Diversidad sectorial: {datos_region['diversidad_sectorial'].mean():.3f}")

def generar_reportes_cyt(modelo: ModeloEconomicoRegional, resultados: pd.DataFrame, save_path: str):
    """Genera reportes específicos para políticas de C&T"""

    # Ejecutar análisis de políticas CT
    analisis_regional = modelo.analizar_politicas_cyt_regional(resultados)
    analisis_sectorial = modelo.analizar_politicas_cyt_sectorial(resultados)
    analisis_corporativo = modelo.analizar_politicas_cyt_corporativo(resultados)

    # Generar reporte completo
    reporte_completo = "# REPORTE INTEGRAL DE POLÍTICAS DE CIENCIA Y TECNOLOGÍA\n\n"
    reporte_completo += "## ÁMBITO REGIONAL POR CONGLOMERADOS\n\n"

    for region, datos in analisis_regional.items():
        reporte_completo += f"### {region.replace('_', ' ').title()}\n\n"
        reporte_completo += "**Métricas de C&T:**\n"
        reporte_completo += f"- Capacidad tecnológica promedio: {datos['metricas_cyt']['capacidad_tecnologica_promedio']:.3f}\n"
        reporte_completo += f"- Innovaciones totales: {datos['metricas_cyt']['innovaciones_total']}\n"
        reporte_completo += f"- Innovaciones promedio por región: {datos['metricas_cyt']['innovaciones_promedio']:.2f}\n"
        reporte_completo += f"- Coordinación económica: {datos['metricas_cyt']['coordinacion_economica']:.3f}\n"
        reporte_completo += f"- Flujos de conocimiento interno: {datos['metricas_cyt']['flujos_conocimiento_interno']:.2f}\n"
        reporte_completo += f"- Eficiencia de asignación: {datos['metricas_cyt']['eficiencia_asignacion']:.3f}\n"
        reporte_completo += f"- Regiones atrapadas: {datos['metricas_cyt']['porcentaje_atrapadas']:.1f}%\n\n"

        reporte_completo += "**Condiciones del Entorno:**\n"
        reporte_completo += f"- Carencias educativas: {datos['condiciones_entorno']['carencias_educativas']:.3f}\n"
        reporte_completo += f"- Nivel de diversificación: {datos['condiciones_entorno']['nivel_diversificacion']:.3f}\n"
        reporte_completo += f"- Nivel de especialización: {datos['condiciones_entorno']['nivel_especializacion']:.3f}\n"
        reporte_completo += f"- Capacidad de absorción: {datos['condiciones_entorno']['capacidad_absorcion']:.3f}\n"
        reporte_completo += f"- Efectividad del sistema de innovación: {datos['condiciones_entorno']['efectividad_sistema_innovacion']:.3f}\n\n"

        reporte_completo += "**Recomendaciones de Políticas C&T:**\n"
        for rec in datos['politicas_recomendadas']:
            reporte_completo += f"- {rec}\n"
        reporte_completo += "\n"

    reporte_completo += "## ÁMBITO SECTORIAL POR TIPOS\n\n"

    for sector, datos in analisis_sectorial.items():
        reporte_completo += f"### {sector.replace('_', ' ').title()}\n\n"
        reporte_completo += "**Métricas de C&T Sectorial:**\n"
        reporte_completo += f"- Presencia en {datos['metricas_cyt']['regiones_con_sector']} regiones\n"
        reporte_completo += f"- Innovaciones promedio: {datos['metricas_cyt']['innovaciones_promedio']:.2f}\n"
        reporte_completo += f"- Productividad promedio: {datos['metricas_cyt']['productividad_promedio']:.3f}\n"
        reporte_completo += f"- Coordinación interregional: {datos['metricas_cyt']['coordinacion_interregional']:.3f}\n"
        reporte_completo += f"- Capacidad tecnológica: {datos['metricas_cyt']['capacidad_tecnologica']:.3f}\n\n"

        reporte_completo += "**Especialización Sectorial:**\n"
        reporte_completo += f"- Grado de especialización: {datos['especializacion']['grado_especializacion']:.3f}\n"
        reporte_completo += f"- Concentración geográfica: {datos['especializacion']['concentracion_geografica']:.3f}\n"
        reporte_completo += f"- Difusión tecnológica: {datos['especializacion']['difusion_tecnologica']:.3f}\n\n"
        reporte_completo += f"**Regiones predominantes:** {list(datos['regiones_predominantes'].keys())[:3]}\n\n"

    reporte_completo += "## ÁMBITO CORPORATIVO/EMPRESARIAL POR TECNOLOGÍAS\n\n"

    reporte_completo += "### Análisis por Tamaño Corporativo\n\n"
    for region, datos in analisis_corporativo['por_tamaño_corporativo'].items():
        reporte_completo += f"**{region.title()}:**\n"
        reporte_completo += f"- Corporaciones grandes: {datos['corporaciones_grandes']}\n"
        reporte_completo += f"- Corporaciones pequeñas: {datos['corporaciones_pequeñas']}\n"
        reporte_completo += f"- Ratio grandes/pequeñas: {datos['ratio_grandes_pequenas']:.2f}\n"
        reporte_completo += f"- Capacidad promedio grandes: {datos['capacidades_promedio_grandes']:.3f}\n"
        reporte_completo += f"- Capacidad promedio pequeñas: {datos['capacidades_promedio_pequenas']:.3f}\n\n"

    reporte_completo += "### Análisis por Nivel Tecnológico\n\n"
    for nivel, datos in analisis_corporativo['por_tecnologia'].items():
        reporte_completo += f"**{nivel.replace('_', ' ').title()}:**\n"
        reporte_completo += f"- Regiones con tecnología: {datos['regiones_con_tecnologia']}\n"
        reporte_completo += f"- Innovaciones promedio: {datos['innovaciones_promedio']:.2f}\n"
        reporte_completo += f"- Coordinación promedio: {datos['coordinacion_promedio']:.3f}\n"
        reporte_completo += f"- Productividad promedio: {datos['productividad_promedio']:.3f}\n"
        reporte_completo += f"- Tasa de atrapamiento: {datos['tasa_atrapamiento']:.1f}%\n\n"

    # Guardar reporte
    with open(os.path.join(save_path, 'REPORTE_POLITICAS_CYT_INTEGRAL.md'), 'w', encoding='utf-8') as f:
        f.write(reporte_completo)

    return reporte_completo

if __name__ == "__main__":
    # Ejecutar análisis completo
    modelo, resultados, resumen = ejecutar_analisis_completo()

    # Define the save path in Google Drive
    save_path = '/content/drive/MyDrive/modelo_economico_resultados'
    os.makedirs(save_path, exist_ok=True)

    # Crear visualizaciones separadas por tipo de análisis
    crear_visualizaciones_completas(modelo, resultados, resumen)

    # Generar reportes de políticas CT
    reporte_cyt = generar_reportes_cyt(modelo, resultados, save_path)

    # Guardar resultados
    resultados.to_csv(os.path.join(save_path, 'resultados_modelo_economico.csv'), index=False)
    resumen.to_csv(os.path.join(save_path, 'resumen_modelo_economico.csv'), index=False)

    print(f"\n=== ARCHIVOS GENERADOS ===")
    print("📊 GRÁFICAS SEPARADAS:")
    print(f"  Guardadas en {save_path}")
    print("\n📋 TABLAS DE ANÁLISIS:")
    print(f"  Guardadas en {save_path}")
    print("\n📄 DATOS Y REPORTES:")
    print(f"  • resultados_modelo_economico.csv: Datos detallados por región y paso (guardado en {save_path})")
    print(f"  • resumen_modelo_economico.csv: Resumen por paso de simulación (guardado en {save_path})")
    print(f"  • REPORTE_POLITICAS_CYT_INTEGRAL.md: Análisis integral de políticas C&T (guardado en {save_path})")
    print("\n¡Análisis de políticas de C&T completado exitosamente!")