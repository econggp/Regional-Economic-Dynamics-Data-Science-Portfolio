# -*- coding: utf-8 -*-
"""abm_validación.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BjC5Sl7CVhRDIksFsVz7vUAQDWBnVnQj
"""

import numpy as np
import pandas as pd
import random
import matplotlib.pyplot as plt
import seaborn as sns
from collections import defaultdict
from matplotlib.gridspec import GridSpec


# === Parámetros globales ===
WORKER_POOL_SIZE = 500
NUM_REGIONS = 32
INITIAL_TECH = 0.12
POLICY_SUPPORT_INNOVATION = 0.2
TRAP_ESCAPE_PROBABILITY = 0.02
EDUCATION_INVESTMENT_RATE = 0.03
KNOWLEDGE_SPILLOVER = 0.1
DIVERSITY_INNOVATION_BONUS = 0.1
SKILL_MISMATCH_PENALTY = 0.5
MIN_INNOVATION_THRESHOLD = 0.2
INNOVATION_BASE_RATE = 0.04
ECONOMIC_CYCLE_LENGTH = 20

SECTOR_PARAMS = {
    'manufacturing': {'tech_intensity': 0.7, 'skill_required': (0.6, 0.8), 'innovation_factor': 0.05,
                      'margin_range': (0.25, 0.4), 'volatility': 0.15, 'training_investment': 0.2,
                      'productivity': 32.5, 'product_range': (8, 18)},
    'services': {'tech_intensity': 0.8, 'skill_required': (0.7, 0.9), 'innovation_factor': 0.08,
                 'margin_range': (0.2, 0.4), 'volatility': 0.15, 'training_investment': 0.1,
                 'productivity': 6.5, 'product_range': (3, 7)},
    'agriculture': {'tech_intensity': 0.2, 'skill_required': (0.3, 0.5), 'innovation_factor': 0.01,
                    'margin_range': (0.2, 0.4), 'volatility': 0.15, 'training_investment': 0.05,
                    'productivity': 8.7, 'product_range': (6, 10)},
    'tourism': {'tech_intensity': 0.1, 'skill_required': (0.2, 0.4), 'innovation_factor': 0.005,
                'margin_range': (0.3, 0.6), 'volatility': 0.3, 'training_investment': 0.1,
                'productivity': 12.8, 'product_range': (5, 9)}
}

SECTOR_DISTRIBUTION = {k: v['tech_intensity'] for k, v in SECTOR_PARAMS.items()}


# === Clase Worker ===
class Worker:
    def __init__(self, sector_type=None):
        if sector_type:
            req_skill = SECTOR_PARAMS[sector_type]['skill_required']
            self.skill = random.uniform(max(0.1, req_skill[0] - 0.2), min(1.0, req_skill[1] + 0.2))
        else:
            self.skill = random.uniform(0.1, 0.6)
        self.experience = 0
        self.employed = False
        self.region_id = None
        self.sector_type = sector_type or random.choice(list(SECTOR_PARAMS.keys()))

    def improve_skills(self, training_investment=0.1):
        improvement = training_investment * (1 - self.skill) * random.uniform(0.05, 0.2)
        self.skill = min(1.0, self.skill + improvement)
        self.experience += 1


# === Clase Product ===
class Product:
    def __init__(self, sector_type, product_id):
        params = SECTOR_PARAMS[sector_type]
        self.id = product_id
        self.name = f"Product_{sector_type}_{product_id}"
        self.revenue = random.uniform(*params['product_range'])
        self.cost = random.uniform(0.4, 0.8) * self.revenue
        self.production = random.uniform(3, 16)
        self.tech_intensity = random.uniform(0.1, params['tech_intensity'])
        self.skill_required = random.uniform(*params['skill_required'])

    def calculate_margin(self):
        return (self.revenue - self.cost) / self.revenue


# === Clase Workforce ===
class Workforce:
    def __init__(self):
        self.workers = []
        self.qualification_gap = 0.0
        self.training_investment = 0.1

    def hire_workers(self, num_workers, worker_pool):
        hired = 0
        available_workers = [w for w in worker_pool if not w.employed]
        for worker in available_workers[:num_workers]:
            worker.employed = True
            worker.region_id = id(self)
            self.workers.append(worker)
            hired += 1
        return hired

    def evaluate_workers(self):
        if self.workers:
            avg_skill = np.mean([w.skill for w in self.workers])
            skill_requirements = [p.skill_required for p in getattr(self, 'products', [])]
            if skill_requirements:
                avg_requirement = np.mean(skill_requirements)
                self.qualification_gap = max(0, avg_requirement - avg_skill)

    def train_workers(self, tech_level):
        for worker in self.workers:
            worker.improve_skills(self.training_investment * (1 + tech_level))


# === Clase Region ===
class Region:
    def __init__(self, region_id, worker_pool, sector=None, params=None):
        self.id = region_id
        self.worker_pool = worker_pool
        self.params = params or {}
        self.sector_type = sector or random.choice(list(SECTOR_PARAMS.keys()))
        self.tech_capability = random.uniform(0.2, 0.7)
        self.innovation_rate = SECTOR_PARAMS[self.sector_type]['innovation_factor']
        self.productivity = 1.0
        self.specialization = 1.0
        self.diversification = 0.0
        self.employment_rate = random.uniform(0.6, 0.9)
        self.trapped = False
        self.products = []
        self.workforce = Workforce()
        self.workforce.products = self.products

    def update(self):
        self.apply_shocks()
        self.make_strategic_decision()
        self.adjust_products()
        self.update_workforce()
        self.update_performance()
        self.check_innovation_trap()

    def apply_shocks(self):
        if random.random() < 0.05:
            shock = random.uniform(-0.2, 0.1)
            self.productivity *= (1 + shock)

    def make_strategic_decision(self):
        tech_invest_prob = POLICY_SUPPORT_INNOVATION * self.tech_capability
        if random.random() < tech_invest_prob:
            self.innovation_rate *= 1.02
            self.tech_capability *= 1.01

    def adjust_products(self):
        if len(self.products) > 0 and random.random() < 0.02:
            self.products.pop(random.randint(0, len(self.products) - 1))
        if random.random() < 0.03:
            new_product = Product(self.sector_type, len(self.products))
            self.products.append(new_product)

    def update_workforce(self):
        target_size = int(WORKER_POOL_SIZE / NUM_REGIONS)
        needed = max(0, target_size - len(self.workforce.workers))
        self.workforce.hire_workers(needed, self.worker_pool)

    def update_performance(self):
        if self.workforce.workers:
            avg_skill = np.mean([w.skill for w in self.workforce.workers])
            self.productivity = 0.6 * avg_skill + 0.4 * self.tech_capability
            self.diversification = DIVERSITY_INNOVATION_BONUS * random.random()
            self.specialization = 1 - self.diversification
            self.workforce.evaluate_workers()

    def check_innovation_trap(self):
        conditions = [
            self.tech_capability < 0.35,
            self.innovation_rate < 0.04,
            np.mean([w.skill for w in self.workforce.workers]) if self.workforce.workers else 0 < 0.4,
            self.diversification < 0.2,
            self.productivity < 0.6
        ]
        self.trapped = sum(conditions) >= 3


# === Modelo Principal ===
class EconomicModel:
    def __init__(self, n_regions=32, params=None):
        self.params = params or {}
        self.worker_pool = [Worker() for _ in range(WORKER_POOL_SIZE)]
        self.regions = []

        # Distribución inicial de sectores
        total_prob = sum(SECTOR_DISTRIBUTION.values())
        normalized_dist = {k: v / total_prob for k, v in SECTOR_DISTRIBUTION.items()}
        self.sector_distribution = normalized_dist

        # Crear regiones con atributos sectoriales aleatorios
        for i in range(n_regions):
            sector_type = random.choices(
                list(self.sector_distribution.keys()),
                weights=self.sector_distribution.values(),
                k=1
            )[0]
            self.regions.append(Region(i, self.worker_pool, sector=sector_type))

        # Historial de simulación
        self.history = []

    def step(self):
        """Avanza la simulación un paso"""
        for region in random.sample(self.regions, len(self.regions)):
            region.update()
        self.record_state()

    def run(self, steps=30):
        """Ejecuta la simulación"""
        for _ in range(steps):
            self.step()
        return pd.DataFrame(self.history)

    def record_state(self):
        current_state = {
            'step': len(self.history),
            'avg_tech': np.mean([r.tech_capability for r in self.regions]),
            'avg_innovation': np.mean([r.innovation_rate for r in self.regions]),
            'avg_productivity': np.mean([r.productivity for r in self.regions]),
            'avg_skill': np.mean([w.skill for r in self.regions for w in r.workforce.workers]),
            'diversification': np.mean([r.diversification for r in self.regions]),
            'num_trapped': sum(r.trapped for r in self.regions)
        }
        self.history.append(current_state)

    def get_agent_data(self):
        data = []
        for region in self.regions:
            for worker in region.workforce.workers:
                data.append({
                    'region_id': region.id,
                    'sector': region.sector_type,
                    'tech': region.tech_capability,
                    'innovation': region.innovation_rate,
                    'productivity': region.productivity,
                    'trapped': region.trapped,
                    'worker_skill': worker.skill,
                    'experience': worker.experience
                })
        return pd.DataFrame(data)


# === Funciones auxiliares ===
def run_multiple_simulations(model_class, num_runs=10, steps=30):
    all_results = []
    for i in range(num_runs):
        model = model_class()
        results = model.run(steps)
        results['run_id'] = i + 1
        all_results.append(results)
    return pd.concat(all_results, ignore_index=True)

def check_stability_and_convergence(df, metric='avg_tech', threshold=0.01):
    stability = df.groupby('step')[metric].agg(['mean', 'std']).reset_index()
    last_steps = stability.iloc[-5:]
    max_change = last_steps['mean'].diff().abs().max()
    print(f"Convergencia: {'✅' if max_change < threshold else '⚠️'} Cambio máximo: {max_change:.4f}")
    return max_change < threshold

def sensitivity_analysis(model_class, param_name, param_values, metric='avg_tech', steps=30):
    results = []
    for value in param_values:
        params = {param_name: value}
        model = model_class(n_regions=NUM_REGIONS, params=params)
        output = model.run(steps)
        final_value = output[metric].iloc[-1]
        results.append({'param': value, 'final_metric': final_value})
    result_df = pd.DataFrame(results)
    print("Análisis de Sensibilidad:")
    print(result_df)
    plt.plot(result_df['param'], result_df['final_metric'], marker='o')
    plt.xlabel(param_name)
    plt.ylabel(metric)
    plt.title(f"Sensibilidad de '{metric}' a '{param_name}'")
    plt.grid(True)
    plt.show()

def visualize_results_individual(model_df, agent_df):
    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    for label, col in [('Nivel Tecnológico Promedio', 'avg_tech'),
                       ('Desigualdad Tecnológica', 'std_tech')]:
        if col in model_df.columns:
            ax1.plot(model_df['step'], model_df[col], label=label)
    ax2 = ax1.twinx()
    if 'avg_innovation' in model_df.columns:
        ax2.plot(model_df['step'], model_df['avg_innovation'], label='Innovación', color='black', linestyle='--')
    ax1.set_title('Evolución de Indicadores Tecnológicos y de Innovación')
    ax1.legend(loc='upper left'), ax2.legend(loc='upper right')
    plt.grid(True)
    plt.show()

    # Calificaciones vs TI
    trapped_comparison = agent_df.groupby('trapped').agg({'worker_skill': 'mean', 'tech': 'mean'})
    print("Comparativa entre regiones atrapadas:")
    print(trapped_comparison.round(3))


# === Ejecutar modelo ===
if __name__ == "__main__":
    model = EconomicModel()
    model_df = model.run(steps=30)
    agent_df = model.get_agent_data()

    # Validación múltiple
    multi_run_df = run_multiple_simulations(EconomicModel, num_runs=10, steps=30)
    check_stability_and_convergence(multi_run_df)

    # Análisis de sensibilidad
    sensitivity_analysis(EconomicModel, 'POLICY_SUPPORT_INNOVATION', [0.1, 0.2, 0.3])
    sensitivity_analysis(EconomicModel, 'EDUCATION_INVESTMENT_RATE', [0.1, 0.2, 0.3])
    sensitivity_analysis(EconomicModel, 'KNOWLEDGE_SPILLOVER', [0.1, 0.2, 0.3])
    sensitivity_analysis(EconomicModel, 'DIVERSITY_INNOVATION_BONUS', [0.1, 0.2, 0.3])

    # Visualización
    visualize_results_individual(model_df, agent_df)