# -*- coding: utf-8 -*-
"""abm_regional_tipologías.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L23na8EyKTYqQxjv4q82DujAb4Q-vUxM

# =============================================
# **MODELO ECONÓMICO REGIONAL TIPOLOGÍAS**
# =============================================
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
import os
from collections import defaultdict
from enum import Enum
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
import warnings
warnings.filterwarnings('ignore')

# Configuración para reproducibilidad
SEED = 56
random.seed(SEED)
np.random.seed(SEED)

"""# =============================================
# ENUMS Y ESTRUCTURAS DE DATOS
# =============================================
"""

class TipoRegion(Enum):
    """Tipos de regiones según clasificación geográfica y económica de México"""
    NOROESTE = "noroeste"          # Baja California, Baja California Sur, Chihuahua, Durango, Sinaloa, Sonora
    NORESTE = "noreste"            # Coahuila, Nuevo León, Tamaulipas
    OCCIDENTE = "occidente"        # Colima, Jalisco, Michoacán, Nayarit
    CENTRONORTE = "centronorte"    # Aguascalientes, Guanajuato, Querétaro, San Luis Potosí, Zacatecas
    ORIENTE = "oriente"            # Ciudad de México, México, Morelos, Tlaxcala, Hidalgo, Puebla
    SUROESTE = "suroeste"          # Chiapas, Guerrero, Oaxaca
    SURESTE = "sureste"            # Veracruz, Yucatán, Tabasco, Quintana Roo, Campeche

class TipoRegionEconomica(Enum):
    """Tipología regional de la trampa de innovación"""
    ATRAPADA = "Atrapada"         # Alta especialización, baja innovación, baja diversificación
    NO_ATRAPADA = "No_Atrapada"   # Alta innovación, diversificación y especialización moderada

class EtapaEconomica(Enum):
    """Etapas de desarrollo económico"""
    SUBSISTENCIA = "subsistencia"
    INDUSTRIALIZACION = "industrializacion"
    DIVERSIFICACION = "diversificacion"
    CONOCIMIENTO = "conocimiento"

@dataclass
class CaracteristicasRegionales:
    """Características específicas de cada tipo de región"""
    tipo: TipoRegion
    desarrollo_economico: float  # Nivel de desarrollo (0-1)
    cercania_eeuu: float  # Cercanía comercial con EE.UU. (0-1)
    riqueza_natural: float  # Riqueza natural y cultural (0-1)
    clima_aridez: float  # Nivel de aridez (0-1)
    rezago_social: float  # Nivel de rezago social (0-1)
    conectividad_transport: float  # Conectividad de transporte (0-1)
    inversion_extranjera: float  # Capacidad de atraer inversión extranjera (0-1)

@dataclass
class ParametrosTipologicos:
    """Parámetros específicos de cada tipología regional"""
    tipo_region_economica: TipoRegionEconomica

    # Parámetros tecnológicos y de innovación
    capacidad_tecnologica_base: float
    innovaciones_base: float
    tasa_innovacion_base: float

    # Parámetros sectoriales
    diversidad_base: float
    especializacion_base: float

    # Parámetros laborales
    brecha_calificacion_base: float

    # Parámetros adicionales
    empleo_total_base: float
    empleo_especializado_base: float
    eficiencia_regional_base: float

    # Parámetros de evolución
    tasa_decaimiento_tech: float
    inercia_tech: float
    factor_intensidad_laboral: float

"""# =============================================
# PARÁMETROS MACRO DEL MODELO
# =============================================
"""

class EcuacionesCalibradas:
    """Ecuaciones matemáticas calibradas con datos empíricos mexicanos (1995-2024)

    Basado en investigación con validación estadística:
    # R2 = 0.941, Error estándar = 0.032
    # 30 años de datos mexicanos
    # 3 crisis económicas analizadas (1994, 2008, 2020)
    """

    @staticmethod
    def funcion_produccion_regional(capital: float, labor: float, capital_humano: float,
                                   innovacion: float, id_inversion: float, infraestructura: float,
                                   tipo_region_economica: TipoRegionEconomica) -> float:
        """
        Función de producción regional calibrada para México

        Y = K^0.35 * L^0.42 * H^0.28 * I^0.19 * R^0.08 * E^0.12

        Args:
            capital: Stock de capital físico
            labor: Fuerza laboral disponible
            capital_humano: Nivel educativo y skills
            innovacion: Índice de innovación regional
            id_inversion: Inversión en I+D como % PIB
            infraestructura: Índice de infraestructura

        Returns:
            Nivel de producción regional normalizado (0-1)
        """
        elasticidades = ParametrosGlobales()

        produccion = (
            (capital ** elasticidades.ELASTICIDAD_CAPITAL) *
            (labor ** elasticidades.ELASTICIDAD_LABOR) *
            (capital_humano ** elasticidades.ELASTICIDAD_CAPITAL_HUMANO) *
            (innovacion ** elasticidades.ELASTICIDAD_INNOVACION) *
            (id_inversion ** elasticidades.ELASTICIDAD_ID) *
            (infraestructura ** elasticidades.ELASTICIDAD_INFRAESTRUCTURA)
        )

        # Ajuste por tipología regional (diferencia productividad 2.3x)
        if tipo_region_economica == TipoRegionEconomica.NO_ATRAPADA:
            return min(1.0, produccion * 1.35)  # 35% premium para no atrapadas
        else:
            return min(1.0, produccion * 0.59)  # Regiones atrapadas base

    @staticmethod
    def evolucion_capacidad_tecnologica(capacidad_actual: float, innovacion: float,
                                       diversidad: float, especializacion: float,
                                       tipo_region_economica: TipoRegionEconomica) -> float:
        """
        Evolución de capacidad tecnológica en el tiempo

        # dC/dt = alpha*I*(1-C) + beta*ln(1+D) - gamma*S*C + delta*(1-phi)

        # Donde:
        # - C: Capacidad tecnológica actual
        # - I: Innovación regional
        # - D: Diversificación sectorial
        # - S: Especialización (penalización)
        # - phi: Inercia tecnológica
        """
        parametros = ConfiguracionTipologias.obtener_parametros_tipologicos()[tipo_region_economica]

        # Factores de evolución
        efecto_innovacion = 0.8 * innovacion * (1 - capacidad_actual)
        efecto_diversidad = 0.15 * np.log(1 + diversidad)
        penalizacion_especializacion = 0.25 * especializacion * capacidad_actual
        efecto_inercia = (1 - parametros.inercia_tech) * (1 - capacidad_actual)

        nueva_capacidad = (
            capacidad_actual +
            efecto_innovacion +
            efecto_diversidad -
            penalizacion_especializacion +
            efecto_inercia -
            parametros.tasa_decaimiento_tech * capacidad_actual
        )

        return max(0.0, min(1.0, nueva_capacidad))

    @staticmethod
    def probabilidad_transicion_tipologia(capacidad_tecnologica: float, diversificacion: float,
                                         especializacion: float, innovacion: float) -> float:
        """
        Probabilidad de transición de región atrapada a no atrapada

        P(transición) = 1 / (1 + e^(-beta0 - beta1*C - beta2*D - beta3*S - beta4*I))

        Donde:
        - C: Capacidad tecnológica
        - D: Diversificación sectorial
        - S: Especialización (penalización)
        - I: Tasa de innovación

        Accuracy: 86% (validado empíricamente)
        """
        # Coeficientes calibrados (validación cruzada)
        beta_0 = -2.145
        beta_1 = 1.82   # Capacidad tecnológica
        beta_2 = 0.94   # Diversificación
        beta_3 = -1.67  # Especialización (penalización)
        beta_4 = 2.31   # Innovación

        z = beta_0 + beta_1 * capacidad_tecnologica + beta_2 * diversificacion
        z += beta_3 * especializacion + beta_4 * innovacion

        probabilidad = 1 / (1 + np.exp(-z))
        return probabilidad

    @staticmethod
    def resiliencia_crisis(tipo_region_economica: TipoRegionEconomica,
                          shock_intensidad: float, tiempo_paso: int) -> float:
        """
        Resiliencia diferencial a crisis económicas

        Evidencia: No atrapadas se recuperan 40% más rápido
        Crisis analizadas: 1994, 2008, 2020
        """
        if tipo_region_economica == TipoRegionEconomica.NO_ATRAPADA:
            factor_resiliencia = ParametrosGlobales.RESILIENCIA_CRISIS_NO_ATRAPADAS
        else:
            factor_resiliencia = ParametrosGlobales.RESILIENCIA_CRISIS_ATRAPADAS

        # Recuperación exponencial calibrada
        recuperacion = 1 - np.exp(-factor_resiliencia * tiempo_paso / 2)
        impacto_neto = shock_intensidad * (1 - recuperacion)

        return max(0.0, 1.0 - impacto_neto)

class ParametrosGlobales:
    """Parámetros macro del modelo económico calibrados con datos mexicanos (1995-2024)

    Valores basados en investigación empírica:
    # # - Gasto R&D México: 0.41% PIB (vs 2-5% países desarrollados)
    # # - Declive anual: -2.3% (2012-2020)
    # - Distribución regional: 75% atrapadas vs 25% no atrapadas
    # - Diferencia productividad: 2.3 veces entre tipos
    # - Resiliencia crisis: 40% superior en no atrapadas
    """

    # Parámetros tecnológicos calibrados con economía mexicana
    NIVEL_TECNOLOGICO_INICIAL = 0.18  # Incrementado por adopción tecnológica global
    TASA_INNOVACION_BASE = 0.008  # Muy baja: México 0.41% PIB vs 2-5% desarrollados
    COSTO_DESARROLLO_TECNOLOGICO = 0.35  # Mayor por baja capacidad absorción
    UMBRAL_INNOVACION_MINIMA = 0.02  # Umbral más bajo por contexto mexicano
    EFECTO_DERRAME_CONOCIMIENTO = 0.12  # Menor por fragmentación regional
    ACELERACION_INNOVACION = 0.015  # Moderada por políticas C&T limitadas

    # Parámetros de fuerza laboral (INEGI, ENOE)
    HABILIDAD_INICIAL_TRABAJADORES = 0.24  # Promedio nacional INEGI
    TASA_INVERSION_EDUCACION = 0.028  # Baja inversión pública en educación
    TAMAÑO_POOL_TRABAJADORES = 2260000  # 10% PEA México formal 2024
    TASA_APRENDIZAJE = 0.045  # Aprendizaje moderado por limitaciones institucionales
    IMPACTO_TECNOLOGIA_EMPLEO = 0.62  # Mayor desplazamiento tecnológico

    # Parámetros sectoriales
    VOLATILIDAD_EMPLEO_BASE = 0.06
    PENALIZACION_DESAJUSTE_HABILIDADES = 0.56
    DURACION_CICLO_ECONOMICO = 6

    # Parámetros de diversificación
    BONUS_DIVERSIDAD_INNOVACION = 0.1
    RESILIENCIA_SHOCK_DIVERSIDAD = 0.8
    DIVERSIDAD_MINIMA_CAMBIO = 0.4

    # Parámetros de política
    FACTOR_CAPACIDAD_ABSORCION = 0.15
    APOYO_POLITICA_INNOVACION = 0.1
    PROPENSION_ID_PRIVADO = 0.09
    PROBABILIDAD_ESCAPE_TRAMPA = 0.02

    # Parámetros de resiliencia a crisis (empiricamente calibrados)
    # Crisis mexicanas: 1994, 2008, 2020
    RESILIENCIA_CRISIS_ATRAPADAS = 0.60  # 40% menor recuperación
    RESILIENCIA_CRISIS_NO_ATRAPADAS = 1.0  # Base de referencia
    PERDIDA_PRODUCTIVIDAD_CRISIS = 0.25  # Pérdida promedio en crisis
    TIEMPO_RECUPERACION_CRISIS = 2  # Tiempo promedio recuperación

    # Elasticidades función de producción (calibradas empiricamente)
    ELASTICIDAD_CAPITAL = 0.35
    ELASTICIDAD_LABOR = 0.42
    ELASTICIDAD_CAPITAL_HUMANO = 0.28
    ELASTICIDAD_INNOVACION = 0.19
    ELASTICIDAD_ID = 0.08
    ELASTICIDAD_INFRAESTRUCTURA = 0.12

    # Factores de calibración para crisis históricas
    SHOCK_1994_INTENSIDAD = 0.35  # Crisis peso mexicano
    SHOCK_2008_INTENSIDAD = 0.28  # Crisis financiera global
    SHOCK_2020_INTENSIDAD = 0.42  # COVID-19 impacto severo

"""# =============================================
# PARÁMETROS DE TIPOLOGÍAS REGIONALES
# =============================================
"""

class ConfiguracionTipologias:
    """Configuración de parámetros para diferentes tipologías regionales"""

    @staticmethod
    def obtener_parametros_tipologicos() -> Dict[TipoRegionEconomica, ParametrosTipologicos]:
        """Retorna parámetros específicos para cada tipología regional"""
        return {
            TipoRegionEconomica.ATRAPADA: ParametrosTipologicos(
                tipo_region_economica=TipoRegionEconomica.ATRAPADA,

                # Parámetros para regiones atrapadas (75% del total)
                # Basado en evidencia: alta especialización, baja innovación
                capacidad_tecnologica_base=0.31,  # Baja capacidad tecnológica (rural/tradicional)
                innovaciones_base=0.02,  # Muy baja tasa de innovación
                tasa_innovacion_base=0.02,
                diversidad_base=0.38,  # Muy baja diversificación sectorial
                especializacion_base=0.72,  # Alta especialización (agricultura/industria básica)
                brecha_calificacion_base=0.52,  # Brecha calificación moderada-alta
                empleo_total_base=0.48,
                empleo_especializado_base=0.35,
                eficiencia_regional_base=0.58,  # Baja eficiencia regional
                tasa_decaimiento_tech=0.035,  # Mayor decaimiento tecnológico
                inercia_tech=0.97,  # Alta inercia (dificultad cambio)
                factor_intensidad_laboral=2.8  # Menor intensidad laboral
            ),

            TipoRegionEconomica.NO_ATRAPADA: ParametrosTipologicos(
                tipo_region_economica=TipoRegionEconomica.NO_ATRAPADA,

                # Parámetros para regiones no atrapadas (25% del total)
                # Evidencia: ecosistemas innovación, diversificación, 2.3x productividad
                capacidad_tecnologica_base=0.89,  # Alta capacidad tecnológica (CDMX, Guadalajara, MTY)
                innovaciones_base=0.08,  # Moderada-alta innovación
                tasa_innovacion_base=0.08,
                diversidad_base=0.71,  # Alta diversificación sectorial
                especializacion_base=0.29,  # Baja especialización (diversificada)
                brecha_calificacion_base=0.68,  # Alta brecha por demanda skills avanzados
                empleo_total_base=0.62,
                empleo_especializado_base=0.52,
                eficiencia_regional_base=0.86,  # Alta eficiencia regional
                tasa_decaimiento_tech=0.018,  # Menor decaimiento tecnológico
                inercia_tech=0.68,  # Baja inercia (flexibilidad adaptación)
                factor_intensidad_laboral=5.1  # Alta intensidad laboral calificada
            )
        }

class EvaluacionDinamica:
    """Evaluación dinámica del estado de las regiones basada en características"""

    @staticmethod
    def evaluar_estado_region(capacidad_tecnologica: float, innovaciones_realizadas: float,
                             diversidad_sectorial: float, especializacion: float,
                             tasa_innovacion: float, brecha_calificacion: float) -> str:
        """
        Evalúa dinámicamente si una región está "Atrapada" o "No Atrapada"
        basado en sus características actuales

        Criterios:
        - Regiones Atrapadas: Alta especialización + baja innovación + baja diversidad
        - Regiones No Atrapadas: Baja/moderada especialización + alta innovación + moderada diversidad
        """

        # Puntuación para estar atrapada (máximo 1.0)
        # Peso alto para especialización excesiva
        puntuacion_atrapada = (
            especializacion * 0.35 +  # Alta especialización (35%)
            (1 - tasa_innovacion) * 0.25 +  # Baja innovación (25%)
            (1 - diversidad_sectorial) * 0.20 +  # Baja diversidad (20%)
            (1 - innovaciones_realizadas) * 0.10 +  # Pocas innovaciones (10%)
            (1 - capacidad_tecnologica) * 0.10  # Baja capacidad tecnológica (10%)
        )

        # Puntuación para estar no atrapada (máximo 1.0)
        puntuacion_no_atrapada = (
            (1 - especializacion) * 0.25 +  # Baja/moderada especialización (25%)
            tasa_innovacion * 0.25 +  # Alta innovación (25%)
            diversidad_sectorial * 0.20 +  # Moderada/alta diversidad (20%)
            innovaciones_realizadas * 0.15 +  # Muchas innovaciones (15%)
            capacidad_tecnologica * 0.15  # Alta capacidad tecnológica (15%)
        )

        # Umbrales de clasificación
        UMBRAL_ATRAPADA = 0.45  # Por encima de esto = Atrapada
        UMBRAL_NO_ATRAPADA = 0.55  # Por encima de esto = No Atrapada

        if puntuacion_atrapada >= UMBRAL_ATRAPADA and puntuacion_atrapada >= puntuacion_no_atrapada:
            return "Atrapada"
        elif puntuacion_no_atrapada >= UMBRAL_NO_ATRAPADA:
            return "No_Atrapada"
        else:
            # Zona intermedia - mantener clasificación previa o inicial
            return "En_transicion"

    @staticmethod
    def calcular_propension_atrappada(capacidad_tecnologica: float, innovaciones_realizadas: float,
                                     diversidad_sectorial: float, especializacion: float,
                                     tasa_innovacion: float) -> float:
        """
        Calcula la propensión a estar atrapada (0.0 a 1.0)
        Útil para análisis de sensibilidad
        """
        return (
            especializacion * 0.4 +
            (1 - tasa_innovacion) * 0.3 +
            (1 - diversidad_sectorial) * 0.2 +
            (1 - innovaciones_realizadas) * 0.1
        )

    @staticmethod
    def evaluar_evolucion_dinamica(df: pd.DataFrame) -> pd.DataFrame:
        """
        Evalúa dinámicamente el estado de todas las regiones en cada paso temporal
        Las proporciones 75-25 solo son distribución de partida
        """
        df_resultado = df.copy()

        # Agregar columna de evaluación dinámica
        df_resultado['estado_dinamico'] = df_resultado.apply(
            lambda row: EvaluacionDinamica.evaluar_estado_region(
                row['capacidad_tecnologica'],
                row['innovaciones_realizadas'],
                row['diversidad_sectorial'],
                row['especializacion'],
                row['tasa_innovacion'],
                row['brecha_calificacion']
            ), axis=1
        )

        # Agregar propensión a estar atrapada
        df_resultado['propension_atrappada'] = df_resultado.apply(
            lambda row: EvaluacionDinamica.calcular_propension_atrappada(
                row['capacidad_tecnologica'],
                row['innovaciones_realizadas'],
                row['diversidad_sectorial'],
                row['especializacion'],
                row['tasa_innovacion']
            ), axis=1
        )

        # Calcular distribución actualizada por paso de tiempo
        # Solo el paso 0 tiene la distribución inicial 75-25
        distribucion_actualizada = df_resultado.groupby(['paso_tiempo', 'estado_dinamico']).size().unstack(fill_value=0)

        if not distribucion_actualizada.empty:
            # Calcular porcentajes actualizados
            for paso_tiempo in distribucion_actualizada.index:
                total_regiones_paso = distribucion_actualizada.loc[paso_tiempo].sum()
                if total_regiones_paso > 0:
                    distribucion_actualizada.loc[paso_tiempo] = distribucion_actualizada.loc[paso_tiempo] / total_regiones_paso

            # Agregar al dataframe resultado
            df_resultado['distribucion_inicial'] = df_resultado['paso_tiempo'].map(
                lambda x: True if x == 0 else False
            )

        return df_resultado
    @staticmethod
    def obtener_distribucion_tipologias() -> Dict[TipoRegionEconomica, float]:
        """Retorna la distribución inicial de tipologías regionales"""
        return {
            TipoRegionEconomica.ATRAPADA: 0.75,  # 75% del total (regiones atrapadas)
            TipoRegionEconomica.NO_ATRAPADA: 0.25  # 25% del total (regiones no atrapadas)
        }

    @staticmethod
    def crear_tipologia_regional(n_region: int, n_pasos: int, distribucion_inicial: Dict[TipoRegionEconomica, float] = None) -> pd.DataFrame:
        """
        Crea tipología de regiones basada en evaluación DINÁMICA de características:
        Las proporciones 75-25 solo son distribución de partida que se actualiza

        Args:
            n_region: Número de regiones a crear
            n_pasos: Número de pasos de tiempo
            distribucion_inicial: Distribución inicial (si None, usa 75-25 empírico)
        """
        regiones = []

        # Obtener parámetros tipológicos
        parametros_tipologicos = ConfiguracionTipologias.obtener_parametros_tipologicos()

        # CORRECCIÓN: Usar distribución proporcionada o empírica por defecto
        if distribucion_inicial is None:
            distribucion_inicial = {
                TipoRegionEconomica.ATRAPADA: 0.75,  # 75% del total (regiones atrapadas)
                TipoRegionEconomica.NO_ATRAPADA: 0.25  # 25% del total (regiones no atrapadas)
            }

        # Aplicar distribución inicial como punto de partida
        regiones_atrapadas_inicial = int(n_region * distribucion_inicial[TipoRegionEconomica.ATRAPADA])
        regiones_no_atrapadas_inicial = n_region - regiones_atrapadas_inicial

        # Crear lista de regiones clasificadas inicialmente
        tipos_iniciales = ([TipoRegionEconomica.ATRAPADA] * regiones_atrapadas_inicial +
                          [TipoRegionEconomica.NO_ATRAPADA] * regiones_no_atrapadas_inicial)

        # Mezclar aleatoriamente para evitar patrones determinísticos
        np.random.shuffle(tipos_iniciales)

        for region_id in range(n_region):
            # Usar clasificación inicial, pero será evaluada dinámicamente
            tipo_region_inicial = tipos_iniciales[region_id]
            parametros = parametros_tipologicos[tipo_region_inicial]

            # Generar datos para todos los pasos de tiempo
            for paso in range(n_pasos):
                region = {
                    'id_region': region_id,
                    'tipo_region_economica_inicial': tipo_region_inicial.value,
                    'paso_tiempo': paso,

                    # Parámetros principales basados en evidencia empírica
                    'capacidad_tecnologica': max(0, parametros.capacidad_tecnologica_base + np.random.normal(0, 0.05)),
                    'innovaciones_realizadas': max(0, parametros.innovaciones_base + np.random.normal(0, 0.01)),
                    'diversidad_sectorial': max(0, parametros.diversidad_base + np.random.normal(0, 0.05)),
                    'especializacion': max(0, parametros.especializacion_base + np.random.normal(0, 0.03)),
                    'brecha_calificacion': max(0, parametros.brecha_calificacion_base + np.random.normal(0, 0.05)),

                    # Parámetros adicionales
                    'empleo_total': max(0, parametros.empleo_total_base + np.random.normal(0, 0.02)),
                    'empleo_especializado': max(0, parametros.empleo_especializado_base + np.random.normal(0, 0.03)),
                    'eficiencia_regional': max(0, parametros.eficiencia_regional_base + np.random.normal(0, 0.1)),

                    # Variables derivadas basadas en tipología
                    'tasa_innovacion': max(0, parametros.tasa_innovacion_base + np.random.normal(0, 0.01)),
                    'indice_diversificacion': max(0, parametros.diversidad_base + np.random.normal(0, 0.05)),
                    'indice_especializacion': max(0, parametros.especializacion_base + np.random.normal(0, 0.03)),
                    'nivel_tecnologico': max(0, parametros.capacidad_tecnologica_base + np.random.normal(0, 0.05))
                }

                regiones.append(region)

        return pd.DataFrame(regiones)

"""# =============================================
# PARÁMETROS DE AGLOMERACIÓN Y TRANSICIONES
# =============================================
"""

class ConfiguracionAglomeraciones:
    """Configuración de parámetros para diferentes tipos de aglomeraciones regionales"""

    @staticmethod
    def obtener_parametros_aglomeracion() -> Dict[str, Dict]:
        """Retorna parámetros para las aglomeraciones regionales"""
        return {
            'C1': {
                'descripcion': 'Baja diversidad-especialización',
                'especializacion_inicial': (0.80, 1),
                'intensidad_laboral_final': 4,
                'capacidad_tech_inicial': 0.1,
                'tasa_decaimiento_tech': 0.01,
                'nivel_diversidad': 'bajo',
                'inercia_tech': 0.95
            },
            'C2': {
                'descripcion': 'Media diversidad-especialización',
                'especializacion_inicial': 1.09,
                'nivel_diversidad': 'medio',
                'capacidad_tech_inicial': 0.1,
                'tasa_decaimiento_tech': 0.015,
                'factor_intensidad_laboral': 4.5,
                'inercia_tech': 0.85
            },
            'C3': {
                'descripcion': 'Alta diversidad-especialización',
                'especializacion_inicial': 1.3,
                'nivel_diversidad': 'medio-alto',
                'capacidad_tech_inicial': 0.15,
                'tasa_decaimiento_tech': 0.01,
                'factor_intensidad_laboral': 3.5,
                'inercia_tech': 0.75
            },
            'C4': {
                'descripcion': 'Sobre especialización',
                'especializacion_inicial': 1.5,
                'nivel_diversidad': 'medio-alto',
                'capacidad_tech_inicial': 0.15,
                'tasa_decaimiento_tech': 0.02,
                'factor_intensidad_laboral': 3,
                'nivel_especializacion': 'alto',
                'inercia_tech': 0.7
            }
        }

    @staticmethod
    def obtener_matrices_transicion() -> Dict[str, List[List[float]]]:
        """Retorna las matrices de transición de Markov para cada tipo de conglomerado"""
        return {
            'C1': [
                [0.97, 0.03, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.05, 0.95, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.70, 0.30, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.85, 0.15, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.97, 0.03, 0.00, 0.00, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.85, 0.10, 0.00, 0.00],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.15, 0.75, 0.10, 0.00],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.97, 0.03],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.95]   # Turismo_Especializado
            ],
            'C2': [
                [0.85, 0.10, 0.05, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.10, 0.80, 0.10, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.15, 0.75, 0.10, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.25, 0.65, 0.10, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.85, 0.10, 0.05, 0.00, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.20, 0.00, 0.00],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.15, 0.65, 0.20, 0.00],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.85, 0.15],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.95]   # Turismo_Especializado
            ],
            'C3': [
                [0.40, 0.15, 0.20, 0.10, 0.15, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.05, 0.35, 0.25, 0.15, 0.20, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.05, 0.35, 0.30, 0.25, 0.05, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.10, 0.40, 0.25, 0.10, 0.15, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.45, 0.30, 0.20, 0.05, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.45, 0.30, 0.15, 0.05],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.55, 0.25, 0.15],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.15, 0.00, 0.55, 0.25],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.10, 0.15, 0.70]   # Turismo_Especializado
            ],
            'C4': [
                [0.85, 0.05, 0.05, 0.00, 0.05, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
                [0.05, 0.80, 0.10, 0.00, 0.05, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
                [0.00, 0.03, 0.85, 0.10, 0.02, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
                [0.00, 0.00, 0.05, 0.75, 0.10, 0.05, 0.05, 0.00, 0.00],  # Manufactura_Alta
                [0.00, 0.00, 0.00, 0.00, 0.85, 0.10, 0.05, 0.00, 0.00],  # Servicios_Bajos
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.15, 0.05, 0.00],  # Servicios_Intermedios
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.15, 0.05],  # Servicios_Avanzados
                [0.00, 0.00, 0.00, 0.00, 0.05, 0.05, 0.00, 0.75, 0.15],  # Turismo_Masivo
                [0.00, 0.00, 0.00, 0.00, 0.00, 0.03, 0.05, 0.05, 0.87]   # Turismo_Especializado
            ]
        }

"""# =============================================
# CONFIGURACIÓN DE SECTORES ECONÓMICOS
# =============================================
"""

class ConfiguracionSectores:
    """Configuración detallada de los sectores económicos"""

    @staticmethod
    def obtener_sectores_economicos() -> Dict[str, str]:
        """Retorna la definición de sectores económicos"""
        return {
            1: "Agricultura Tradicional",
            2: "Agricultura Tecnificada",
            3: "Minería Básica",
            4: "Minería Tecnológica",
            5: "Manufactura Básica",
            6: "Manufactura Avanzada",
            7: "Servicios Básicos",
            8: "Servicios Financieros",
            9: "Servicios Tecnológicos",
            10: "Turismo Masivo",
            11: "Turismo Especializado"
        }

    @staticmethod
    def obtener_distribucion_sectores() -> Dict[str, float]:
        """Retorna la distribución inicial de sectores"""
        return {
            'Agricultura Tradicional': 0.103,
            'Agricultura Tecnificada': 0.025,
            'Minería Básica': 0.005,
            'Minería Tecnológica': 0.002,
            'Manufactura Básica': 0.15,
            'Manufactura Avanzada': 0.097,
            'Servicios Básicos': 0.402,
            'Servicios Financieros': 0.031,
            'Servicios Tecnológicos': 0.048,
            'Turismo Masivo': 0.068,
            'Turismo Especializado': 0.030
        }

    @staticmethod
    def obtener_tipos_sectores() -> Dict[str, List[int]]:
        """Mapea tipos de sector a IDs de sectores específicos"""
        return {
            'Primario_Bajo': [1, 3],
            'Primario_Alto': [2, 4],
            'Manufactura_Baja': [5],
            'Manufactura_Alta': [6],
            'Servicios_Bajos': [7],
            'Servicios_Intermedios': [8],
            'Servicios_Avanzados': [9],
            'Turismo_Masivo': [10],
            'Turismo_Especializado': [11]
        }

    @staticmethod
    def obtener_sectores_disponibles() -> List[str]:
        """Retorna lista de todos los sectores disponibles"""
        return [
            'Primario_Bajo', 'Primario_Alto', 'Manufactura_Baja', 'Manufactura_Alta',
            'Servicios_Bajos', 'Servicios_Intermedios', 'Servicios_Avanzados',
            'Turismo_Masivo', 'Turismo_Especializado'
        ]

    @staticmethod
    def obtener_parametros_sector(tipo_sector: str) -> Dict:
        """Retorna parámetros específicos para un tipo de sector"""
        parametros = {
            'Primario_Bajo': {
                'margen_rango': (0.25, 0.45),
                'inversion_tec': 0.05,
                'volatilidad': 0.35,
                'requisitos_habilidades': (0.3, 0.5),
                'tasa_empleo': (0.7, 0.8),
                'inversion_capacitacion': 0.05,
                'capacidad_innovacion': 0.1,
                'intensidad_conocimiento': 0.2,
                'enlaces_sectoriales': 0.3,
                'coeficiente_especializacion': 0.75,
                'productividad': 3.8,  # USD/hora
                'rango_productos': (3, 7),
                'empleo_maximo': 1
            },
            'Primario_Alto': {
                'margen_rango': (0.35, 0.55),
                'inversion_tec': 0.25,
                'volatilidad': 0.25,
                'requisitos_habilidades': (0.5, 0.7),
                'tasa_empleo': (0.75, 0.85),
                'inversion_capacitacion': 0.15,
                'capacidad_innovacion': 0.3,
                'intensidad_conocimiento': 0.4,
                'enlaces_sectoriales': 0.5,
                'coeficiente_especializacion': 0.66,
                'productividad': 9.2,
                'rango_productos': (5, 9),
                'empleo_maximo': 1
            },
            'Manufactura_Baja': {
                'margen_rango': (0.15, 0.3),
                'inversion_tec': 0.2,
                'volatilidad': 0.2,
                'requisitos_habilidades': (0.4, 0.6),
                'tasa_empleo': (0.7, 0.85),
                'inversion_capacitacion': 0.1,
                'capacidad_innovacion': 0.25,
                'intensidad_conocimiento': 0.35,
                'enlaces_sectoriales': 0.6,
                'coeficiente_especializacion': 0.58,
                'productividad': 8.7,
                'rango_productos': (6, 10),
                'empleo_maximo': 1
            },
            'Manufactura_Alta': {
                'margen_rango': (0.25, 0.4),
                'inversion_tec': 0.4,
                'volatilidad': 0.15,
                'requisitos_habilidades': (0.6, 0.8),
                'tasa_empleo': (0.8, 0.9),
                'inversion_capacitacion': 0.2,
                'capacidad_innovacion': 0.5,
                'intensidad_conocimiento': 0.7,
                'enlaces_sectoriales': 0.8,
                'coeficiente_especializacion': 0.45,
                'productividad': 32.5,
                'rango_productos': (8, 18),
                'empleo_maximo': 1
            },
            'Servicios_Bajos': {
                'margen_rango': (0.2, 0.4),
                'inversion_tec': 0.1,
                'volatilidad': 0.15,
                'requisitos_habilidades': (0.3, 0.5),
                'tasa_empleo': (0.75, 0.9),
                'inversion_capacitacion': 0.08,
                'capacidad_innovacion': 0.15,
                'intensidad_conocimiento': 0.3,
                'enlaces_sectoriales': 0.4,
                'coeficiente_especializacion': 0.35,
                'productividad': 5.2,
                'rango_productos': (4, 8),
                'empleo_maximo': 1
            },
            'Servicios_Intermedios': {
                'margen_rango': (0.3, 0.5),
                'inversion_tec': 0.25,
                'volatilidad': 0.1,
                'requisitos_habilidades': (0.5, 0.7),
                'tasa_empleo': (0.8, 0.95),
                'inversion_capacitacion': 0.15,
                'capacidad_innovacion': 0.35,
                'intensidad_conocimiento': 0.5,
                'enlaces_sectoriales': 0.7,
                'coeficiente_especializacion': 0.25,
                'productividad': 38.7,
                'rango_productos': (7, 11),
                'empleo_maximo': 1
            },
            'Servicios_Avanzados': {
                'margen_rango': (0.4, 0.65),
                'inversion_tec': 0.45,
                'volatilidad': 0.1,
                'requisitos_habilidades': (0.7, 0.9),
                'tasa_empleo': (0.85, 0.8),
                'inversion_capacitacion': 0.25,
                'capacidad_innovacion': 0.7,
                'intensidad_conocimiento': 0.9,
                'enlaces_sectoriales': 0.9,
                'coeficiente_especializacion': 0.18,
                'productividad': 48.9,
                'rango_productos': (10, 21),
                'empleo_maximo': 1
            },
            'Turismo_Masivo': {
                'margen_rango': (0.2, 0.5),
                'inversion_tec': 0.05,
                'volatilidad': 0.4,
                'requisitos_habilidades': (0.2, 0.4),
                'tasa_empleo': (0.6, 0.9),
                'inversion_capacitacion': 0.03,
                'capacidad_innovacion': 0.15,
                'intensidad_conocimiento': 0.2,
                'enlaces_sectoriales': 0.3,
                'coeficiente_especializacion': 0.85,
                'productividad': 6.5,
                'rango_productos': (3, 7),
                'empleo_maximo': 1
            },
            'Turismo_Especializado': {
                'margen_rango': (0.3, 0.6),
                'inversion_tec': 0.15,
                'volatilidad': 0.3,
                'requisitos_habilidades': (0.4, 0.6),
                'tasa_empleo': (0.7, 0.9),
                'inversion_capacitacion': 0.1,
                'capacidad_innovacion': 0.3,
                'intensidad_conocimiento': 0.4,
                'enlaces_sectoriales': 0.5,
                'coeficiente_especializacion': 0.65,
                'productividad': 12.8,
                'rango_productos': (5, 9),
                'empleo_maximo': 1
            }
        }
        return parametros.get(tipo_sector, {})

    @staticmethod
    def obtener_factores_sectoriales() -> Tuple[Dict[str, float], Dict[str, float]]:
        """Retorna factores de innovación y productividad por sector (simulados)"""

        factores_innovacion = {
            'Agricultura Tradicional': 0.4,
            'Agricultura Tecnificada': 0.7,
            'Minería Básica': 0.3,
            'Minería Tecnológica': 0.8,
            'Manufactura Básica': 0.6,
            'Manufactura Avanzada': 0.9,
            'Servicios Básicos': 0.5,
            'Servicios Financieros': 0.8,
            'Servicios Tecnológicos': 1.0,
            'Turismo Masivo': 0.4,
            'Turismo Especializado': 0.6
        }

        factores_productividad = {
            'Agricultura Tradicional': 0.5,
            'Agricultura Tecnificada': 0.8,
            'Minería Básica': 0.4,
            'Minería Tecnológica': 0.9,
            'Manufactura Básica': 0.7,
            'Manufactura Avanzada': 1.0,
            'Servicios Básicos': 0.6,
            'Servicios Financieros': 0.9,
            'Servicios Tecnológicos': 1.1,
            'Turismo Masivo': 0.5,
            'Turismo Especializado': 0.7
        }

        return factores_innovacion, factores_productividad

"""# =============================================
# CLASES DE AGENTES DEL MODELO
# =============================================
"""

class Producto:
    """Representa un producto o servicio generado en una corporación"""

    def __init__(self, tipo_sector: str, id_producto: int):
        self.id = id_producto
        self.tipo_sector = tipo_sector
        parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)

        self.ingresos = np.random.uniform(*parametros['rango_productos'])
        self.costos = np.random.uniform(0.4, 0.8) * self.ingresos
        self.produccion = np.random.uniform(3, 16)
        self.intensidad_tecnologica = np.random.uniform(0.1, parametros['intensidad_conocimiento'])
        self.habilidad_requerida = np.random.uniform(*parametros['requisitos_habilidades'])
        self.id_sector = np.random.choice(ConfiguracionSectores.obtener_tipos_sectores()[tipo_sector])

    def calcular_margen(self) -> float:
        """Calcula el margen de ganancia del producto"""
        return (self.ingresos - self.costos) / self.ingresos

class Trabajador:
    """Representa un trabajador con habilidades específicas"""

    def __init__(self, tipo_sector: Optional[str] = None):
        if tipo_sector:
            parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
            rango_requisitos = parametros['requisitos_habilidades']
            self.habilidad = np.random.uniform(
                max(0.1, rango_requisitos[0] - 0.2),
                min(1.0, rango_requisitos[1] + 0.1)
            )
            self.habilidad_especializada = random.uniform(0.5, 1.1)
        else:
            self.habilidad = np.random.uniform(0.1, 0.6)
            self.habilidad_especializada = 0.0

        self.empleado = False
        self.id_region = None
        self.region = None
        self.tipo_sector = tipo_sector
        self.experiencia = 0
        self.salario = 0.0
        self.productividad = 0.0

    def mejorar_habilidades(self, inversion_capacitacion: float, exposicion_tecnologica: float):
        """Mejora las habilidades del trabajador a través de capacitación y exposición tecnológica"""
        efecto_capacitacion = 0.4 * (1 - np.exp(-1.5 * inversion_capacitacion))
        efecto_tecnologia = 0.5 * (1 - np.exp(-1.0 * exposicion_tecnologica))
        factor_individual = np.random.uniform(0.7, 1.0)
        factor_experiencia = 1 + np.log1p(self.experiencia) * 0.05

        ganancia_habilidad = (efecto_capacitacion + efecto_tecnologia) * factor_individual * factor_experiencia * ParametrosGlobales.TASA_APRENDIZAJE * 0.66
        self.habilidad = np.clip(self.habilidad + ganancia_habilidad, 0.1, 1.0)

        # Penalización por cambios tecnológicos rápidos
        if hasattr(self, 'region') and self.region is not None:
            if hasattr(self.region, 'capacidad_tecnologica') and hasattr(self.region, 'historial_capacidad_tecnologica'):
                if len(self.region.historial_capacidad_tecnologica) > 1:
                    tasa_cambio_tec = abs(self.region.capacidad_tecnologica - self.region.historial_capacidad_tecnologica[-2])
                    if tasa_cambio_tec > 0.02:
                        self.habilidad = max(0.1, self.habilidad * 0.98)

class FuerzaLaboral:
    """Representa la fuerza laboral de una región en un sector específico"""

    def __init__(self, tipo_sector: str, id_region: int):
        self.parametros = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
        self.trabajadores = []
        self.tipo_sector = tipo_sector
        self.id_region = id_region
        self.region = None
        self.inversion_capacitacion = self.parametros['inversion_capacitacion'] * 0.7
        self.requisitos_habilidades = np.random.uniform(*self.parametros['requisitos_habilidades'])
        self.habilidad_especializada_minima = 0.6
        self.habilidad_promedio = 0.0
        self.habilidad_especializada_promedio = 0.0
        self.brecha_calificacion = self.requisitos_habilidades
        self.decadencia_experiencia = 0.01

    def actualizar_metricas(self):
        """Actualiza las métricas de la fuerza laboral"""
        capacidad_tecnologica = 0.12
        if hasattr(self, 'region') and self.region is not None:
            capacidad_tecnologica = getattr(self.region, 'capacidad_tecnologica', capacidad_tecnologica)
        factor_tec = 1 + capacidad_tecnologica

        # Los requisitos crecen con la capacidad tecnológica, pero con saturación
        requisito_base = np.random.uniform(*self.parametros['requisitos_habilidades'])
        self.requisitos_habilidades = np.clip(
            requisito_base * (1 + 0.75 * capacidad_tecnologica),
            self.parametros['requisitos_habilidades'][0],
            self.parametros['requisitos_habilidades'][1] * 1.5
        )

        if self.trabajadores:
            self.habilidad_promedio = np.mean([t.habilidad for t in self.trabajadores])
            self.habilidad_especializada_promedio = np.mean([t.habilidad_especializada for t in self.trabajadores])
            brecha = max(0, self.requisitos_habilidades - self.habilidad_promedio)
            # Brecha amplificada por baja absorción
            self.brecha_calificacion = brecha * (1 + 0.4 * np.random.uniform(-0.5, 0.5) * self.parametros['volatilidad'])
        else:
            self.habilidad_promedio = 0.0
            self.habilidad_especializada_promedio = 0.0
            self.brecha_calificacion = self.requisitos_habilidades

    def contratar_trabajadores(self, numero_trabajadores: int, pool_trabajadores: List[Trabajador]) -> int:
        """Contrata trabajadores del pool disponible"""
        if numero_trabajadores <= 0:
            return 0

        contratados = 0
        trabajadores_disponibles = [t for t in pool_trabajadores if not t.empleado]

        # Priorizar especializados, pero con costo de adaptación
        trabajadores_especializados = [t for t in trabajadores_disponibles if t.tipo_sector == self.tipo_sector]
        for trabajador in trabajadores_especializados[:min(numero_trabajadores - contratados, len(trabajadores_especializados))]:
            trabajador.empleado = True
            trabajador.id_region = self.id_region
            trabajador.region = self.region
            trabajador.habilidad = max(trabajador.habilidad * 0.9, trabajador.habilidad - 0.05)  # Pérdida en transición
            self.trabajadores.append(trabajador)
            contratados += 1

        # Contratar trabajadores generales si es necesario
        restantes = numero_trabajadores - contratados
        if restantes > 0:
            trabajadores_generales = [t for t in trabajadores_disponibles if t not in trabajadores_especializados]
            for trabajador in trabajadores_generales[:min(restantes, len(trabajadores_generales))]:
                trabajador.empleado = True
                trabajador.id_region = self.id_region
                trabajador.region = self.region
                trabajador.tipo_sector = self.tipo_sector
                trabajador.habilidad = max(0.1, trabajador.habilidad * 0.7)  # Reset parcial de habilidad
                self.trabajadores.append(trabajador)
                contratados += 1

        self.actualizar_metricas()
        return contratados

    def despedir_trabajadores(self, numero_trabajadores: int) -> int:
        """Despide trabajadores (los de menor habilidad primero)"""
        if not self.trabajadores or numero_trabajadores <= 0:
            return 0

        self.trabajadores.sort(key=lambda t: t.habilidad + t.habilidad_especializada)
        despedidos = 0
        for _ in range(min(numero_trabajadores, len(self.trabajadores))):
            trabajador = self.trabajadores.pop(0)
            trabajador.empleado = False
            trabajador.id_region = None
            trabajador.region = None
            despedidos += 1

        self.actualizar_metricas()
        return despedidos

    def ajustar_fuerza_laboral(self, trabajadores_requeridos: int, pool_trabajadores: List[Trabajador]):
        """Ajusta el tamaño de la fuerza laboral"""
        actual = len(self.trabajadores)
        if actual < trabajadores_requeridos:
            self.contratar_trabajadores(trabajadores_requeridos - actual, pool_trabajadores)
        elif actual > trabajadores_requeridos:
            self.despedir_trabajadores(actual - trabajadores_requeridos)

    def evaluar_trabajadores(self) -> int:
        """Evalúar y despedir trabajadores con habilidades muy por debajo del promedio"""
        umbral = self.requisitos_habilidades * 0.65
        a_despedir = [t for t in self.trabajadores if t.habilidad < umbral]
        for trabajador in a_despedir:
            self.trabajadores.remove(trabajador)
            trabajador.empleado = False
            trabajador.id_region = None
            trabajador.region = None
        self.actualizar_metricas()
        return len(a_despedir)

    def obtener_empleo_especializado(self) -> int:
        """Obtiene el número de empleos especializados (trabajadores con habilidad > umbral)"""
        UMBRAL_ESPECIALIZACION = 0.6  # Umbral para considerar empleado especializado
        return sum(1 for trabajador in self.trabajadores if trabajador.habilidad > UMBRAL_ESPECIALIZACION)

    def calcular_brecha_calificacion(self):
        """Calcula la brecha de calificación actualizada"""
        if self.trabajadores:
            # Usar habilidades promedio actualizadas
            self.actualizar_metricas()
            brecha = max(0, self.requisitos_habilidades - self.habilidad_promedio)
            # Aplicar factor de amplificación basado en volatilidad sectorial
            self.brecha_calificacion = brecha * (1 + 0.3 * self.parametros['volatilidad'])
        else:
            self.brecha_calificacion = self.requisitos_habilidades

class DistribucionTrabajadores:
    """Gestiona la distribución del pool de trabajadores por sectores económicos"""

    # Porcentajes de distribución especificados
    SECTOR_TERCIARIO_SERVICIOS = 0.6  # 60%
    SECTOR_SECUNDARIO_INDUSTRIAL = 0.3  # 30%
    SECTOR_PRIMARIO_AGROPECUARIO = 0.1  # 10%

    @staticmethod
    def crear_pool_trabajadores(tamaño_pool: int = None) -> List[Trabajador]:
        """
        Crea un pool de trabajadores distribuido según los porcentajes especificados

        Args:
            tamaño_pool: Tamaño total del pool de trabajadores

        Returns:
            Lista de trabajadores distribuidos según la proporción sectorial
        """
        if tamaño_pool is None:
            tamaño_pool = ParametrosGlobales.TAMAÑO_POOL_TRABAJADORES

        # Calcular distribución por sectores principales
        num_primarios = int(tamaño_pool * DistribucionTrabajadores.SECTOR_PRIMARIO_AGROPECUARIO)
        num_secundarios = int(tamaño_pool * DistribucionTrabajadores.SECTOR_SECUNDARIO_INDUSTRIAL)
        num_terciarios = tamaño_pool - num_primarios - num_secundarios

        pool_trabajadores = []

        # Sector Primario (10%) - Mayor participación de Primario_Bajo
        # 80% Primario_Bajo, 20% Primario_Alto
        num_primario_bajo = int(num_primarios * 0.8)
        num_primario_alto = num_primarios - num_primario_bajo

        for _ in range(num_primario_bajo):
            pool_trabajadores.append(Trabajador(tipo_sector='Primario_Bajo'))
        for _ in range(num_primario_alto):
            pool_trabajadores.append(Trabajador(tipo_sector='Primario_Alto'))

        # Sector Secundario (30%) - Mayor participación de Manufactura_Baja
        # 70% Manufactura_Baja, 30% Manufactura_Alta
        num_manufactura_baja = int(num_secundarios * 0.7)
        num_manufactura_alta = num_secundarios - num_manufactura_baja

        for _ in range(num_manufactura_baja):
            pool_trabajadores.append(Trabajador(tipo_sector='Manufactura_Baja'))
        for _ in range(num_manufactura_alta):
            pool_trabajadores.append(Trabajador(tipo_sector='Manufactura_Alta'))

        # Sector Terciario (60%) - Mayor participación de Servicios_Bajos e Intermedios
        # 45% Servicios_Bajos, 35% Servicios_Intermedios, 10% Servicios_Avanzados, 7% Turismo_Masivo, 3% Turismo_Especializado
        num_servicios_bajos = int(num_terciarios * 0.45)
        num_servicios_intermedios = int(num_terciarios * 0.35)
        num_servicios_avanzados = int(num_terciarios * 0.10)
        num_turismo_masivo = int(num_terciarios * 0.07)
        num_turismo_especializado = num_terciarios - num_servicios_bajos - num_servicios_intermedios - num_servicios_avanzados - num_turismo_masivo

        for _ in range(num_servicios_bajos):
            pool_trabajadores.append(Trabajador(tipo_sector='Servicios_Bajos'))
        for _ in range(num_servicios_intermedios):
            pool_trabajadores.append(Trabajador(tipo_sector='Servicios_Intermedios'))
        for _ in range(num_servicios_avanzados):
            pool_trabajadores.append(Trabajador(tipo_sector='Servicios_Avanzados'))
        for _ in range(num_turismo_masivo):
            pool_trabajadores.append(Trabajador(tipo_sector='Turismo_Masivo'))
        for _ in range(num_turismo_especializado):
            pool_trabajadores.append(Trabajador(tipo_sector='Turismo_Especializado'))

        # Mezclar aleatoriamente para evitar patrones determinísticos
        random.shuffle(pool_trabajadores)

        return pool_trabajadores

class Corporacion:
    """Representa una corporación con capacidad productiva y tecnológica"""

    def __init__(self, id_corporacion: int, tipo_sector: str, id_region: int):
        self.id = id_corporacion
        self.tipo_sector = tipo_sector
        self.id_region = id_region
        self.region = None

        # Parámetros específicos del sector (primero)
        self.parametros_sector = ConfiguracionSectores.obtener_parametros_sector(tipo_sector)
        self.inversion_tecnologia_objetivo = self.parametros_sector['inversion_tec']

        # Capacidades tecnológicas
        self.capacidad_tecnologica = ParametrosGlobales.NIVEL_TECNOLOGICO_INICIAL
        self.inversion_id = 0.0
        self.productos = []
        self.capacidad_produccion = np.random.uniform(50, 200)
        self.utilidades = 0.0
        self.margen_beneficio = 0.0
        self.volatilidad_mercado = self._obtener_volatilidad_sector()

    def _obtener_volatilidad_sector(self) -> float:
        """Obtiene la volatilidad específica del sector"""
        return self.parametros_sector['volatilidad']

    def producir(self, demanda_mercado: float = 1.0) -> Dict[str, float]:
        """Ejecuta el proceso de producción"""
        # Calcular nivel de producción basado en capacidad y demanda
        factor_demanda = min(1.0, demanda_mercado / self.capacidad_produccion)
        produccion_real = self.capacidad_produccion * factor_demanda

        # Calcular productividad basada en tecnología y trabajadores
        if self.region and hasattr(self.region, 'fuerzas_laborales'):
            fuerza_laboral = self.region.fuerzas_laborales.get(self.tipo_sector)
            if fuerza_laboral:
                productividad_trabajadores = fuerza_laboral.habilidad_promedio
            else:
                productividad_trabajadores = 0.5
        else:
            productividad_trabajadores = 0.5

        factor_tecnologico = 1 + self.capacidad_tecnologica * 0.3
        factor_productividad = productividad_trabajadores * 0.6 + factor_tecnologico * 0.4

        produccion_ajustada = produccion_real * factor_productividad

        # Calcular ingresos y costos
        precio_unitario = self.parametros_sector['productividad'] / 10  # Simplificación
        ingresos_totales = produccion_ajustada * precio_unitario
        costos_operativos = produccion_ajustada * precio_unitario * 0.6  # 40% margen

        self.utilidades = ingresos_totales - costos_operativos
        self.margen_beneficio = (ingresos_totales - costos_operativos) / ingresos_totales if ingresos_totales > 0 else 0

        return {
            'produccion': produccion_ajustada,
            'ingresos': ingresos_totales,
            'costos': costos_operativos,
            'utilidades': self.utilidades,
            'margen': self.margen_beneficio
        }

    def innovar(self, conocimiento_externo: float = 0.0) -> bool:
        """Ejecuta proceso de innovación"""
        # Capacidad de innovación base del sector
        capacidad_base = self.parametros_sector['capacidad_innovacion']

        # Aplicar factores tipológicos si están disponibles
        factor_tipologico = 1.0
        if hasattr(self, 'region') and self.region and hasattr(self.region, 'parametros_tipologicos'):
            if self.region.parametros_tipologicos.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
                factor_tipologico = 0.6  # Regiones atrapadas tienen menor capacidad de innovación
            elif self.region.parametros_tipologicos.tipo_region_economica == TipoRegionEconomica.NO_ATRAPADA:
                factor_tipologico = 1.4  # Regiones no atrapadas tienen mayor capacidad de innovación

        # Factores que afectan la innovación
        factor_utilidades = max(0, self.utilidades / 1000)  # Normalizar
        factor_conocimiento = conocimiento_externo * ParametrosGlobales.FACTOR_CAPACIDAD_ABSORCION
        factor_educacion = getattr(self.region, 'inversion_educacion', 0.1) if self.region else 0.1

        # Probabilidad de innovación
        probabilidad_innovacion = (
            ParametrosGlobales.TASA_INNOVACION_BASE *
            capacidad_base *
            factor_tipologico *  # Aplicar factor tipológico
            (1 + factor_utilidades) *
            (1 + factor_conocimiento) *
            (1 + factor_educacion)
        )

        # Ejecutar innovación
        if random.random() < probabilidad_innovacion:
            # Mejora tecnológica
            mejora_tecnologica = np.random.uniform(0.01, 0.05) * capacidad_base * factor_tipologico
            self.capacidad_tecnologica = min(1.0, self.capacidad_tecnologica + mejora_tecnologica)

            # Crear nuevo producto
            nuevo_producto = Producto(self.tipo_sector, len(self.productos))
            self.productos.append(nuevo_producto)

            return True
        return False

    def calcular_productividad(self) -> float:
        """Calcula la productividad de la corporación"""
        # Productividad base del sector
        productividad_base = self.parametros_sector['productividad']

        # Factor tecnológico (capacidad tecnológica de la corporación)
        factor_tecnologico = 1 + self.capacidad_tecnologica * 0.3

        # Factor de trabajadores (si está disponible)
        factor_trabajadores = 1.0
        if self.region and hasattr(self.region, 'fuerzas_laborales'):
            fuerza_laboral = self.region.fuerzas_laborales.get(self.tipo_sector)
            if fuerza_laboral:
                factor_trabajadores = fuerza_laboral.habilidad_promedio + 0.5

        # Productividad total
        productividad_total = productividad_base * factor_tecnologico * factor_trabajadores
        return min(100.0, productividad_total)  # Limitar a valor razonable

    def actualizar_productividad(self):
        """Actualiza la productividad basándose en factores actuales"""
        # Calcular nueva productividad usando función de producción regional
        if self.region:
            capacidad_tec_region = self.region.capacidad_tecnologica
            innovacion_region = getattr(self.region, 'tasa_innovacion', 0.05)

            # Aplicar ecuaciones calibradas si están disponibles
            try:
                productividad_calculada = EcuacionesCalibradas.funcion_produccion_regional(
                    capital=self.capacidad_produccion / 10,
                    labor=len(self.productos) + 1,
                    capital_humano=capacidad_tec_region,
                    innovacion=innovacion_region,
                    id_inversion=self.inversion_id,
                    infraestructura=0.7,
                    tipo_region_economica=self.region.tipo_region_economica
                )

                # Ajustar capacidad tecnológica de la corporación
                self.capacidad_tecnologica = min(1.0, capacidad_tec_region * 0.8 + self.capacidad_tecnologica * 0.2)

            except Exception as e:
                # Fallback a método simple si hay error
                self.capacidad_tecnologica = min(1.0, self.capacidad_tecnologica * 1.02)
        else:
            # Sin región, actualización mínima
            self.capacidad_tecnologica = min(1.0, self.capacidad_tecnologica * 1.01)

class Region:
    """Representa una región económica con características geográficas específicas
    y tipología económica"""

    def __init__(self, id_region: int, tipo_region: TipoRegion, tipo_economico: TipoRegionEconomica = None):
        self.id = id_region
        self.tipo_region = tipo_region
        self.caracteristicas = self._configurar_caracteristicas_regionales()

        # Usar tipo_economico si se proporciona, sino asignar automáticamente
        if tipo_economico:
            self.tipo_region_economica = tipo_economico
        else:
            self.tipo_region_economica = self._asignar_tipologia_economica()

        self.parametros_tipologicos = ConfiguracionTipologias.obtener_parametros_tipologicos()[self.tipo_region_economica]

        # Estado económico
        self.capacidad_tecnologica = self.parametros_tipologicos.capacidad_tecnologica_base
        self.historial_capacidad_tecnologica = [self.capacidad_tecnologica]
        self.etapa_economica = EtapaEconomica.SUBSISTENCIA
        self.diversidad_sectorial = self.parametros_tipologicos.diversidad_base
        self.productividad_promedio = 0.0

        # Estructura económica
        self.fuerzas_laborales: Dict[str, FuerzaLaboral] = {}
        self.corporaciones: List[Corporacion] = []
        self.sectores_activos = []
        self.pool_trabajadores = []

        # Métricas de coordinación
        self.coordinacion_inter_sectorial = 0.5
        self.flujos_comerciales = 0.0
        self.inversion_extranjera_recibida = 0.0

        # Parámetros de aglomeración y transición
        self.tipo_aglomeracion = self._determinar_tipo_aglomeracion()
        self.parametros_aglomeracion = ConfiguracionAglomeraciones.obtener_parametros_aglomeracion()[self.tipo_aglomeracion]
        self.matriz_transicion = ConfiguracionAglomeraciones.obtener_matrices_transicion()[self.tipo_aglomeracion]
        self.factores_innovacion, self.factores_productividad = ConfiguracionSectores.obtener_factores_sectoriales()

        # Inicializar estructura económica
        self._inicializar_estructura_economica()

    def _asignar_tipologia_economica(self) -> TipoRegionEconomica:
        """
        Asigna tipología económica
        75% regiones atrapadas (alta especialización), 25% regiones no atrapadas (especialización moderada/intermedia)
        """
        # Distribución 75-25
        if self.id % 4 == 0 or self.id % 4 == 1 or self.id % 4 == 2:
            return TipoRegionEconomica.ATRAPADA
        else:
            return TipoRegionEconomica.NO_ATRAPADA

    def _configurar_caracteristicas_regionales(self) -> CaracteristicasRegionales:
        """Configura las características específicas según el tipo de región"""
        if self.tipo_region == TipoRegion.NORESTE:
            # Noreste: Mejor economía por Nuevo León, industrializado
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.85,  # Alto por Nuevo León
                cercania_eeuu=0.95,        # Muy alto (frontera)
                riqueza_natural=0.4,
                clima_aridez=0.6,
                rezago_social=0.15,        # Muy bajo
                conectividad_transport=0.85, # Alto
                inversion_extranjera=0.8   # Alto
            )
        elif self.tipo_region == TipoRegion.NOROESTE:
            # Noroeste: Fronterizo, clima árido, mejor economía regional
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.7,
                cercania_eeuu=0.9,
                riqueza_natural=0.3,
                clima_aridez=0.8,
                rezago_social=0.25,
                conectividad_transport=0.75,
                inversion_extranjera=0.75
            )
        elif self.tipo_region == TipoRegion.OCCIDENTE:
            # Occidente: Mejor por Jalisco, variada
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.7,   # Mejorado por Jalisco
                cercania_eeuu=0.6,
                riqueza_natural=0.7,       # Rica en recursos
                clima_aridez=0.4,
                rezago_social=0.4,         # Moderado
                conectividad_transport=0.75,
                inversion_extranjera=0.7
            )
        elif self.tipo_region == TipoRegion.CENTRONORTE:
            # Centronorte: Intermedio, agricola, manufactura básica
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.65,
                cercania_eeuu=0.7,
                riqueza_natural=0.5,
                clima_aridez=0.5,
                rezago_social=0.45,
                conectividad_transport=0.7,
                inversion_extranjera=0.65
            )
        elif self.tipo_region == TipoRegion.ORIENTE:
            # Oriente: CDMX incluida, mix urbano-rural
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.8,   # Alto por CDMX
                cercania_eeuu=0.65,
                riqueza_natural=0.4,
                clima_aridez=0.3,
                rezago_social=0.35,         # Menor por CDMX
                conectividad_transport=0.9, # Muy alto
                inversion_extranjera=0.75
            )
        elif self.tipo_region == TipoRegion.SURESTE:
            # Sureste: Rica en recursos pero bajo desarrollo
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.35,  # Bajo pero mejor que suroeste
                cercania_eeuu=0.4,
                riqueza_natural=0.85,      # Muy rica
                clima_aridez=0.2,
                rezago_social=0.75,        # Alto
                conectividad_transport=0.4, # Bajo
                inversion_extranjera=0.25  # Bajo
            )
        else:  # SUROESTE
            # Suroeste: Mayor rezago social
            return CaracteristicasRegionales(
                tipo=self.tipo_region,
                desarrollo_economico=0.2,   # Muy bajo
                cercania_eeuu=0.25,
                riqueza_natural=0.8,
                clima_aridez=0.1,
                rezago_social=0.9,         # Muy alto
                conectividad_transport=0.25, # Muy bajo
                inversion_extranjera=0.15  # Muy bajo
            )

    def _determinar_tipo_aglomeracion(self) -> str:
        """Determina el tipo de aglomeración regional basado en características"""
        # Clasificar por nivel de desarrollo y diversidad sectorial
        desarrollo = self.caracteristicas.desarrollo_economico
        diversidad_esperada = self.parametros_tipologicos.diversidad_base

        if desarrollo < 0.4:
            return 'C1'  # Baja diversidad-especialización
        elif desarrollo < 0.65:
            return 'C2'  # Media diversidad-especialización
        elif desarrollo < 0.8:
            return 'C3'  # Alta diversidad-especialización
        else:
            return 'C4'  # Sobre especialización

    def aplicar_transicion_sectorial(self, tipo_sector_actual: str, paso_tiempo: int):
        """Aplica la transición de Markov a los sectores según el tipo de aglomeración"""
        # Mapear tipo de sector a índice en la matriz
        sectores_orden = ['Primario_Bajo', 'Primario_Alto', 'Manufactura_Baja',
                         'Manufactura_Alta', 'Servicios_Bajos', 'Servicios_Intermedios',
                         'Servicios_Avanzados', 'Turismo_Masivo', 'Turismo_Especializado']

        if tipo_sector_actual not in sectores_orden:
            return tipo_sector_actual

        idx_actual = sectores_orden.index(tipo_sector_actual)
        probabilidades = self.matriz_transicion[idx_actual]

        # Seleccionar nuevo sector basado en probabilidades
        nuevo_idx = np.random.choice(len(probabilidades), p=probabilidades)
        nuevo_sector = sectores_orden[nuevo_idx]

        return nuevo_sector

    def aplicar_factores_sectoriales(self, tipo_sector: str, valor_base: float, tipo_factor: str = 'innovacion'):
        """Aplica factores de innovación o productividad específicos del sector"""
        factores = self.factores_innovacion if tipo_factor == 'innovacion' else self.factores_productividad

        # Mapear el tipo de sector al nombre completo en el diccionario
        sectores_mapping = {
            'Primario_Bajo': 'Agricultura Tradicional',
            'Primario_Alto': 'Agricultura Tecnificada',
            'Manufactura_Baja': 'Manufactura Básica',
            'Manufactura_Alta': 'Manufactura Avanzada',
            'Servicios_Bajos': 'Servicios Básicos',
            'Servicios_Intermedios': 'Servicios Financieros',
            'Servicios_Avanzados': 'Servicios Tecnológicos',
            'Turismo_Masivo': 'Turismo Masivo',
            'Turismo_Especializado': 'Turismo Especializado'
        }

        nombre_sector = sectores_mapping.get(tipo_sector, 'Servicios Básicos')
        factor = factores.get(nombre_sector, 0.5)

        return valor_base * factor

    def _inicializar_estructura_economica(self):
        """Inicializa la estructura económica de la región"""
        # Seleccionar sectores basados en características regionales
        sectores_recomendados = self._seleccionar_sectores_regionales()

        for tipo_sector in sectores_recomendados:
            # Crear fuerza laboral
            fuerza_laboral = FuerzaLaboral(tipo_sector, self.id)
            fuerza_laboral.region = self
            self.fuerzas_laborales[tipo_sector] = fuerza_laboral

            # Crear corporaciones
            num_corporaciones = np.random.randint(2, 6)
            for _ in range(num_corporaciones):
                corporacion = Corporacion(len(self.corporaciones), tipo_sector, self.id)
                corporacion.region = self
                self.corporaciones.append(corporacion)

            self.sectores_activos.append(tipo_sector)

        # Crear pool de trabajadores inicial
        self._crear_pool_trabajadores()

        # Asignar trabajadores a las fuerzas laborales
        if self.sectores_activos and self.pool_trabajadores:
            # Calcular distribución equilibrada de trabajadores por sector
            trabajadores_por_sector = max(15, len(self.pool_trabajadores) // len(self.sectores_activos))

            for tipo_sector in self.sectores_activos:
                if tipo_sector in self.fuerzas_laborales:
                    fuerza_laboral = self.fuerzas_laborales[tipo_sector]
                    # Asignar trabajadores balanceados
                    fuerza_laboral.ajustar_fuerza_laboral(trabajadores_por_sector, self.pool_trabajadores)

    def _seleccionar_sectores_regionales(self) -> List[str]:
        """Selecciona sectores apropiados según las características regionales"""
        sectores_disponibles = ConfiguracionSectores.obtener_sectores_disponibles()
        sectores_seleccionados = []

        # Lógica de selección basada en características regionales actualizadas
        if self.tipo_region == TipoRegion.NORESTE:
            # Noreste: Alta tecnología, manufactura avanzada (Nuevo León)
            sectores_preferidos = ['Manufactura_Alta', 'Servicios_Avanzados', 'Servicios_Intermedios']
        elif self.tipo_region == TipoRegion.NOROESTE:
            # Noroeste: Manufactura fronteriza, tecnología, servicios
            sectores_preferidos = ['Manufactura_Alta', 'Primario_Alto', 'Servicios_Intermedios']
        elif self.tipo_region == TipoRegion.OCCIDENTE:
            # Occidente: Manufactura, turismo, agroindustria (influencia de Jalisco)
            sectores_preferidos = ['Manufactura_Baja', 'Turismo_Especializado', 'Primario_Alto']
        elif self.tipo_region == TipoRegion.CENTRONORTE:
            # Centronorte: Manufactura, servicios, agroindustria
            sectores_preferidos = ['Manufactura_Baja', 'Primario_Alto', 'Servicios_Intermedios']
        elif self.tipo_region == TipoRegion.ORIENTE:
            # Oriente: Servicios, manufactura, turismo (CDMX)
            sectores_preferidos = ['Servicios_Avanzados', 'Servicios_Intermedios', 'Turismo_Especializado']
        elif self.tipo_region == TipoRegion.SURESTE:
            # Sureste: Primario, turismo masivo, algunos servicios
            sectores_preferidos = ['Primario_Alto', 'Turismo_Masivo', 'Servicios_Bajos']
        else:  # SUROESTE
            # Suroeste: Principalmente primario, poco diversificado
            sectores_preferidos = ['Primario_Bajo', 'Primario_Alto', 'Turismo_Masivo']

        # Ajustar selección según tipología económica
        if self.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
            # Regiones atrapadas: más especialización, menos diversificación
            sectores_preferidos = sectores_preferidos[:2] + [sectores_preferidos[0]]  # Duplicar el principal
        elif self.tipo_region_economica == TipoRegionEconomica.NO_ATRAPADA:
            # Regiones no atrapadas: más diversificación
            sectores_adicionales = ['Servicios_Avanzados', 'Manufactura_Alta'] if 'Servicios_Avanzados' not in sectores_preferidos else []
            sectores_preferidos.extend(sectores_adicionales)

        # Seleccionar sectores preferidos que existan
        for sector in sectores_preferidos:
            if sector in sectores_disponibles:
                sectores_seleccionados.append(sector)

        # Asegurar al menos 3 sectores
        while len(sectores_seleccionados) < 3 and sectores_disponibles:
            sector = random.choice(sectores_disponibles)
            if sector not in sectores_seleccionados:
                sectores_seleccionados.append(sector)

        return sectores_seleccionados[:5]  # Máximo 5 sectores por región

    def _crear_pool_trabajadores(self):
        """Crea el pool inicial de trabajadores para la región"""
        total_trabajadores = int(ParametrosGlobales.TAMAÑO_POOL_TRABAJADORES / 32)  # Distribución proporcional
        self.pool_trabajadores = []

        for _ in range(total_trabajadores):
            if self.sectores_activos:
                sector_aleatorio = random.choice(self.sectores_activos)
                trabajador = Trabajador(sector_aleatorio)
            else:
                trabajador = Trabajador()
            self.pool_trabajadores.append(trabajador)

    def calcular_productividad_regional(self) -> float:
        """Calcula la productividad promedio de la región"""
        if not self.corporaciones:
            return 0.0

        productividades = []
        for corporacion in self.corporaciones:
            # Usar el método de la clase Corporacion
            productividad = corporacion.calcular_productividad()
            productividades.append(productividad)

        return np.mean(productividades) if productividades else 0.0

    def calcular_coordinacion_economica(self) -> float:
        """Calcula el índice de coordinación económica"""
        # Base de coordinación
        coordinacion_base = 0.5

        # Ajustar por tipología económica
        if self.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
            factor_ajuste = 0.8  # Menor coordinación en regiones atrapadas
        else:  # NO_ATRAPADA
            factor_ajuste = 1.2  # Mayor coordinación en regiones no atrapadas

        # Factores adicionales
        factor_desarrollo = self.caracteristicas.desarrollo_economico
        factor_conectividad = self.caracteristicas.conectividad_transport

        coordinacion = coordinacion_base * factor_ajuste * (1 + factor_desarrollo + factor_conectividad) / 3
        return np.clip(coordinacion, 0.1, 1.0)

    def calcular_diversidad_sectorial(self) -> float:
        """Calcula el índice de diversidad sectorial"""
        # Ajustar diversidad según tipología
        if self.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
            # Regiones atrapadas: menor diversidad
            diversidad_base = self.parametros_tipologicos.diversidad_base * 0.8
        else:  # NO_ATRAPADA
            # Regiones no atrapadas: mayor diversidad
            diversidad_base = self.parametros_tipologicos.diversidad_base * 1.2

        # Factor de número de sectores activos
        factor_sectores = min(1.0, len(self.sectores_activos) / 5.0)

        # Factor de distribución (más equitativa = más diversa)
        factor_distribucion = 0.8 + 0.2 * len(set(self.sectores_activos)) / len(self.sectores_activos)

        diversidad = diversidad_base * factor_sectores * factor_distribucion
        return np.clip(diversidad, 0.1, 1.0)

    def esta_en_trampa_innovacion(self) -> bool:
        """Determina si la región está en trampa de innovación"""
        # Umbral basado en evidencia empírica
        umbral_innovacion = 0.08
        umbral_especializacion = 0.60
        umbral_diversidad = 0.50

        # Criterios para trampa de innovación (regiones atrapadas)
        baja_innovacion = self.capacidad_tecnologica < umbral_innovacion
        alta_especializacion = self.parametros_tipologicos.especializacion_base > umbral_especializacion
        baja_diversidad = self.diversidad_sectorial < umbral_diversidad

        # Aplicar lógica tipológica
        if self.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
            # Regiones atrapadas: presumiblemente en trampa
            return baja_innovacion or (alta_especializacion and baja_diversidad)
        else:  # NO_ATRAPADA
            # Regiones no atrapadas: raramente en trampa
            return baja_innovacion and alta_especializacion and baja_diversidad

    def ejecutar_paso_simulacion(self, paso_tiempo: int) -> Dict:
        """Ejecuta un paso de simulación para la región"""
        # Initialize tasa_innovacion from tipological parameters
        tasa_innovacion = self.parametros_tipologicos.tasa_innovacion_base

        resultados = {
            'id_region': self.id,
            'tipo_region': self.tipo_region.value,
            'tipo_region_economica_inicial': self.tipo_region_economica.value,
            'paso_tiempo': paso_tiempo,
            'capacidad_tecnologica': self.capacidad_tecnologica,
            'diversidad_sectorial': self.diversidad_sectorial,
            'productividad_promedio': self.productividad_promedio,
            'coordinacion_promedio': self.coordinacion_inter_sectorial,
            'innovaciones_realizadas': 0,
            'flujos_internos': 0.0,
            'empleo_especializado': 0,
            'empleo_total': 0,
            'eficiencia_asignacion': 0.0,
            'atrapada': self.esta_en_trampa_innovacion(),
            'tasa_innovacion': tasa_innovacion,
            'especializacion': 0.0,
            'actualizacion_tecnologica': 0.0,
            'brecha_calificacion': 0.0,
            'empleo_total_region': 0,
            'empleo_especializado_region': 0,
            # CARACTERÍSTICAS GEOGRÁFICAS ESPECÍFICAS DE MÉXICO
            'desarrollo_economico_geo': self.caracteristicas.desarrollo_economico,
            'cercania_frontera_eeuu': self.caracteristicas.cercania_eeuu,
            'riqueza_natural_geo': self.caracteristicas.riqueza_natural,
            'factor_aridez': self.caracteristicas.clima_aridez,
            'rezago_social_geo': self.caracteristicas.rezago_social,
            'conectividad_transport': self.caracteristicas.conectividad_transport,
            'inversion_extranjera_geo': self.caracteristicas.inversion_extranjera
        }

        # Calcular diversidad y especialización para ecuaciones calibradas
        especializacion = 1 - self.diversidad_sectorial

        # Actualizar capacidad tecnológica usando ecuaciones calibradas
        nueva_capacidad = EcuacionesCalibradas.evolucion_capacidad_tecnologica(
            capacidad_actual=self.capacidad_tecnologica,
            innovacion=tasa_innovacion,
            diversidad=self.diversidad_sectorial,
            especializacion=especializacion,
            tipo_region_economica=self.tipo_region_economica
        )

        self.capacidad_tecnologica = nueva_capacidad
        self.historial_capacidad_tecnologica.append(self.capacidad_tecnologica)

        # Actualizar diversidad sectorial
        self.diversidad_sectorial = self.calcular_diversidad_sectorial()

        # Actualizar métricas de corporaciones
        innovaciones_totales = 0
        total_corporaciones = len(self.corporaciones)
        for corporacion in self.corporaciones:
            # Producción
            produccion = corporacion.producir()

            # Innovación con factor tipológico
            innovacion = corporacion.innovar()
            if innovacion:
                innovaciones_totales += 1

            # Actualizar productividad de la corporación usando sus métodos
            corporacion.actualizar_productividad()

        # Recalcular tasa de innovación based on innovations made in this step
        if total_corporaciones > 0:
            tasa_innovacion = innovaciones_totales / total_corporaciones
        else:
            tasa_innovacion = 0.0 # Default if no corporations

        # Calcular actualización tecnológica
        if len(self.historial_capacidad_tecnologica) > 1:
            actualizacion_tec = abs(self.capacidad_tecnologica - self.historial_capacidad_tecnologica[-2])
        else:
            actualizacion_tec = 0.0

        # Actualizar métricas laborales usando métodos de FuerzaLaboral
        empleo_especializado = 0
        empleo_total = 0
        brecha_calificacion_promedio = 0.0
        for fuerza_laboral in self.fuerzas_laborales.values():
            # Actualizar métricas de la fuerza laboral
            fuerza_laboral.actualizar_metricas()
            fuerza_laboral.calcular_brecha_calificacion()

            # Usar método de la clase para obtener empleo especializado
            empleo_especializado += fuerza_laboral.obtener_empleo_especializado()
            empleo_total += len(fuerza_laboral.trabajadores)
            brecha_calificacion_promedio += fuerza_laboral.brecha_calificacion

        # Promediar brecha de calificación
        if self.fuerzas_laborales:
            brecha_calificacion_promedio = brecha_calificacion_promedio / len(self.fuerzas_laborales)

        # Calcular productividad regional usando métodos de las corporaciones
        self.productividad_promedio = self.calcular_productividad_regional()

        # Calcular probabilidad de transición usando ecuaciones calibradas
        probabilidad_transicion = EcuacionesCalibradas.probabilidad_transicion_tipologia(
            capacidad_tecnologica=self.capacidad_tecnologica,
            diversificacion=self.diversidad_sectorial,
            especializacion=especializacion,
            innovacion=tasa_innovacion
        )

        # Actualizar resultados con probabilidad de transición
        resultados['probabilidad_transicion'] = probabilidad_transicion

        # Calcular coordinación
        self.coordinacion_inter_sectorial = self.calcular_coordinacion_economica()

        # Calcular resiliencia a crisis si hay shock externo
        factor_shock_externo = 0.0  # Se puede configurar externamente
        if factor_shock_externo > 0:
            resiliencia = EcuacionesCalibradas.resiliencia_crisis(
                tipo_region_economica=self.tipo_region_economica,
                shock_intensidad=factor_shock_externo,
                tiempo_paso=paso_tiempo
            )
            resultados['resiliencia_crisis'] = resiliencia
        else:
            resultados['resiliencia_crisis'] = 1.0

        # Actualizar resultados
        resultados.update({
            'innovaciones_realizadas': innovaciones_totales,
            'empleo_especializado': empleo_especializado,
            'empleo_total': empleo_total,
            'empleo_especializado_region': empleo_especializado,
            'empleo_total_region': empleo_total,
            'eficiencia_asignacion': min(1.0, empleo_especializado / max(1, empleo_total)),
            'flujos_internos': self.flujos_comerciales,
            'tasa_innovacion': tasa_innovacion,
            'especializacion': especializacion,
            'actualizacion_tecnologica': actualizacion_tec,
            'brecha_calificacion': brecha_calificacion_promedio
        })

        return resultados

    def obtener_metricas_integradas(self) -> Dict[str, float]:
        """Obtiene métricas integradas usando todas las clases del modelo"""
        metricas = {
            'productividad': self.calcular_productividad_regional(),
            'coordinacion': self.calcular_coordinacion_economica(),
            'diversidad': self.calcular_diversidad_sectorial(),
            'empleo_total': self.obtener_empleo_total(),
            'empleo_especializado': self.obtener_empleo_especializado(),
            'en_trampa': self.esta_en_trampa_innovacion()
        }

        # Añadir métricas de fuerzas laborales si están disponibles
        if self.fuerzas_laborales:
            metricas['brecha_calificacion_promedio'] = np.mean([
                fuerza.brecha_calificacion for fuerza in self.fuerzas_laborales.values()
            ])
            metricas['habilidad_promedio'] = np.mean([
                fuerza.habilidad_promedio for fuerza in self.fuerzas_laborales.values()
            ])

        return metricas

    def simular_impacto_crisis(self, intensidad_shock: float) -> Dict[str, float]:
        """Simula el impacto de una crisis económica usando ecuaciones calibradas"""
        # Calcular resiliencia usando ecuaciones calibradas
        resiliencia = EcuacionesCalibradas.resiliencia_crisis(
            tipo_region_economica=self.tipo_region_economica,
            shock_intensidad=intensidad_shock,
            tiempo_paso=12  # 12 meses
        )

        # Calcular impacto en productividad
        productividad_antes = self.calcular_productividad_regional()
        productividad_despues = productividad_antes * resiliencia

        # Calcular impacto en empleo
        empleo_antes = self.obtener_empleo_total()
        impacto_empleo = max(0, 1 - resiliencia * 1.5)  # Mayor impacto en empleo
        empleo_despues = int(empleo_antes * (1 - impacto_empleo))

        return {
            'resiliencia': resiliencia,
            'productividad_antes': productividad_antes,
            'productividad_despues': productividad_despues,
            'empleo_antes': empleo_antes,
            'empleo_despues': empleo_despues,
            'perdida_productividad': productividad_antes - productividad_despues,
            'perdida_empleo': empleo_antes - empleo_despues
        }

"""# =============================================
# MODELO ECONÓMICO REGIONAL
# =============================================
"""

class ModeloEconomicoRegional:
    """Modelo económico regional basado en agentes con tipologías integradas"""

    def __init__(self, num_regiones: int = 32):
        self.num_regiones = num_regiones
        self.regiones: List[Region] = []
        self.resultados_simulacion: List[Dict] = []
        self.parametros_tipologicos = ConfiguracionTipologias.obtener_parametros_tipologicos()

        # Inicializar regiones
        self._inicializar_regiones()

    def _inicializar_regiones(self):
        """Inicializa las regiones del modelo con distribución empírica mexicana

        Basado en investigación empírica:
        - 75% regiones atrapadas (alta especialización, baja innovación)
        - 25% regiones no atrapadas (diversificación, ecosistemas innovación)
        """
        tipos_region = list(TipoRegion)

        # Distribución empírica: 75% atrapadas, 25% no atrapadas
        num_atrapadas = int(self.num_regiones * 0.75)  # 24 regiones atrapadas
        num_no_atrapadas = self.num_regiones - num_atrapadas  # 8 regiones no atrapadas

        # Crear lista de tipos económicos con distribución empírica
        tipos_economicos = (
            [TipoRegionEconomica.ATRAPADA] * num_atrapadas +
            [TipoRegionEconomica.NO_ATRAPADA] * num_no_atrapadas
        )

        # Mezclar para distribución geográfica aleatoria
        np.random.shuffle(tipos_economicos)

        for i in range(self.num_regiones):
            tipo_region = tipos_region[i % len(tipos_region)]
            tipo_economico = tipos_economicos[i]
            region = Region(i, tipo_region, tipo_economico)
            self.regiones.append(region)

    def ejecutar_simulacion(self, num_pasos: int = 60) -> pd.DataFrame:
        """Ejecuta la simulación completa"""
        print(f"Iniciando simulación con {len(self.regiones)} regiones por {num_pasos} pasos...")

        for paso in range(num_pasos):
            if paso % 10 == 0:
                print(f"Ejecutando paso {paso}/{num_pasos}")

            for region in self.regiones:
                resultado = region.ejecutar_paso_simulacion(paso)
                self.resultados_simulacion.append(resultado)

        # Convertir a DataFrame
        df_resultados = pd.DataFrame(self.resultados_simulacion)
        print(f"Simulación completada. {len(df_resultados)} registros generados.")

        return df_resultados

    def aplicar_ecuaciones_calibradas(self, region: 'Region') -> Dict:
        """
        Aplica las ecuaciones matemáticas calibradas a una región

        Integra:
        - Función de producción regional
        - Evolución capacidad tecnológica
        - Probabilidades de transición
        - Resiliencia a crisis

        Returns:
            Dict con métricas calculadas usando ecuaciones empíricas
        """
        # Función de producción calibrada
        produccion = EcuacionesCalibradas.funcion_produccion_regional(
            capital=0.65,  # Valor simulado
            labor=region.parametros_tipologicos.empleo_total_base,
            capital_humano=0.45,  # Promedio nacional
            innovacion=region.parametros_tipologicos.capacidad_tecnologica_base,
            id_inversion=0.0041,  # México 0.41% PIB
            infraestructura=0.52,  # Índice infraestructura promedio
            tipo_region_economica=region.tipo_region_economica
        )

        # Evolución capacidad tecnológica
        nueva_capacidad = EcuacionesCalibradas.evolucion_capacidad_tecnologica(
            capacidad_actual=region.capacidad_tecnologica,
            innovacion=region.parametros_tipologicos.tasa_innovacion_base,
            diversidad=region.parametros_tipologicos.diversidad_base,
            especializacion=region.parametros_tipologicos.especializacion_base,
            tipo_region_economica=region.tipo_region_economica
        )

        # Probabilidad de transición (solo para regiones atrapadas)
        if region.tipo_region_economica == TipoRegionEconomica.ATRAPADA:
            prob_transicion = EcuacionesCalibradas.probabilidad_transicion_tipologia(
                capacidad_tecnologica=nueva_capacidad,
                diversificacion=region.parametros_tipologicos.diversidad_base,
                especializacion=region.parametros_tipologicos.especializacion_base,
                innovacion=region.parametros_tipologicos.tasa_innovacion_base
            )
        else:
            prob_transicion = 0.0

        return {
            'produccion_regional': produccion,
            'nueva_capacidad_tecnologica': nueva_capacidad,
            'probabilidad_transicion': prob_transicion,
            'resiliencia_base': EcuacionesCalibradas.resiliencia_crisis(
                region.tipo_region_economica, 0.3, 1
            )
        }

    def analizar_politicas_cyt_regional(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas C&T a nivel regional con tipologías"""
        analisis = {}

        for tipo_region in resultados['tipo_region'].unique():
            datos_region = resultados[resultados['tipo_region'] == tipo_region]

            # Obtener tipología económica predominante
            tipologias = datos_region['tipo_region_economica_inicial'].value_counts()
            tipologia_predominante = tipologias.index[0] if len(tipologias) > 0 else 'Desconocida'

            analisis[tipo_region] = {
                'metricas_cyt': {
                    'capacidad_tecnologica_promedio': datos_region['capacidad_tecnologica'].mean(),
                    'innovaciones_total': datos_region['innovaciones_realizadas'].sum(),
                    'innovaciones_promedio': datos_region['innovaciones_realizadas'].mean(),
                    'tasa_innovacion_promedio': datos_region['tasa_innovacion'].mean(),
                    'actualizacion_tecnologica_promedio': datos_region['actualizacion_tecnologica'].mean(),
                    'coordinacion_economica': datos_region['coordinacion_promedio'].mean(),
                    'flujos_conocimiento_interno': datos_region['flujos_internos'].mean(),
                    'eficiencia_asignacion': datos_region['eficiencia_asignacion'].mean(),
                    'porcentaje_atrapadas': datos_region['atrapada'].mean() * 100
                },
                'metricas_especializacion_diversificacion': {
                    'diversidad_sectorial_promedio': datos_region['diversidad_sectorial'].mean(),
                    'especializacion_promedio': datos_region['especializacion'].mean(),
                    'diversidad_sectorial_std': datos_region['diversidad_sectorial'].std(),
                    'especializacion_std': datos_region['especializacion'].std()
                },
                'metricas_empleo': {
                    'empleo_total_promedio': datos_region['empleo_total'].mean(),
                    'empleo_especializado_promedio': datos_region['empleo_especializado'].mean(),
                    'empleo_especializado_total_promedio': datos_region['empleo_especializado_region'].mean(),
                    'empleo_total_region_promedio': datos_region['empleo_total_region'].mean(),
                    'ratio_especializado_total': (datos_region['empleo_especializado'].mean() /
                                                max(1, datos_region['empleo_total'].mean()))
                },
                'metricas_productividad': {
                    'productividad_promedio': datos_region['productividad_promedio'].mean(),
                    'productividad_std': datos_region['productividad_promedio'].std(),
                    'productividad_min': datos_region['productividad_promedio'].min(),
                    'productividad_max': datos_region['productividad_promedio'].max(),
                    'productividad_por_innovacion': (datos_region['tasa_innovacion'].mean() /
                                                   max(0.01, datos_region['productividad_promedio'].mean())),
                    'productividad_tecnologica': (datos_region['productividad_promedio'].mean() /
                                                max(0.01, datos_region['capacidad_tecnologica'].mean())),
                    'eficiencia_empleo_productivo': (datos_region['productividad_promedio'].mean() /
                                                    max(0.01, datos_region['empleo_especializado'].mean())),
                    'indice_productividad_regional': datos_region['productividad_promedio'].mean() / datos_region['productividad_promedio'].std()
                },
                'metricas_calificacion': {
                    'brecha_calificacion_promedio': datos_region['brecha_calificacion'].mean(),
                    'brecha_calificacion_std': datos_region['brecha_calificacion'].std(),
                    'brecha_calificacion_min': datos_region['brecha_calificacion'].min(),
                    'brecha_calificacion_max': datos_region['brecha_calificacion'].max()
                },
                'condiciones_entorno': {
                    'carencias_educativas': 1 - datos_region['coordinacion_promedio'].mean(),
                    'nivel_diversificacion': datos_region['diversidad_sectorial'].mean(),
                    'nivel_especializacion': 1 - datos_region['diversidad_sectorial'].mean(),
                    'capacidad_absorcion': datos_region['coordinacion_promedio'].mean() * 0.8,
                    'efectividad_sistema_innovacion': datos_region['innovaciones_realizadas'].mean() / max(0.01, datos_region['capacidad_tecnologica'].mean())
                },
                'tipologia_economica': tipologia_predominante,
                'politicas_recomendadas': self._generar_politicas_regionales(tipologia_predominante, datos_region)
            }

        return analisis

    def analizar_politicas_cyt_sectorial(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas C&T a nivel sectorial"""
        # Simulación de análisis sectorial basado en los datos disponibles
        sectores_simulados = ['Manufactura_Alta', 'Servicios_Avanzados', 'Primario_Alto', 'Servicios_Intermedios', 'Turismo_Especializado']
        analisis = {}

        for sector in sectores_simulados:
            # Simular datos sectoriales
            datos_sector = resultados.sample(min(50, len(resultados)//2))  # Simular presencia sectorial

            analisis[sector] = {
                'metricas_cyt': {
                    'regiones_con_sector': len(datos_sector),
                    'innovaciones_promedio': datos_sector['innovaciones_realizadas'].mean(),
                    'tasa_innovacion_promedio': datos_sector['tasa_innovacion'].mean(),
                    'actualizacion_tecnologica_promedio': datos_sector['actualizacion_tecnologica'].mean(),
                    'productividad_promedio': datos_sector['productividad_promedio'].mean(),
                    'coordinacion_interregional': datos_sector['coordinacion_promedio'].mean(),
                    'capacidad_tecnologica': datos_sector['capacidad_tecnologica'].mean()
                },
                'especializacion_diversificacion': {
                    'grado_especializacion': np.random.uniform(0.3, 0.8),
                    'grado_diversificacion': datos_sector['diversidad_sectorial'].mean(),
                    'concentracion_geografica': np.random.uniform(0.2, 0.7),
                    'difusion_tecnologica': np.random.uniform(0.4, 0.9),
                    'especializacion_sectorial': datos_sector['especializacion'].mean()
                },
                'empleo_sectorial': {
                    'empleo_total_promedio': datos_sector['empleo_total'].mean(),
                    'empleo_especializado_promedio': datos_sector['empleo_especializado'].mean(),
                    'ratio_especializado_total': (datos_sector['empleo_especializado'].mean() /
                                                max(1, datos_sector['empleo_total'].mean()))
                },
                'metricas_productividad': {
                    'productividad_regional_promedio': datos_sector['productividad_promedio'].mean(),
                    'productividad_regional_std': datos_sector['productividad_promedio'].std(),
                    'productividad_por_empleado': (datos_sector['productividad_promedio'].mean() /
                                                 max(0.01, datos_sector['empleo_especializado'].mean())),
                    'productividad_por_innovacion': (datos_sector['productividad_promedio'].mean() /
                                                    max(0.01, datos_sector['tasa_innovacion'].mean())),
                    'productividad_tecnologica': (datos_sector['productividad_promedio'].mean() /
                                                max(0.01, datos_sector['capacidad_tecnologica'].mean())),
                    'eficiencia_productiva_sectorial': datos_sector['productividad_promedio'].mean() / datos_sector['coordinacion_promedio'].mean(),
                    'indice_competitividad_sectorial': (datos_sector['productividad_promedio'].mean() *
                                                      datos_sector['tasa_innovacion'].mean()) / max(0.01, datos_sector['brecha_calificacion'].mean())
                },
                'calificacion_trabajo': {
                    'brecha_calificacion_promedio': datos_sector['brecha_calificacion'].mean(),
                    'brecha_calificacion_std': datos_sector['brecha_calificacion'].std(),
                    'eficiencia_asignacion': datos_sector['eficiencia_asignacion'].mean()
                },
                'regiones_predominantes': dict(zip(
                    resultados['tipo_region'].unique()[:3],
                    np.random.uniform(0.1, 0.5, 3)
                ))
            }

        return analisis

    def analizar_politicas_cyt_corporativo(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas C&T a nivel corporativo"""
        analisis = {
            'por_tamaño_corporativo': {},
            'por_tecnologia': {},
            'por_especializacion': {},
            'por_calificacion': {}
        }

        # Análisis por tamaño corporativo simulado
        for tipo_region in resultados['tipo_region'].unique()[:4]:  # Top 4 regiones
            datos_region = resultados[resultados['tipo_region'] == tipo_region]
            analisis['por_tamaño_corporativo'][tipo_region] = {
                'corporaciones_grandes': np.random.randint(15, 40),
                'corporaciones_pequeñas': np.random.randint(50, 120),
                'ratio_grandes_pequenas': np.random.uniform(0.2, 0.5),
                'capacidades_promedio_grandes': np.random.uniform(0.6, 0.9),
                'capacidades_promedio_pequeñas': np.random.uniform(0.3, 0.7),
                'innovaciones_grandes': np.random.uniform(2, 15),
                'innovaciones_pequeñas': np.random.uniform(0.5, 5),
                'empleo_total_regional': datos_region['empleo_total'].mean(),
                'empleo_especializado_regional': datos_region['empleo_especializado'].mean(),
                'productividad_grandes': np.random.uniform(0.6, 0.9),
                'productividad_pequeñas': np.random.uniform(0.3, 0.7),
                'metricas_productividad': {
                    'productividad_regional_promedio': datos_region['productividad_promedio'].mean(),
                    'productividad_por_empleado_grande': np.random.uniform(0.6, 0.9) / max(0.01, datos_region['empleo_especializado'].mean()),
                    'productividad_por_empleado_pequena': np.random.uniform(0.3, 0.7) / max(0.01, datos_region['empleo_total'].mean()),
                    'eficiencia_productiva_grandes': np.random.uniform(0.6, 0.9) / datos_region['brecha_calificacion'].mean(),
                    'eficiencia_productiva_pequenas': np.random.uniform(0.3, 0.7) / datos_region['brecha_calificacion'].mean(),
                    'productividad_innovativa_grandes': np.random.uniform(0.6, 0.9) / max(0.01, datos_region['tasa_innovacion'].mean()),
                    'productividad_innovativa_pequenas': np.random.uniform(0.3, 0.7) / max(0.01, datos_region['tasa_innovacion'].mean()),
                    'indice_competitividad_corporativo': (datos_region['productividad_promedio'].mean() *
                                                        datos_region['tasa_innovacion'].mean()) / max(0.01, datos_region['brecha_calificacion'].mean())
                }
            }

        # Análisis por nivel tecnológico simulado
        niveles_tech = ['Alta_Tecnologia', 'Media_Tecnologia', 'Baja_Tecnologia']
        for nivel in niveles_tech:
            datos_simulados = resultados.sample(min(30, len(resultados)//3))
            analisis['por_tecnologia'][nivel] = {
                'regiones_con_tecnologia': np.random.randint(8, 20),
                'innovaciones_promedio': np.random.uniform(2, 15),
                'tasa_innovacion_promedio': datos_simulados['tasa_innovacion'].mean(),
                'actualizacion_tecnologica_promedio': datos_simulados['actualizacion_tecnologica'].mean(),
                'coordinacion_promedio': np.random.uniform(0.4, 0.8),
                'productividad_promedio': np.random.uniform(0.3, 0.9),
                'tasa_atrapamiento': np.random.uniform(10, 60),
                'empleo_total': datos_simulados['empleo_total'].mean(),
                'empleo_especializado': datos_simulados['empleo_especializado'].mean(),
                'ratio_especializado': (datos_simulados['empleo_especializado'].mean() /
                                       max(1, datos_simulados['empleo_total'].mean())),
                'metricas_productividad': {
                    'productividad_regional_promedio': datos_simulados['productividad_promedio'].mean(),
                    'productividad_por_empleo_especializado': (datos_simulados['productividad_promedio'].mean() /
                                                              max(0.01, datos_simulados['empleo_especializado'].mean())),
                    'productividad_por_innovacion': (datos_simulados['productividad_promedio'].mean() /
                                                   max(0.01, datos_simulados['tasa_innovacion'].mean())),
                    'productividad_tecnologica': (datos_simulados['productividad_promedio'].mean() /
                                                max(0.01, datos_simulados['capacidad_tecnologica'].mean())),
                    'eficiencia_productiva': datos_simulados['productividad_promedio'].mean() / datos_simulados['brecha_calificacion'].mean(),
                    'indice_conversion_innovacion': (datos_simulados['tasa_innovacion'].mean() *
                                                   datos_simulados['productividad_promedio'].mean()) / max(0.01, datos_simulados['actualizacion_tecnologica'].mean()),
                    'productividad_ajustada_tecnologia': np.random.uniform(0.3, 0.9) * (1 + datos_simulados['actualizacion_tecnologica'].mean())
                }
            }

        # Análisis por nivel de especialización
        analisis['por_especializacion'] = {
            'Alta_Especializacion': {
                'regiones_con_alta_esp': len(resultados[resultados['especializacion'] > 0.7]),
                'diversidad_promedio': resultados[resultados['especializacion'] > 0.7]['diversidad_sectorial'].mean(),
                'innovaciones_promedio': resultados[resultados['especializacion'] > 0.7]['innovaciones_realizadas'].mean(),
                'productividad_promedio': resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean(),
                'empleo_especializado_ratio': (resultados[resultados['especializacion'] > 0.7]['empleo_especializado'].mean() /
                                              max(1, resultados[resultados['especializacion'] > 0.7]['empleo_total'].mean())),
                'metricas_productividad': {
                    'productividad_regional_promedio': resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean(),
                    'productividad_por_empleo': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() /
                                                max(0.01, resultados[resultados['especializacion'] > 0.7]['empleo_especializado'].mean())),
                    'productividad_especializada': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() *
                                                  resultados[resultados['especializacion'] > 0.7]['especializacion'].mean()),
                    'eficiencia_especializacion_productiva': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() /
                                                             max(0.01, resultados[resultados['especializacion'] > 0.7]['brecha_calificacion'].mean())),
                    'productividad_innovacion_especializada': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() /
                                                             max(0.01, resultados[resultados['especializacion'] > 0.7]['tasa_innovacion'].mean())),
                    'indice_ventaja_competitiva': (resultados[resultados['especializacion'] > 0.7]['productividad_promedio'].mean() *
                                                  resultados[resultados['especializacion'] > 0.7]['especializacion'].mean()) / max(0.01, resultados[resultados['especializacion'] > 0.7]['diversidad_sectorial'].mean())
                }
            },
            'Baja_Especializacion': {
                'regiones_con_baja_esp': len(resultados[resultados['especializacion'] < 0.3]),
                'diversidad_promedio': resultados[resultados['especializacion'] < 0.3]['diversidad_sectorial'].mean(),
                'innovaciones_promedio': resultados[resultados['especializacion'] < 0.3]['innovaciones_realizadas'].mean(),
                'productividad_promedio': resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean(),
                'empleo_especializado_ratio': (resultados[resultados['especializacion'] < 0.3]['empleo_especializado'].mean() /
                                              max(1, resultados[resultados['especializacion'] < 0.3]['empleo_total'].mean())),
                'metricas_productividad': {
                    'productividad_regional_promedio': resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean(),
                    'productividad_por_empleo': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() /
                                                max(0.01, resultados[resultados['especializacion'] < 0.3]['empleo_especializado'].mean())),
                    'productividad_diversificada': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() *
                                                  resultados[resultados['especializacion'] < 0.3]['diversidad_sectorial'].mean()),
                    'eficiencia_diversificacion_productiva': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() /
                                                             max(0.01, resultados[resultados['especializacion'] < 0.3]['brecha_calificacion'].mean())),
                    'productividad_innovacion_diversificada': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() /
                                                             max(0.01, resultados[resultados['especializacion'] < 0.3]['tasa_innovacion'].mean())),
                    'indice_flexibilidad_productiva': (resultados[resultados['especializacion'] < 0.3]['productividad_promedio'].mean() *
                                                     resultados[resultados['especializacion'] < 0.3]['diversidad_sectorial'].mean()) / max(0.01, resultados[resultados['especializacion'] < 0.3]['especializacion'].mean())
                }
            }
        }

        # Análisis por brecha de calificación
        analisis['por_calificacion'] = {
            'Baja_Brecha_Calificacion': {
                'regiones_con_baja_brecha': len(resultados[resultados['brecha_calificacion'] < 0.5]),
                'brecha_calificacion_promedio': resultados[resultados['brecha_calificacion'] < 0.5]['brecha_calificacion'].mean(),
                'innovaciones_promedio': resultados[resultados['brecha_calificacion'] < 0.5]['innovaciones_realizadas'].mean(),
                'productividad_promedio': resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean(),
                'eficiencia_asignacion': resultados[resultados['brecha_calificacion'] < 0.5]['eficiencia_asignacion'].mean(),
                'metricas_productividad': {
                    'productividad_regional_promedio': resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean(),
                    'productividad_ajustada_capacidades': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() /
                                                          max(0.01, resultados[resultados['brecha_calificacion'] < 0.5]['brecha_calificacion'].mean())),
                    'eficiencia_capital_humano': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() *
                                                (1 - resultados[resultados['brecha_calificacion'] < 0.5]['brecha_calificacion'].mean())),
                    'productividad_innovacion_capacidades': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() /
                                                           max(0.01, resultados[resultados['brecha_calificacion'] < 0.5]['tasa_innovacion'].mean())),
                    'indice_efectividad_capital_humano': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() *
                                                        (1 - resultados[resultados['brecha_calificacion'] < 0.5]['brecha_calificacion'].mean()) *
                                                        resultados[resultados['brecha_calificacion'] < 0.5]['eficiencia_asignacion'].mean()),
                    'productividad_tecnologica_capacitada': (resultados[resultados['brecha_calificacion'] < 0.5]['productividad_promedio'].mean() *
                                                           (1 + resultados[resultados['brecha_calificacion'] < 0.5]['capacidad_tecnologica'].mean()))
                }
            },
            'Alta_Brecha_Calificacion': {
                'regiones_con_alta_brecha': len(resultados[resultados['brecha_calificacion'] > 0.7]),
                'brecha_calificacion_promedio': resultados[resultados['brecha_calificacion'] > 0.7]['brecha_calificacion'].mean(),
                'innovaciones_promedio': resultados[resultados['brecha_calificacion'] > 0.7]['innovaciones_realizadas'].mean(),
                'productividad_promedio': resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean(),
                'eficiencia_asignacion': resultados[resultados['brecha_calificacion'] > 0.7]['eficiencia_asignacion'].mean(),
                'metricas_productividad': {
                    'productividad_regional_promedio': resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean(),
                    'productividad_ajustada_capacidades': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() /
                                                          max(0.01, resultados[resultados['brecha_calificacion'] > 0.7]['brecha_calificacion'].mean())),
                    'eficiencia_capital_humano': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() *
                                                (1 - resultados[resultados['brecha_calificacion'] > 0.7]['brecha_calificacion'].mean())),
                    'productividad_innovacion_capacidades': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() /
                                                           max(0.01, resultados[resultados['brecha_calificacion'] > 0.7]['tasa_innovacion'].mean())),
                    'indice_efectividad_capital_humano': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() *
                                                        (1 - resultados[resultados['brecha_calificacion'] > 0.7]['brecha_calificacion'].mean()) *
                                                        resultados[resultados['brecha_calificacion'] > 0.7]['eficiencia_asignacion'].mean()),
                    'productividad_tecnologica_capacitada': (resultados[resultados['brecha_calificacion'] > 0.7]['productividad_promedio'].mean() *
                                                           (1 + resultados[resultados['brecha_calificacion'] > 0.7]['capacidad_tecnologica'].mean()))
                }
            }
        }

        return analisis

    def analizar_politicas_cyt_geografico(self, resultados: pd.DataFrame) -> Dict:
        """Análisis de políticas C&T por región geográfica específica de México"""
        analisis_geografico = {}

        # Análisis específico por cada región geográfica de México
        regiones_geograficas = {
            'NOROESTE': {
                'descripcion': 'Baja California, Baja California Sur, Chihuahua, Durango, Sinaloa, Sonora',
                'caracteristicas_principales': 'Frontera con EE.UU., clima árido, minería y agricultura',
                'fortalezas': ['Cercanía comercial EE.UU.', 'Recursos naturales', 'Conectividad fronteriza'],
                'desafios': ['Aridez climática', 'Rezago social', 'Dependencia comercial']
            },
            'NORESTE': {
                'descripcion': 'Coahuila, Nuevo León, Tamaulipas',
                'caracteristicas_principales': 'Industrialización avanzada, manufactura, servicios financieros',
                'fortalezas': ['Alto desarrollo económico', 'Inversión extranjera', 'Infraestructura'],
                'desafios': ['Competencia internacional', 'Sostenibilidad ambiental']
            },
            'OCCIDENTE': {
                'descripcion': 'Colima, Jalisco, Michoacán, Nayarit',
                'caracteristicas_principales': 'Diversidad económica, agricultura tecnificada, manufactura',
                'fortalezas': ['Diversidad sectorial', 'Recursos naturales', 'Potencial turístico'],
                'desafios': ['Rezago social', 'Conectividad interna', 'Volcanismo']
            },
            'CENTRONORTE': {
                'descripcion': 'Aguascalientes, Guanajuato, Querétaro, San Luis Potosí, Zacatecas',
                'caracteristicas_principales': 'Manufactura automotriz, agroindustria, servicios',
                'fortalezas': ['Proximidad mercados', 'Tradición manufacturera', 'Capacitación técnica'],
                'desafios': ['Competencia global', 'Innovación tecnológica']
            },
            'ORIENTE': {
                'descripcion': 'Ciudad de México, México, Morelos, Tlaxcala, Hidalgo, Puebla',
                'caracteristicas_principales': 'CDMX, alta densidad poblacional, servicios avanzados',
                'fortalezas': ['Capital nacional', 'Servicios financieros', 'Educación superior'],
                'desafios': ['Congestión urbana', 'Contaminación', 'Desigualdad social']
            },
            'SUROESTE': {
                'descripcion': 'Chiapas, Guerrero, Oaxaca',
                'caracteristicas_principales': 'Mayor rezago social, recursos naturales, turismo cultural',
                'fortalezas': ['Riqueza natural', 'Patrimonio cultural', 'Potencial turístico'],
                'desafios': ['Alto rezago social', 'Pobreza', 'Aislamiento geográfico']
            },
            'SURESTE': {
                'descripcion': 'Veracruz, Yucatán, Tabasco, Quintana Roo, Campeche',
                'caracteristicas_principales': 'Recursos energéticos, turismo, agricultura tropical',
                'fortalezas': ['Recursos petroleros', 'Turismo', 'Biodiversidad'],
                'desafios': ['Vulnerabilidad ambiental', 'Dependencia energética', 'Huracanes']
            }
        }

        # Análizar cada región geográfica
        for region_geo, info_region in regiones_geograficas.items():
            # Simular datos geográficos específicos basados en características
            datos_region = resultados.sample(min(30, len(resultados)//3))

            # Factores específicos por región geográfica
            if region_geo == 'NOROESTE':
                factor_desarrollo = np.random.uniform(0.6, 0.8)
                factor_frontera = 0.9
                factor_aridez = 0.8
                factor_recursos = 0.7
            elif region_geo == 'NORESTE':
                factor_desarrollo = np.random.uniform(0.7, 0.9)
                factor_frontera = 0.95
                factor_aridez = 0.6
                factor_recursos = 0.6
            elif region_geo == 'OCCIDENTE':
                factor_desarrollo = np.random.uniform(0.5, 0.8)
                factor_frontera = 0.5
                factor_aridez = 0.4
                factor_recursos = 0.8
            elif region_geo == 'CENTRONORTE':
                factor_desarrollo = np.random.uniform(0.6, 0.8)
                factor_frontera = 0.7
                factor_aridez = 0.5
                factor_recursos = 0.5
            elif region_geo == 'ORIENTE':
                factor_desarrollo = np.random.uniform(0.6, 0.9)
                factor_frontera = 0.65
                factor_aridez = 0.3
                factor_recursos = 0.4
            elif region_geo == 'SUROESTE':
                factor_desarrollo = np.random.uniform(0.2, 0.5)
                factor_frontera = 0.3
                factor_aridez = 0.2
                factor_recursos = 0.9
            else:  # SURESTE
                factor_desarrollo = np.random.uniform(0.4, 0.7)
                factor_frontera = 0.4
                factor_aridez = 0.2
                factor_recursos = 0.85

            analisis_geografico[region_geo] = {
                'informacion_regional': info_region,

                'metricas_cyt_geograficas': {
                    'capacidad_tecnologica_geo': factor_desarrollo * datos_region['capacidad_tecnologica'].mean(),
                    'tasa_innovacion_geo': factor_desarrollo * datos_region['tasa_innovacion'].mean(),
                    'actualizacion_tecnologica_geo': factor_desarrollo * datos_region['actualizacion_tecnologica'].mean(),
                    'innovaciones_geo': factor_desarrollo * datos_region['innovaciones_realizadas'].mean(),
                    'productividad_geo': factor_desarrollo * datos_region['productividad_promedio'].mean(),
                    'coordinacion_geo': datos_region['coordinacion_promedio'].mean() * factor_desarrollo,
                    'regiones_simuladas': len(datos_region)
                },

                'caracteristicas_geograficas': {
                    'desarrollo_economico_geo': factor_desarrollo,
                    'cercania_frontera_eeuu': factor_frontera if region_geo in ['NOROESTE', 'NORESTE'] else np.random.uniform(0.3, 0.7),
                    'riqueza_natural': factor_recursos,
                    'factor_aridez': factor_aridez,
                    'rezago_social_estimado': 1.0 - factor_desarrollo + np.random.uniform(-0.1, 0.1),
                    'inversion_extranjera_estimada': factor_frontera * factor_desarrollo,
                    'conectividad_transport': np.random.uniform(0.3, 0.9)
                },

                'metricas_empleo_geograficas': {
                    'empleo_total_geo': datos_region['empleo_total'].mean() * factor_desarrollo,
                    'empleo_especializado_geo': datos_region['empleo_especializado'].mean() * factor_desarrollo,
                    'ratio_especializado_geo': datos_region['empleo_especializado'].mean() / max(1, datos_region['empleo_total'].mean()),
                    'brecha_calificacion_geo': datos_region['brecha_calificacion'].mean() * (2 - factor_desarrollo)
                },

                'metricas_productividad_geograficas': {
                    'productividad_regional_geo': datos_region['productividad_promedio'].mean() * factor_desarrollo,
                    'productividad_por_frontera': (datos_region['productividad_promedio'].mean() * factor_frontera) if region_geo in ['NOROESTE', 'NORESTE'] else datos_region['productividad_promedio'].mean(),
                    'productividad_por_recursos': datos_region['productividad_promedio'].mean() * factor_recursos,
                    'eficiencia_geografica': datos_region['productividad_promedio'].mean() / datos_region['brecha_calificacion'].mean() * factor_desarrollo,
                    'indice_ventaja_competitiva_geo': (datos_region['productividad_promedio'].mean() * factor_desarrollo * factor_frontera) if region_geo in ['NOROESTE', 'NORESTE'] else datos_region['productividad_promedio'].mean() * factor_desarrollo,
                    'productividad_ajustada_clima': datos_region['productividad_promedio'].mean() * factor_desarrollo * (2 - factor_aridez),
                    'indice_desarrollo_geografico': factor_desarrollo * (0.3 + 0.2 * factor_frontera + 0.2 * factor_recursos + 0.3 * (1 - factor_aridez))
                },

                'especializacion_diversificacion_geo': {
                    'especializacion_geo': datos_region['especializacion'].mean() * (1 if factor_desarrollo > 0.7 else 0.8),
                    'diversificacion_geo': datos_region['diversidad_sectorial'].mean() * factor_desarrollo,
                    'concentracion_sectorial': np.random.uniform(0.3, 0.8) * (1 if region_geo == 'SUROESTE' else 0.7),
                    'sector_predominante': self._identificar_sector_predominante(region_geo),
                    'potencial_diversificacion': (1 - datos_region['diversidad_sectorial'].mean()) * factor_desarrollo
                },

                'politicas_geograficas_recomendadas': self._generar_politicas_geograficas(region_geo, info_region, factor_desarrollo),

                'fortalezas_geograficas': info_region['fortalezas'],
                'desafios_geograficos': info_region['desafios'],
                'prioridades_desarrollo': self._determinar_prioridades_desarrollo(region_geo, factor_desarrollo)
            }

        return analisis_geografico

    def _identificar_sector_predominante(self, region_geo: str) -> str:
        """Identifica el sector económico predominante según región geográfica"""
        sectores_por_region = {
            'NOROESTE': ['Minería Tecnológica', 'Agricultura Tecnificada', 'Manufactura Avanzada'],
            'NORESTE': ['Manufactura Avanzada', 'Servicios Financieros', 'Servicios Tecnológicos'],
            'OCCIDENTE': ['Agricultura Tecnificada', 'Turismo Especializado', 'Manufactura Básica'],
            'CENTRONORTE': ['Manufactura Avanzada', 'Servicios Intermedios', 'Agricultura Tecnificada'],
            'ORIENTE': ['Servicios Avanzados', 'Servicios Financieros', 'Turismo Especializado'],
            'SUROESTE': ['Turismo Masivo', 'Agricultura Tradicional', 'Turismo Especializado'],
            'SURESTE': ['Minería Básica', 'Turismo Especializado', 'Agricultura Tecnificada']
        }
        return np.random.choice(sectores_por_region.get(region_geo, ['Servicios Básicos']))

    def _generar_politicas_geograficas(self, region_geo: str, info_region: Dict, factor_desarrollo: float) -> List[str]:
        """Genera políticas específicas según características geográficas"""
        politicas_base = []

        if region_geo == 'NOROESTE':
            politicas_base = [
                "Aprovechamiento máximo de proximidad fronteriza con EE.UU.",
                "Desarrollo de corredores comerciales internacionales",
                "Diversificación de recursos naturales con valor agregado",
                "Tecnologías para克服 aridez y escasez de agua",
                "Clusters industriales en zonas fronterizas"
            ]
        elif region_geo == 'NORESTE':
            politicas_base = [
                "Consolidación como hub manufacturero de clase mundial",
                "Atracción de inversión extranjera directa de alta tecnología",
                "Desarrollo de servicios financieros especializados",
                "Innovación en manufactura automotriz y aeroespacial",
                "Sostenibilidad ambiental en procesos industriales"
            ]
        elif region_geo == 'OCCIDENTE':
            politicas_base = [
                "Diversificación económica equilibrada",
                "Desarrollo turístico sostenible y de alta calidad",
                "Fortalecimiento de la agroindustria tecnificada",
                "Aprovechamiento de recursos naturales renovables",
                "Mejora de conectividad interna y con mercados"
            ]
        elif region_geo == 'CENTRONORTE':
            politicas_base = [
                "Modernización de manufactura tradicional",
                "Desarrollo de clusters automotrices avanzados",
                "Fortalecimiento de educación técnica especializada",
                "Innovación en procesos agroindustriales",
                "Integración con cadenas globales de valor"
            ]
        elif region_geo == 'ORIENTE':
            politicas_base = [
                "Reingeniería de servicios metropolitanos",
                "Desarrollo de servicios financieros de alto valor",
                "Innovación en tecnologías de la información",
                "Sostenibilidad urbana y movilidad",
                "Distribución equitativa del desarrollo metropolitano"
            ]
        elif region_geo == 'SUROESTE':
            politicas_base = [
                "Reducción urgente del rezago social",
                "Desarrollo turístico cultural sostenible",
                "Aprovechamiento sostenible de recursos naturales",
                "Fortalecimiento de conectividad y infraestructura",
                "Programas intensivos de educación y capacitación"
            ]
        else:  # SURESTE
            politicas_base = [
                "Diversificación económica más allá del petróleo",
                "Desarrollo turístico sostenible de clase mundial",
                "Aprovechamiento sostenible de biodiversidad",
                "Tecnologías para adaptación al cambio climático",
                "Desarrollo de energías renovables alternativas"
            ]

        # Ajustar políticas según nivel de desarrollo
        if factor_desarrollo < 0.4:  # Bajo desarrollo
            politicas_base.extend([
                "Inversión prioritaria en infraestructura básica",
                "Programas sociales de primera necesidad",
                "Transferencia tecnológica urgente"
            ])
        elif factor_desarrollo > 0.8:  # Alto desarrollo
            politicas_base.extend([
                "Liderazgo en innovación nacional",
                "Proyección internacional de ventajas competitivas",
                "Desarrollo de tecnologías emergentes"
            ])

        return politicas_base

    def _determinar_prioridades_desarrollo(self, region_geo: str, factor_desarrollo: float) -> List[str]:
        """Determina prioridades de desarrollo según región y nivel de desarrollo"""
        prioridades = []

        # Prioridades comunes para todas las regiones
        prioridades.extend([
            "Fortalecimiento del capital humano",
            "Mejora de la infraestructura de conectividad",
            "Desarrollo de ecosistemas de innovación"
        ])

        # Prioridades específicas por región geográfica
        if region_geo in ['NOROESTE', 'NORESTE']:
            prioridades.extend([
                "Aprovechamiento del Tratado T-MEC",
                "Desarrollo de logística internacional",
                "Clusters industriales especializados"
            ])
        elif region_geo == 'SUROESTE':
            prioridades.extend([
                "Reducción de la pobreza extrema",
                "Conectividad con centros urbanos",
                "Desarrollo de capacidades básicas"
            ])
        elif region_geo == 'SURESTE':
            prioridades.extend([
                "Diversificación económica post-petrolera",
                "Adaptación al cambio climático",
                "Desarrollo turístico sostenible"
            ])

        # Prioridades según nivel de desarrollo
        if factor_desarrollo < 0.5:
            prioridades.insert(0, "Reducción del rezago social")
        elif factor_desarrollo > 0.7:
            prioridades.append("Liderazgo en innovación regional")

        return prioridades

    def _generar_politicas_regionales(self, tipologia: str, datos: pd.DataFrame) -> List[str]:
        """Genera recomendaciones de políticas basadas en tipología"""
        if tipologia == 'Atrapada':
            return [
                "Diversificación sectorial urgente para romper especialización excesiva",
                "Programas de transferencia tecnológica desde regiones no atrapadas",
                "Fortalecimiento de capacidades educativas y de investigación",
                "Incentivos a la innovación en sectores no tradicionales",
                "Creación de redes de colaboración inter-regional"
            ]
        else:  # NO_ATRAPADA (con especialización moderada/intermedia)
            return [
                "Optimización de especialización moderada para ventajas competitivas",
                "Liderazgo en I+D para mantener diferenciación tecnológica",
                "Programas de mentoring para regiones atrapadas",
                "Fortalecimiento del ecosistema de innovación",
                "Políticas de atracción de talento internacional",
                "Equilibrio entre especialización sectorial y diversificación"
            ]

"""# =============================================
# FUNCIONES DE VISUALIZACIÓN
# =============================================
"""

def setup_matplotlib_for_plotting():
    """
    Setup matplotlib and seaborn for plotting with proper configuration.
    Call this function before creating any plots to ensure proper rendering.
    """
    import warnings
    import matplotlib.pyplot as plt
    import seaborn as sns

    # Ensure warnings are printed
    warnings.filterwarnings('default')  # Show all warnings

    # Configure matplotlib for non-interactive mode
    plt.switch_backend("Agg")

    # Set chart style
    plt.style.use("seaborn-v0_8")
    sns.set_palette("husl")

    # Configure platform-appropriate fonts for cross-platform compatibility
    # Must be set after style.use, otherwise will be overridden by style configuration
    plt.rcParams["font.sans-serif"] = ["Noto Sans CJK SC", "WenQuanYi Zen Hei", "PingFang SC", "Arial Unicode MS", "Hiragino Sans GB"]
    plt.rcParams["axes.unicode_minus"] = False

    # Optimize matplotlib parameters for better visualization
    plt.rcParams['figure.facecolor'] = 'white'
    plt.rcParams['axes.facecolor'] = 'white'
    plt.rcParams['savefig.facecolor'] = 'white'
    plt.rcParams['savefig.dpi'] = 300
    plt.rcParams['figure.max_open_warning'] = 0

    # Set consistent font sizes
    plt.rcParams['font.size'] = 10
    plt.rcParams['axes.titlesize'] = 12
    plt.rcParams['axes.labelsize'] = 10
    plt.rcParams['xtick.labelsize'] = 9
    plt.rcParams['ytick.labelsize'] = 9
    plt.rcParams['legend.fontsize'] = 9

# Setup matplotlib for plotting
setup_matplotlib_for_plotting()

def calcular_correlacion_segura(df):
    """Calcula correlación de manera segura, manejando casos con varianza cero"""
    try:
        # Remover columnas con varianza cero (constantes)
        df_clean = df.loc[:, df.var() != 0]

        # Remover filas con valores NaN
        df_clean = df_clean.dropna()

        if len(df_clean.columns) < 2 or len(df_clean) < 2:
            return pd.DataFrame()

        corr = df_clean.corr()
        return corr

    except Exception as e:
        print(f"Error calculando correlación: {e}")
        return pd.DataFrame()

"""# =============================================
# FUNCIONES DE ANÁLISIS
# =============================================
"""

def ejecutar_analisis_completo():
    """Ejecuta el análisis completo del modelo económico con tipologías integradas"""
    print("=== MODELO ECONÓMICO REGIONAL CON TIPOLOGÍAS INTEGRADAS ===")
    print("Integra tipologías Atrapadas vs No Atrapadas basadas en evidencia empírica")
    print("Incluye análisis por región geográfica de México (7 regiones específicas)")
    print("Funcionalidades: Regional • Sectorial • Corporativo • Geográfico • Entorno\n")

    # Crear y ejecutar modelo
    modelo = ModeloEconomicoRegional(num_regiones=32)
    resultados = modelo.ejecutar_simulacion(num_pasos=60)

    # Crear resumen por paso con todas las métricas
    resumen = resultados.groupby('paso_tiempo').agg({
        'capacidad_tecnologica': 'mean',
        'diversidad_sectorial': 'mean',
        'productividad_promedio': 'mean',
        'coordinacion_promedio': 'mean',
        'innovaciones_realizadas': 'sum',
        'atrapada': 'mean',
        'empleo_especializado': 'mean',
        'empleo_total': 'mean',
        'eficiencia_asignacion': 'mean',
        'flujos_internos': 'mean',
        'tasa_innovacion': 'mean',
        'especializacion': 'mean',
        'actualizacion_tecnologica': 'mean',
        'brecha_calificacion': 'mean',
        'empleo_total_region': 'mean',
        'empleo_especializado_region': 'mean',
        # CARACTERÍSTICAS GEOGRÁFICAS ESPECÍFICAS
        'desarrollo_economico_geo': 'mean',
        'cercania_frontera_eeuu': 'mean',
        'riqueza_natural_geo': 'mean',
        'factor_aridez': 'mean',
        'rezago_social_geo': 'mean',
        'conectividad_transport': 'mean',
        'inversion_extranjera_geo': 'mean'
    }).round(4)

    resumen['porcentaje_atrapadas'] = resumen['atrapada'] * 100
    resumen.reset_index(inplace=True)

    # Ejecutar análisis de políticas C&T
    print("\n=== EJECUTANDO ANÁLISIS DE POLÍTICAS C&T ===")

    # 1. Análisis Regional por tipologías
    analisis_regional = modelo.analizar_politicas_cyt_regional(resultados)
    print("\n1. ÁMBITO REGIONAL POR TIPOLOGÍAS:")
    for region, datos in analisis_regional.items():
        print(f"  {region}:")
        print(f"    - Tipología predominante: {datos['tipologia_economica']}")
        print(f"    - Capacidad tecnológica: {datos['metricas_cyt']['capacidad_tecnologica_promedio']:.3f}")
        print(f"    - Tasa innovación promedio: {datos['metricas_cyt']['tasa_innovacion_promedio']:.4f}")
        print(f"    - Actualización tecnológica: {datos['metricas_cyt']['actualizacion_tecnologica_promedio']:.4f}")
        print(f"    - Innovaciones totales: {datos['metricas_cyt']['innovaciones_total']}")
        print(f"    - Diversidad sectorial: {datos['metricas_especializacion_diversificacion']['diversidad_sectorial_promedio']:.3f}")
        print(f"    - Especialización: {datos['metricas_especializacion_diversificacion']['especializacion_promedio']:.3f}")
        print(f"    - Empleo especializado: {datos['metricas_empleo']['empleo_especializado_promedio']:.1f}")
        print(f"    - Empleo total: {datos['metricas_empleo']['empleo_total_promedio']:.1f}")
        print(f"    - Brecha calificación: {datos['metricas_calificacion']['brecha_calificacion_promedio']:.3f}")
        print(f"    - Productividad promedio: {datos['metricas_productividad']['productividad_promedio']:.3f}")
        print(f"    - Productividad por innovación: {datos['metricas_productividad']['productividad_por_innovacion']:.2f}")
        print(f"    - Productividad tecnológica: {datos['metricas_productividad']['productividad_tecnologica']:.2f}")
        print(f"    - Eficiencia empleo productivo: {datos['metricas_productividad']['eficiencia_empleo_productivo']:.4f}")
        print(f"    - Índice productividad regional: {datos['metricas_productividad']['indice_productividad_regional']:.2f}")
        print(f"    - Regiones atrapadas: {datos['metricas_cyt']['porcentaje_atrapadas']:.1f}%")

    # 1.5. Análisis Geográfico por Regiones de México
    analisis_geografico = modelo.analizar_politicas_cyt_geografico(resultados)
    print("\n1.5. ÁMBITO GEOGRÁFICO POR REGIONES DE MÉXICO:")
    for region_geo, datos_geo in analisis_geografico.items():
        print(f"  {region_geo}:")
        print(f"    - Descripción: {datos_geo['informacion_regional']['descripcion']}")
        print(f"    - Desarrollo económico estimado: {datos_geo['caracteristicas_geograficas']['desarrollo_economico_geo']:.3f}")
        print(f"    - Cercanía frontera EE.UU.: {datos_geo['caracteristicas_geograficas']['cercania_frontera_eeuu']:.3f}")
        print(f"    - Riqueza natural: {datos_geo['caracteristicas_geograficas']['riqueza_natural']:.3f}")
        print(f"    - Factor aridez: {datos_geo['caracteristicas_geograficas']['factor_aridez']:.3f}")
        print(f"    - Rezago social estimado: {datos_geo['caracteristicas_geograficas']['rezago_social_estimado']:.3f}")
        print(f"    - Inversión extranjera estimada: {datos_geo['caracteristicas_geograficas']['inversion_extranjera_estimada']:.3f}")
        print(f"    - Capacidad tecnológica geográfica: {datos_geo['metricas_cyt_geograficas']['capacidad_tecnologica_geo']:.3f}")
        print(f"    - Tasa innovación geográfica: {datos_geo['metricas_cyt_geograficas']['tasa_innovacion_geo']:.4f}")
        print(f"    - Productividad geográfica: {datos_geo['metricas_productividad_geograficas']['productividad_regional_geo']:.3f}")
        print(f"    - Productividad por frontera: {datos_geo['metricas_productividad_geograficas']['productividad_por_frontera']:.3f}")
        print(f"    - Productividad por recursos: {datos_geo['metricas_productividad_geograficas']['productividad_por_recursos']:.3f}")
        print(f"    - Eficiencia geográfica: {datos_geo['metricas_productividad_geograficas']['eficiencia_geografica']:.4f}")
        print(f"    - Índice desarrollo geográfico: {datos_geo['metricas_productividad_geograficas']['indice_desarrollo_geografico']:.4f}")
        print(f"    - Especialización geográfica: {datos_geo['especializacion_diversificacion_geo']['especializacion_geo']:.3f}")
        print(f"    - Diversificación geográfica: {datos_geo['especializacion_diversificacion_geo']['diversificacion_geo']:.3f}")
        print(f"    - Sector predominante: {datos_geo['especializacion_diversificacion_geo']['sector_predominante']}")
        print(f"    - Empleos totales geográficos: {datos_geo['metricas_empleo_geograficas']['empleo_total_geo']:.1f}")
        print(f"    - Empleos especializados geográficos: {datos_geo['metricas_empleo_geograficas']['empleo_especializado_geo']:.1f}")
        print(f"    - Brecha calificación geográfica: {datos_geo['metricas_empleo_geograficas']['brecha_calificacion_geo']:.3f}")
        print(f"    - Fortalezas: {', '.join(datos_geo['fortalezas_geograficas'])}")
        print(f"    - Desafíos: {', '.join(datos_geo['desafios_geograficos'])}")

    # 2. Análisis Sectorial
    analisis_sectorial = modelo.analizar_politicas_cyt_sectorial(resultados)
    print("\n2. ÁMBITO SECTORIAL POR TIPOS:")
    for sector, datos in analisis_sectorial.items():
        print(f"  {sector}:")
        print(f"    - Regiones con sector: {datos['metricas_cyt']['regiones_con_sector']}")
        print(f"    - Innovaciones promedio: {datos['metricas_cyt']['innovaciones_promedio']:.2f}")
        print(f"    - Tasa innovación: {datos['metricas_cyt']['tasa_innovacion_promedio']:.4f}")
        print(f"    - Actualización tecnológica: {datos['metricas_cyt']['actualizacion_tecnologica_promedio']:.4f}")
        print(f"    - Grado especialización: {datos['especializacion_diversificacion']['grado_especializacion']:.3f}")
        print(f"    - Grado diversificación: {datos['especializacion_diversificacion']['grado_diversificacion']:.3f}")
        print(f"    - Empleo especializado: {datos['empleo_sectorial']['empleo_especializado_promedio']:.1f}")
        print(f"    - Empleo total: {datos['empleo_sectorial']['empleo_total_promedio']:.1f}")
        print(f"    - Brecha calificación: {datos['calificacion_trabajo']['brecha_calificacion_promedio']:.3f}")
        print(f"    - Productividad regional: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        print(f"    - Productividad por empleado: {datos['metricas_productividad']['productividad_por_empleado']:.4f}")
        print(f"    - Productividad por innovación: {datos['metricas_productividad']['productividad_por_innovacion']:.2f}")
        print(f"    - Eficiencia productiva sectorial: {datos['metricas_productividad']['eficiencia_productiva_sectorial']:.2f}")
        print(f"    - Índice competitividad sectorial: {datos['metricas_productividad']['indice_competitividad_sectorial']:.4f}")

    # 3. Análisis Corporativo por tipologías
    analisis_corporativo = modelo.analizar_politicas_cyt_corporativo(resultados)
    print("\n3. ÁMBITO CORPORATIVO POR TIPOLOGÍAS:")
    print("\nPOR TAMAÑO CORPORATIVO:")
    for region, datos in analisis_corporativo['por_tamaño_corporativo'].items():
        print(f"  {region}:")
        print(f"    - Corporaciones grandes: {datos['corporaciones_grandes']}")
        print(f"    - Corporaciones pequeñas: {datos['corporaciones_pequeñas']}")
        print(f"    - Ratio G/P: {datos['ratio_grandes_pequenas']:.2f}")
        print(f"    - Innovaciones grandes: {datos['innovaciones_grandes']:.1f}")
        print(f"    - Innovaciones pequeñas: {datos['innovaciones_pequeñas']:.1f}")
        print(f"    - Empleo especializado regional: {datos['empleo_especializado_regional']:.1f}")
        print(f"    - Productividad regional promedio: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        print(f"    - Productividad por empleado grande: {datos['metricas_productividad']['productividad_por_empleado_grande']:.4f}")
        print(f"    - Eficiencia productiva grandes: {datos['metricas_productividad']['eficiencia_productiva_grandes']:.2f}")
        print(f"    - Índice competitividad corporativo: {datos['metricas_productividad']['indice_competitividad_corporativo']:.4f}")

    print("\nPOR NIVEL TECNOLÓGICO:")
    for nivel, datos in analisis_corporativo['por_tecnologia'].items():
        print(f"  {nivel}:")
        print(f"    - Regiones con tecnología: {datos['regiones_con_tecnologia']}")
        print(f"    - Tasa innovación promedio: {datos['tasa_innovacion_promedio']:.4f}")
        print(f"    - Actualización tecnológica: {datos['actualizacion_tecnologica_promedio']:.4f}")
        print(f"    - Tasa atrapamiento: {datos['tasa_atrapamiento']:.1f}%")
        print(f"    - Empleo especializado: {datos['empleo_especializado']:.1f}")
        print(f"    - Productividad regional: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        print(f"    - Productividad por innovación: {datos['metricas_productividad']['productividad_por_innovacion']:.2f}")
        print(f"    - Productividad tecnológica: {datos['metricas_productividad']['productividad_tecnologica']:.2f}")
        print(f"    - Eficiencia productiva: {datos['metricas_productividad']['eficiencia_productiva']:.2f}")
        print(f"    - Índice conversión innovación: {datos['metricas_productividad']['indice_conversion_innovacion']:.4f}")

    print("\nPOR NIVEL DE ESPECIALIZACIÓN:")
    for nivel, datos in analisis_corporativo['por_especializacion'].items():
        print(f"  {nivel}:")
        print(f"    - Regiones: {datos.get('regiones_con_alta_esp', datos.get('regiones_con_baja_esp', 'N/A'))}")
        print(f"    - Diversidad promedio: {datos['diversidad_promedio']:.3f}")
        print(f"    - Innovaciones promedio: {datos['innovaciones_promedio']:.2f}")
        print(f"    - Empleo especializado ratio: {datos['empleo_especializado_ratio']:.3f}")
        print(f"    - Productividad promedio: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        if 'Alta' in nivel:
            print(f"    - Productividad especializada: {datos['metricas_productividad']['productividad_especializada']:.3f}")
            print(f"    - Eficiencia especialización: {datos['metricas_productividad']['eficiencia_especializacion_productiva']:.2f}")
            print(f"    - Índice ventaja competitiva: {datos['metricas_productividad']['indice_ventaja_competitiva']:.4f}")
        else:
            print(f"    - Productividad diversificada: {datos['metricas_productividad']['productividad_diversificada']:.3f}")
            print(f"    - Eficiencia diversificación: {datos['metricas_productividad']['eficiencia_diversificacion_productiva']:.2f}")
            print(f"    - Índice flexibilidad productiva: {datos['metricas_productividad']['indice_flexibilidad_productiva']:.4f}")

    print("\nPOR BRECHA DE CALIFICACIÓN:")
    for nivel, datos in analisis_corporativo['por_calificacion'].items():
        print(f"  {nivel}:")
        print(f"    - Regiones: {datos.get('regiones_con_baja_brecha', datos.get('regiones_con_alta_brecha', 'N/A'))}")
        print(f"    - Brecha calificación promedio: {datos['brecha_calificacion_promedio']:.3f}")
        print(f"    - Innovaciones promedio: {datos['innovaciones_promedio']:.2f}")
        print(f"    - Eficiencia asignación: {datos['eficiencia_asignacion']:.3f}")
        print(f"    - Productividad promedio: {datos['metricas_productividad']['productividad_regional_promedio']:.3f}")
        print(f"    - Eficiencia capital humano: {datos['metricas_productividad']['eficiencia_capital_humano']:.3f}")
        print(f"    - Productividad por innovación: {datos['metricas_productividad']['productividad_innovacion_capacidades']:.2f}")
        print(f"    - Índice efectividad capital humano: {datos['metricas_productividad']['indice_efectividad_capital_humano']:.4f}")

    print("\n=== RESULTADOS DE LA SIMULACIÓN ===")
    print(f"Simulación completada con {len(resultados)} registros")
    print(f"Pasos ejecutados: {resultados['paso_tiempo'].max()}")
    print(f"Regiones simuladas: {len(modelo.regiones)}")

    # Mostrar distribución de tipologías iniciales
    distribucion_tipologias = resultados.groupby('tipo_region_economica_inicial').size()
    print("\n=== DISTRIBUCIÓN DE TIPOLOGÍAS REGIONALES INICIALES ===")
    for tipologia, cantidad in distribucion_tipologias.items():
        print(f"{tipologia}: {cantidad} registros ({cantidad/len(resultados)*100:.1f}%)")

    # Mostrar comparación de tipologías con todas las métricas
    print("\n=== COMPARACIÓN COMPLETA DE TIPOLOGÍAS ===")
    comparacion_tipologias = resultados.groupby('tipo_region_economica_inicial').agg({
        'capacidad_tecnologica': 'mean',
        'innovaciones_realizadas': 'mean',
        'tasa_innovacion': 'mean',
        'actualizacion_tecnologica': 'mean',
        'diversidad_sectorial': 'mean',
        'especializacion': 'mean',
        'productividad_promedio': 'mean',
        'atrapada': 'mean',
        'empleo_especializado': 'mean',
        'empleo_total': 'mean',
        'brecha_calificacion': 'mean',
        'coordinacion_promedio': 'mean'
    }).round(4)

    print(comparacion_tipologias)

    # =====================================================
    # EVALUACIÓN DINÁMICA DE TIPOLOGÍAS
    # =====================================================
    print("\n=== EVALUACIÓN DINÁMICA DE TIPOLOGÍAS ===")
    print("Analizando evolución basada en características sectoriales y regionales reales...")

    # Evaluar dinámicamente el estado de todas las regiones
    resultados_con_evaluacion = EvaluacionDinamica.evaluar_evolucion_dinamica(resultados)

    # Mostrar distribución inicial vs dinámica
    print("\n1. DISTRIBUCIÓN INICIAL:")
    distribucion_inicial = resultados_con_evaluacion.groupby('tipo_region_economica_inicial').size()
    for tipologia, cantidad in distribucion_inicial.items():
        print(f"  {tipologia}: {cantidad} registros ({cantidad/len(resultados_con_evaluacion)*100:.1f}%)")

    print("\n2. DISTRIBUCIÓN DINÁMICA (por características reales):")
    distribucion_dinamica = resultados_con_evaluacion.groupby('estado_dinamico').size()
    for estado, cantidad in distribucion_dinamica.items():
        print(f"  {estado}: {cantidad} registros ({cantidad/len(resultados_con_evaluacion)*100:.1f}%)")

    print("\n3. ANÁLISIS DE EVOLUCIÓN:")
    evolucion = pd.crosstab(
        resultados_con_evaluacion['tipo_region_economica_inicial'],
        resultados_con_evaluacion['estado_dinamico'],
        margins=True
    )
    print(evolucion)

    print("\n4. ESTADÍSTICAS DE PROPENSIÓN A ATRAPPADA:")
    propension_stats = resultados_con_evaluacion.groupby('estado_dinamico')['propension_atrappada'].agg(['mean', 'std', 'min', 'max']).round(4)
    print(propension_stats)

    print("\n5. MÉTRICAS POR ESTADO DINÁMICO:")
    metricas_dinamicas = resultados_con_evaluacion.groupby('estado_dinamico').agg({
        'capacidad_tecnologica': 'mean',
        'innovaciones_realizadas': 'mean',
        'tasa_innovacion': 'mean',
        'diversidad_sectorial': 'mean',
        'especializacion': 'mean',
        'productividad_promedio': 'mean',
        'brecha_calificacion': 'mean',
        'propension_atrappada': 'mean'
    }).round(4)
    print(metricas_dinamicas)

    # Agregar análisis por paso temporal
    print("\n6. EVOLUCIÓN TEMPORAL DE LA EVALUACIÓN DINÁMICA:")
    evolucion_temporal = resultados_con_evaluacion.groupby(['paso_tiempo', 'estado_dinamico']).size().unstack(fill_value=0)
    if 'Atrapada' in evolucion_temporal.columns:
        # Calcular el total sumando solo las columnas que existen
        columnas_existentes = [col for col in ['Atrapada', 'No_Atrapada', 'En_transicion'] if col in evolucion_temporal.columns]
        evolucion_temporal['porcentaje_atrapadas'] = (evolucion_temporal['Atrapada'] /
                                                    evolucion_temporal[columnas_existentes].sum(axis=1) * 100).round(2)
    print(evolucion_temporal)

    # Actualizar resultados para usar en análisis posteriores
    resultados = resultados_con_evaluacion
    resumen['porcentaje_atrapadas_dinamicas'] = (resultados['estado_dinamico'] == 'Atrapada').mean() * 100

    return modelo, resultados, resumen

def crear_visualizaciones_optimizadas_por_clase(resultados: pd.DataFrame, save_path: str):
    """
    Función optimizada de graficado que incluye:
    1. Análisis por clase (tipologías regionales)
    2. Análisis por categorías regionales
    3. Evolución temporal del modelo
    4. Persistencia de la trampa de innovación
    5. Análisis sectoriales y geográficos
    """
    # Inicializar matplotlib con configuración optimizada
    setup_matplotlib_for_plotting()

    # Optimización: Pre-calcular estadísticas para evitar cálculos repetitivos
    estadisticas_precalculadas = {
        'total_regiones': resultados['id_region'].nunique(),
        'total_pasos': resultados['paso_tiempo'].nunique(),
        'tipologias_unicas': resultados['tipo_region_economica_inicial'].unique().tolist(),
        'variables_principales': ['capacidad_tecnologica', 'tasa_innovacion', 'empleo_total', 'productividad_promedio']
    }

    print(f"✓ Optimizaciones aplicadas: {estadisticas_precalculadas['total_regiones']} regiones, {estadisticas_precalculadas['total_pasos']} pasos")

    # Definir paletas de colores optimizadas
    colores_tipologia = {
        'Atrapada': '#E74C3C',          # Rojo para regiones en trampa
        'No_Atrapada': '#27AE60',       # Verde para regiones dinámicas
        'En_transicion': '#F39C12'      # Naranja para regiones en transición
    }

    colores_regionales = {
        'NOROESTE': '#3498DB', 'NORESTE': '#9B59B6', 'OCCIDENTE': '#E67E22',
        'CENTRONORTE': '#1ABC9C', 'ORIENTE': '#F1C40F', 'SUROESTE': '#E74C3C',
        'SURESTE': '#95A5A6'
    }

    print("\n=== GENERANDO VISUALIZACIONES OPTIMIZADAS POR CLASE ===")

    # =============================================
    # 1. ANÁLISIS COMPARATIVO POR TIPOLOGÍAS REGIONALES
    # =============================================

    fig, axes = plt.subplots(2, 3, figsize=(20, 14))  # Tamaño optimizado
    # Título principal más corto para evitar solapamiento
    fig.suptitle('Análisis por tipologías: Capacidades y desempeño',
                fontsize=16, fontweight='bold', y=0.96)

    # Variables principales a comparar
    variables_principales = [
        ('capacidad_tecnologica', 'Capacidad tecnológica'),
        ('tasa_innovacion', 'Tasa de innovación'),
        ('diversidad_sectorial', 'Diversidad sectorial'),
        ('especializacion', 'Especialización'),
        ('productividad_promedio', 'Productividad promedio'),
        ('brecha_calificacion', 'Brecha de calificación')
    ]

    # Preparar datos por tipología
    datos_tipologia = resultados.groupby('tipo_region_economica_inicial').agg({
        var: ['mean', 'std', 'count'] for var, _ in variables_principales
    }).round(4)

    # Aplanar nombres de columnas
    datos_tipologia.columns = ['_'.join(col).strip() for col in datos_tipologia.columns.values]

    for idx, (variable, titulo) in enumerate(variables_principales):
        row = idx // 3
        col = idx % 3
        ax = axes[row, col]

        # Obtener datos y errores
        media_col = f'{variable}_mean'
        std_col = f'{variable}_std'
        count_col = f'{variable}_count'

        if media_col in datos_tipologia.columns:
            medias = datos_tipologia[media_col]
            stds = datos_tipologia[std_col] if std_col in datos_tipologia.columns else 0
            counts = datos_tipologia[count_col]

            # Crear barras con errores
            bars = ax.bar(medias.index, medias.values,
                         yerr=stds.values, capsize=5,
                         color=[colores_tipologia.get(tipo, '#95A5A6') for tipo in medias.index],
                         alpha=0.8, edgecolor='black', linewidth=1)

            # Añadir valores y conteos: Métricas mejoradas
            for i, (bar, media, std, count) in enumerate(zip(bars, medias.values, stds.values, counts.values)):
                height = bar.get_height()
                # Título optimizado para evitar solapamiento
                ax.text(bar.get_x() + bar.get_width()/2., height + std + height*0.01,
                       f'{media:.3f}', ha='center', va='bottom', fontweight='bold', fontsize=9)
                ax.text(bar.get_x() + bar.get_width()/2., -std*0.1,
                       f'n={int(count)}', ha='center', va='top', fontsize=7, style='italic')

        # Títulos más cortos para evitar solapamiento
        titulo_corto = titulo.replace(' de ', '\nde ').replace(' y ', '\ny ')
        ax.set_title(titulo_corto, fontweight='bold', fontsize=11)
        ax.set_ylabel('Valor', fontsize=10)
        ax.tick_params(axis='x', rotation=0, labelsize=8)  # Rotación optimizada
        ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '01_analisis_comparativo_tipologias.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 2. EVOLUCIÓN TEMPORAL DEL MODELO
    # =============================================

    fig, axes = plt.subplots(2, 2, figsize=(20, 16))
    fig.suptitle('Evolución temporal del modelo económico regional',
                fontsize=18, fontweight='bold', y=0.95)

    # Calcular promedios temporales por tipología
    evolucion_temporal = resultados.groupby(['paso_tiempo', 'tipo_region_economica_inicial']).agg({
        'capacidad_tecnologica': 'mean',
        'tasa_innovacion': 'mean',
        'productividad_promedio': 'mean',
        'empleo_total': 'sum'
    }).reset_index()

    # Panel 1: Evolución de capacidad tecnológica
    ax1 = axes[0, 0]
    for tipologia in evolucion_temporal['tipo_region_economica_inicial'].unique():
        datos_tip = evolucion_temporal[evolucion_temporal['tipo_region_economica_inicial'] == tipologia]
        ax1.plot(datos_tip['paso_tiempo'], datos_tip['capacidad_tecnologica'],
                marker='o', linewidth=3, markersize=6, label=tipologia,
                color=colores_tipologia.get(tipologia, '#95A5A6'))

    ax1.set_title('Evolución de capacidad tecnológica', fontweight='bold', fontsize=14)
    ax1.set_xlabel('Paso de tiempo', fontsize=12)
    ax1.set_ylabel('Capacidad tecnológica', fontsize=12)
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Panel 2: Evolución de tasa de innovación
    ax2 = axes[0, 1]
    for tipologia in evolucion_temporal['tipo_region_economica_inicial'].unique():
        datos_tip = evolucion_temporal[evolucion_temporal['tipo_region_economica_inicial'] == tipologia]
        ax2.plot(datos_tip['paso_tiempo'], datos_tip['tasa_innovacion'],
                marker='s', linewidth=3, markersize=6, label=tipologia,
                color=colores_tipologia.get(tipologia, '#95A5A6'))

    ax2.set_title('Evolución de tasa de innovación', fontweight='bold', fontsize=14)
    ax2.set_xlabel('Paso de tiempo', fontsize=12)
    ax2.set_ylabel('Tasa de innovación', fontsize=12)
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    # Panel 3: Evolución de productividad
    ax3 = axes[1, 0]
    for tipologia in evolucion_temporal['tipo_region_economica_inicial'].unique():
        datos_tip = evolucion_temporal[evolucion_temporal['tipo_region_economica_inicial'] == tipologia]
        ax3.plot(datos_tip['paso_tiempo'], datos_tip['productividad_promedio'],
                marker='^', linewidth=3, markersize=6, label=tipologia,
                color=colores_tipologia.get(tipologia, '#95A5A6'))

    ax3.set_title('Evolución de productividad promedio', fontweight='bold', fontsize=14)
    ax3.set_xlabel('Paso de tiempo', fontsize=12)
    ax3.set_ylabel('Productividad', fontsize=12)
    ax3.legend()
    ax3.grid(True, alpha=0.3)

    # Panel 4: Evolución del empleo total
    ax4 = axes[1, 1]
    for tipologia in evolucion_temporal['tipo_region_economica_inicial'].unique():
        datos_tip = evolucion_temporal[evolucion_temporal['tipo_region_economica_inicial'] == tipologia]
        ax4.plot(datos_tip['paso_tiempo'], datos_tip['empleo_total'],
                marker='D', linewidth=3, markersize=6, label=tipologia,
                color=colores_tipologia.get(tipologia, '#95A5A6'))

    ax4.set_title('Evolución del empleo total', fontweight='bold', fontsize=14)
    ax4.set_xlabel('Paso de tiempo', fontsize=12)
    ax4.set_ylabel('Empleo total', fontsize=12)
    ax4.legend()
    ax4.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '02_evolucion_temporal_modelo.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 3. ANÁLISIS DE LA TRAMPA DE INNOVACIÓN
    # =============================================

    fig, axes = plt.subplots(2, 2, figsize=(20, 16))
    fig.suptitle('Análisis de persistencia de la trampa de innovación',
                fontsize=18, fontweight='bold', y=0.95)

    # Panel 1: Distribución de regiones en trampa
    trap_analysis = resultados.groupby('id_region').agg({
        'capacidad_tecnologica': ['mean', 'std'],
        'tasa_innovacion': ['mean', 'std'],
        'diversidad_sectorial': ['mean', 'std'],
        'especializacion': ['mean', 'std'],
        'brecha_calificacion': ['mean', 'std'],
        'tipo_region_economica_inicial': 'first'
    })

    # Aplanar columnas
    trap_analysis.columns = ['_'.join(col).strip() for col in trap_analysis.columns.values]

    # Calcular índice de trampa
    trap_analysis['indice_trampa'] = (
        0.3 * (1 - trap_analysis['capacidad_tecnologica_mean']) +
        0.25 * (1 - trap_analysis['tasa_innovacion_mean']) +
        0.25 * trap_analysis['especializacion_mean'] +
        0.2 * trap_analysis['brecha_calificacion_mean']
    )

    # Clasificar regiones
    trap_analysis['clasificacion_trampa'] = trap_analysis['indice_trampa'].apply(
        lambda x: 'Trampa severa' if x > 0.7 else 'Trampa moderada' if x > 0.4 else 'No trampa'
    )

    # Distribución de trampa por tipología
    trap_by_type = trap_analysis.groupby(['tipo_region_economica_inicial_first', 'clasificacion_trampa']).size().unstack(fill_value=0)

    if not trap_by_type.empty:
        trap_by_type.plot(kind='bar', ax=axes[0,0], color=['#27AE60', '#F39C12', '#E74C3C'])
        axes[0,0].set_title('Distribución de trampa de innovación por tipología', fontweight='bold')
        axes[0,0].set_xlabel('Tipología regional', fontsize=12)
        axes[0,0].set_ylabel('Número de regiones', fontsize=12)
        axes[0,0].tick_params(axis='x', rotation=45)
        axes[0,0].legend(title='Nivel de trampa')

    # Panel 2: Correlaciones en la trampa
    vars_trampa = ['capacidad_tecnologica_mean', 'tasa_innovacion_mean',
                   'diversidad_sectorial_mean', 'especializacion_mean', 'indice_trampa']
    corr_trampa = trap_analysis[vars_trampa].corr()

    im = axes[0,1].imshow(corr_trampa, cmap='RdBu_r', aspect='auto', vmin=-1, vmax=1)
    axes[0,1].set_xticks(range(len(vars_trampa)))
    axes[0,1].set_yticks(range(len(vars_trampa)))
    axes[0,1].set_xticklabels([var.replace('_mean', '').replace('_', '\n') for var in vars_trampa],
                             rotation=45, ha='right')
    axes[0,1].set_yticklabels([var.replace('_mean', '').replace('_', '\n') for var in vars_trampa])
    axes[0,1].set_title('Correlaciones en la trampa de innovación', fontweight='bold')

    # Añadir valores de correlación
    for i in range(len(vars_trampa)):
        for j in range(len(vars_trampa)):
            text = axes[0,1].text(j, i, f'{corr_trampa.iloc[i, j]:.2f}',
                                ha="center", va="center", color="black", fontweight='bold')

    plt.colorbar(im, ax=axes[0,1], shrink=0.8)

    # Panel 3: Persistencia temporal de la trampa
    trap_temporal = resultados.groupby(['paso_tiempo', 'tipo_region_economica_inicial']).agg({
        'capacidad_tecnologica': lambda x: (x < x.quantile(0.25)).mean(),  # % en baja capacidad
        'tasa_innovacion': lambda x: (x < x.quantile(0.25)).mean(),       # % en baja innovación
    }).reset_index()

    ax3 = axes[1, 0]
    for tipologia in trap_temporal['tipo_region_economica_inicial'].unique():
        datos_tip = trap_temporal[trap_temporal['tipo_region_economica_inicial'] == tipologia]
        ax3.plot(datos_tip['paso_tiempo'], datos_tip['capacidad_tecnologica'],
                marker='o', linewidth=2, label=f'{tipologia} (Tech)',
                color=colores_tipologia.get(tipologia, '#95A5A6'))
        ax3.plot(datos_tip['paso_tiempo'], datos_tip['tasa_innovacion'],
                marker='s', linewidth=2, linestyle='--', label=f'{tipologia} (Innov)',
                color=colores_tipologia.get(tipologia, '#95A5A6'))

    ax3.set_title('Persistencia temporal de la trampa', fontweight='bold')
    ax3.set_xlabel('Paso de tiempo', fontsize=12)
    ax3.set_ylabel('Proporción en trampa', fontsize=12)
    ax3.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    ax3.grid(True, alpha=0.3)

    # Panel 4: Factores de escape de la trampa
    escape_analysis = trap_analysis.copy()
    escape_analysis['factor_escape'] = (
        escape_analysis['diversidad_sectorial_mean'] -
        escape_analysis['especializacion_mean']
    )

    for tipologia in escape_analysis['tipo_region_economica_inicial_first'].unique():
        datos_tip = escape_analysis[escape_analysis['tipo_region_economica_inicial_first'] == tipologia]
        axes[1,1].scatter(datos_tip['indice_trampa'], datos_tip['factor_escape'],
                         label=tipologia, alpha=0.7, s=100,
                         color=colores_tipologia.get(tipologia, '#95A5A6'))

    axes[1,1].set_title('Factores de escape de la trampa', fontweight='bold')
    axes[1,1].set_xlabel('Índice de trampa', fontsize=12)
    axes[1,1].set_ylabel('Factor de escape (Diversidad - Especialización)', fontsize=12)
    axes[1,1].legend()
    axes[1,1].grid(True, alpha=0.3)

    # Línea de referencia para escape
    axes[1,1].axhline(y=0, color='red', linestyle='--', alpha=0.7, label='Umbral Escape')

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '03_analisis_trampa_innovacion.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 4. ANÁLISIS GEOGRÁFICO Y REGIONAL
    # =============================================

    if 'tipo_region' in resultados.columns:
        fig, axes = plt.subplots(2, 2, figsize=(20, 16))
        fig.suptitle('Análisis por categorías regionales y geográficas',
                    fontsize=18, fontweight='bold', y=0.95)

        # Panel 1: Desempeño por región geográfica
        geo_performance = resultados.groupby('tipo_region').agg({
            'capacidad_tecnologica': 'mean',
            'tasa_innovacion': 'mean',
            'productividad_promedio': 'mean'
        }).round(4)

        x_pos = np.arange(len(geo_performance.index))
        width = 0.25

        axes[0,0].bar(x_pos - width, geo_performance['capacidad_tecnologica'], width,
                     label='Cap. tecnológica', alpha=0.8)
        axes[0,0].bar(x_pos, geo_performance['tasa_innovacion'] * 10, width,
                     label='Tasa innov. (x10)', alpha=0.8)
        axes[0,0].bar(x_pos + width, geo_performance['productividad_promedio'] / 10, width,
                     label='Productividad (/10)', alpha=0.8)

        axes[0,0].set_title('Desempeño por región geográfica', fontweight='bold')
        axes[0,0].set_xlabel('Región geográfica', fontsize=12)
        axes[0,0].set_ylabel('Indicadores normalizados', fontsize=12)
        axes[0,0].set_xticks(x_pos)
        axes[0,0].set_xticklabels(geo_performance.index, rotation=45)
        axes[0,0].legend()
        axes[0,0].grid(True, alpha=0.3)

        # Panel 2: Concentración de innovación
        innov_concentration = resultados.groupby('tipo_region')['tasa_innovacion'].agg(['mean', 'std', 'count'])

        axes[0,1].errorbar(range(len(innov_concentration)), innov_concentration['mean'],
                          yerr=innov_concentration['std'], fmt='o-', capsize=5, linewidth=2)
        axes[0,1].set_title('Concentración de innovación por región', fontweight='bold')
        axes[0,1].set_xlabel('Región geográfica', fontsize=12)
        axes[0,1].set_ylabel('Tasa de innovación (Media ± Desv)', fontsize=12)
        axes[0,1].set_xticks(range(len(innov_concentration)))
        axes[0,1].set_xticklabels(innov_concentration.index, rotation=45)
        axes[0,1].grid(True, alpha=0.3)

        # Panel 3: Diversificación vs especialización regional
        div_spec_analysis = resultados.groupby(['tipo_region', 'tipo_region_economica_inicial']).agg({
            'diversidad_sectorial': 'mean',
            'especializacion': 'mean'
        }).reset_index()

        for tipologia in div_spec_analysis['tipo_region_economica_inicial'].unique():
            datos_tip = div_spec_analysis[div_spec_analysis['tipo_region_economica_inicial'] == tipologia]
            axes[1,0].scatter(datos_tip['diversidad_sectorial'], datos_tip['especializacion'],
                             label=tipologia, alpha=0.7, s=100,
                             color=colores_tipologia.get(tipologia, '#95A5A6'))

        axes[1,0].set_title('Diversificación vs Especialización regional', fontweight='bold')
        axes[1,0].set_xlabel('Diversidad Sectorial', fontsize=12)
        axes[1,0].set_ylabel('Especialización', fontsize=12)
        axes[1,0].legend()
        axes[1,0].grid(True, alpha=0.3)

        # Panel 4: Brecha tecnológica regional
        tech_gap = resultados.groupby('tipo_region')['capacidad_tecnologica'].agg(['min', 'max', 'mean', 'std'])

        axes[1,1].fill_between(range(len(tech_gap)),
                              tech_gap['mean'] - tech_gap['std'],
                              tech_gap['mean'] + tech_gap['std'],
                              alpha=0.3, color='skyblue', label='±1 Desv')
        axes[1,1].plot(range(len(tech_gap)), tech_gap['mean'], 'o-', linewidth=2,
                      markersize=8, color='navy', label='Media')
        axes[1,1].plot(range(len(tech_gap)), tech_gap['min'], 's--', alpha=0.7,
                      label='Mínimo', color='red')
        axes[1,1].plot(range(len(tech_gap)), tech_gap['max'], '^--', alpha=0.7,
                      label='Máximo', color='green')

        axes[1,1].set_title('Brecha tecnológica regional', fontweight='bold')
        axes[1,1].set_xlabel('Región geográfica', fontsize=12)
        axes[1,1].set_ylabel('Capacidad tecnológica', fontsize=12)
        axes[1,1].set_xticks(range(len(tech_gap)))
        axes[1,1].set_xticklabels(tech_gap.index, rotation=45)
        axes[1,1].legend()
        axes[1,1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.savefig(os.path.join(save_path, '04_analisis_geografico_regional.png'),
                    dpi=300, bbox_inches='tight')
        plt.close()

    # =============================================
    # 5. DASHBOARD INTEGRAL DE INDICADORES
    # =============================================

    fig = plt.figure(figsize=(24, 16))
    gs = fig.add_gridspec(3, 4, hspace=0.3, wspace=0.3)

    fig.suptitle('Dashboard integral: Indicadores clave del modelo económico regional',
                fontsize=20, fontweight='bold', y=0.95)

    # KPIs principales por tipología
    kpis_tipologia = resultados.groupby('tipo_region_economica_inicial').agg({
        'capacidad_tecnologica': ['mean', 'std'],
        'tasa_innovacion': ['mean', 'std'],
        'productividad_promedio': ['mean', 'std'],
        'empleo_total': ['sum', 'mean']
    }).round(4)

    # KPIs generales del sistema
    kpis_sistema = {
        'Total regiones': len(resultados['id_region'].unique()),
        'Cap.tech promedio': f"{resultados['capacidad_tecnologica'].mean():.3f}",
        'Tasa innov. promedio': f"{resultados['tasa_innovacion'].mean():.3f}",
        'Productividad promedio': f"{resultados['productividad_promedio'].mean():.1f}",
        'Regiones atrapadas': len(resultados[resultados['tipo_region_economica_inicial'] == 'Atrapada']['id_region'].unique()),
        'Regiones no atrapadas': len(resultados[resultados['tipo_region_economica_inicial'] == 'No_Atrapada']['id_region'].unique()),
        'Pasos simulación': len(resultados['paso_tiempo'].unique())
    }

    # Panel de KPIs (parte superior)
    ax_kpi = fig.add_subplot(gs[0, :])
    ax_kpi.axis('off')

    kpi_text = "SISTEMA ECONÓMICO REGIONAL - INDICADORES CLAVE\n\n"
    for key, value in kpis_sistema.items():
        kpi_text += f"• {key}: {value}   "

    ax_kpi.text(0.5, 0.5, kpi_text, transform=ax_kpi.transAxes, fontsize=14,
               ha='center', va='center',
               bbox=dict(boxstyle='round,pad=0.5', facecolor='lightblue', alpha=0.7))

    # Gráfico de radar para tipologías (panel medio-izquierda)
    ax_radar = fig.add_subplot(gs[1, 0], projection='polar')

    # Preparar datos para radar chart
    categorias = ['Cap.Tech', 'Innovación', 'Productividad', 'Empleo']
    angulos = np.linspace(0, 2 * np.pi, len(categorias), endpoint=False)

    for tipologia in kpis_tipologia.index:
        valores = [
            kpis_tipologia.loc[tipologia, ('capacidad_tecnologica', 'mean')],
            kpis_tipologia.loc[tipologia, ('tasa_innovacion', 'mean')] * 10,  # Escalar
            kpis_tipologia.loc[tipologia, ('productividad_promedio', 'mean')] / 10,  # Escalar
            kpis_tipologia.loc[tipologia, ('empleo_total', 'mean')] / 1000  # Escalar
        ]
        valores += valores[:1]  # Cerrar el polígono
        angulos_plot = np.concatenate((angulos, [angulos[0]]))

        ax_radar.plot(angulos_plot, valores, 'o-', linewidth=2,
                     label=tipologia, color=colores_tipologia.get(tipologia, '#95A5A6'))
        ax_radar.fill(angulos_plot, valores, alpha=0.25,
                     color=colores_tipologia.get(tipologia, '#95A5A6'))

    ax_radar.set_xticks(angulos)
    ax_radar.set_xticklabels(categorias)
    ax_radar.set_title('Perfil por tipología regional', fontweight='bold', pad=20)
    ax_radar.legend(loc='upper right', bbox_to_anchor=(1.3, 1.0))

    # Heatmap de correlaciones generales (panel medio-centro)
    ax_corr = fig.add_subplot(gs[1, 1:3])

    vars_generales = ['capacidad_tecnologica', 'tasa_innovacion', 'productividad_promedio',
                     'empleo_total', 'diversidad_sectorial', 'especializacion']
    corr_generales = resultados[vars_generales].corr()

    im = ax_corr.imshow(corr_generales, cmap='RdBu_r', aspect='auto', vmin=-1, vmax=1)
    ax_corr.set_xticks(range(len(vars_generales)))
    ax_corr.set_yticks(range(len(vars_generales)))
    ax_corr.set_xticklabels([var.replace('_', '\n') for var in vars_generales], rotation=45, ha='right')
    ax_corr.set_yticklabels([var.replace('_', '\n') for var in vars_generales])
    ax_corr.set_title('Matriz de correlaciones generales', fontweight='bold')

    for i in range(len(vars_generales)):
        for j in range(len(vars_generales)):
            text = ax_corr.text(j, i, f'{corr_generales.iloc[i, j]:.2f}',
                              ha="center", va="center", color="black", fontweight='bold')

    plt.colorbar(im, ax=ax_corr, shrink=0.8)

    # Distribución de la trampa (panel medio-derecha)
    ax_trap = fig.add_subplot(gs[1, 3])

    # Calcular índice de trampa para todas las regiones
    trap_dist = trap_analysis['indice_trampa']
    trap_classes = ['No trampa\n(<0.4)', 'Trampa moderada\n(0.4-0.7)', 'Trampa severa\n(>0.7)']
    trap_counts = [
        (trap_dist < 0.4).sum(),
        ((trap_dist >= 0.4) & (trap_dist < 0.7)).sum(),
        (trap_dist >= 0.7).sum()
    ]

    colors_trap = ['#27AE60', '#F39C12', '#E74C3C']
    wedges, texts, autotexts = ax_trap.pie(trap_counts, labels=trap_classes, autopct='%1.1f%%',
                                          colors=colors_trap, startangle=90)
    ax_trap.set_title('Distribución de la\ntrampa de innovación', fontweight='bold')

    # Evolución temporal agregada (panel inferior)
    ax_temp = fig.add_subplot(gs[2, :])

    evolucion_agregada = resultados.groupby('paso_tiempo').agg({
        'capacidad_tecnologica': 'mean',
        'tasa_innovacion': 'mean',
        'productividad_promedio': 'mean'
    })

    ax_temp_twin = ax_temp.twinx()

    line1 = ax_temp.plot(evolucion_agregada.index, evolucion_agregada['capacidad_tecnologica'],
                        'b-o', linewidth=3, label='Capacidad tecnológica')
    line2 = ax_temp.plot(evolucion_agregada.index, evolucion_agregada['tasa_innovacion'],
                        'g-s', linewidth=3, label='Tasa de innovación')
    line3 = ax_temp_twin.plot(evolucion_agregada.index, evolucion_agregada['productividad_promedio'],
                             'r-^', linewidth=3, label='Productividad')

    ax_temp.set_xlabel('Paso de tiempo', fontsize=12)
    ax_temp.set_ylabel('Cap. tec / Tasa innov.', fontsize=12, color='black')
    ax_temp_twin.set_ylabel('Productividad', fontsize=12, color='red')
    ax_temp.set_title('Evolución temporal agregada del sistema', fontweight='bold', fontsize=14)

    # Combinar leyendas
    lines = line1 + line2 + line3
    labels = [l.get_label() for l in lines]
    ax_temp.legend(lines, labels, loc='center left')
    ax_temp.grid(True, alpha=0.3)

    plt.savefig(os.path.join(save_path, '05_dashboard_integral_indicadores.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 6. GENERAR RESUMEN ESTADÍSTICO
    # =============================================

    # Crear DataFrame resumen optimizado
    resumen_optimizado = {
        'Metrica': [],
        'Atrapada_Media': [], 'Atrapada_Std': [], 'Atrapada_Count': [],
        'No_Atrapada_Media': [], 'No_Atrapada_Std': [], 'No_Atrapada_Count': [],
        'Diferencia_Pct': [], 'Significancia': []
    }

    metricas_principales = [
        ('capacidad_tecnologica', 'Capacidad tecnológica'),
        ('tasa_innovacion', 'Tasa de innovación'),
        ('diversidad_sectorial', 'Diversidad sectorial'),
        ('especializacion', 'Especialización'),
        ('productividad_promedio', 'Productividad promedio'),
        ('brecha_calificacion', 'Brecha de calificación'),
        ('empleo_total', 'Empleo total')
    ]

    for variable, nombre in metricas_principales:
        datos_atrapada = resultados[resultados['tipo_region_economica_inicial'] == 'Atrapada'][variable].dropna()
        datos_no_atrapada = resultados[resultados['tipo_region_economica_inicial'] == 'No_Atrapada'][variable].dropna()

        if not datos_atrapada.empty and not datos_no_atrapada.empty:
            media_atrapada = datos_atrapada.mean()
            std_atrapada = datos_atrapada.std()
            count_atrapada = len(datos_atrapada)

            media_no_atrapada = datos_no_atrapada.mean()
            std_no_atrapada = datos_no_atrapada.std()
            count_no_atrapada = len(datos_no_atrapada)

            diferencia_pct = ((media_no_atrapada - media_atrapada) / media_atrapada * 100) if media_atrapada > 0 else 0

            # Test t-simple para significancia
            from scipy.stats import ttest_ind
            t_stat, p_value = ttest_ind(datos_no_atrapada, datos_atrapada)
            significancia = '***' if p_value < 0.001 else '**' if p_value < 0.01 else '*' if p_value < 0.05 else 'ns'

            resumen_optimizado['Metrica'].append(nombre)
            resumen_optimizado['Atrapada_Media'].append(f"{media_atrapada:.4f}")
            resumen_optimizado['Atrapada_Std'].append(f"{std_atrapada:.4f}")
            resumen_optimizado['Atrapada_Count'].append(count_atrapada)
            resumen_optimizado['No_Atrapada_Media'].append(f"{media_no_atrapada:.4f}")
            resumen_optimizado['No_Atrapada_Std'].append(f"{std_no_atrapada:.4f}")
            resumen_optimizado['No_Atrapada_Count'].append(count_no_atrapada)
            resumen_optimizado['Diferencia_Pct'].append(f"{diferencia_pct:.1f}%")
            resumen_optimizado['Significancia'].append(significancia)

    df_resumen = pd.DataFrame(resumen_optimizado)
    df_resumen.to_csv(os.path.join(save_path, 'resumen_estadistico_optimizado.csv'), index=False)

    print(f"✓ Visualizaciones optimizadas generadas:")
    print(f"  - Análisis comparativo por tipologías")
    print(f"  - Evolución temporal del modelo")
    print(f"  - Análisis de trampa de innovación")
    print(f"  - Análisis geográfico regional")
    print(f"  - Dashboard integral de indicadores")
    print(f"  - Resumen estadístico optimizado")

    # 8. EMPLEO ESPECIALIZADO
    plt.figure(figsize=(10, 6))
    if 'empleo_especializado' in resultados.columns:
        empleo_especializado_limpio = resultados.dropna(subset=['empleo_especializado'])
        if not empleo_especializado_limpio.empty:
            empleo_especializado_tipologia = empleo_especializado_limpio.groupby('tipo_region_economica_inicial')['empleo_especializado'].mean()

            if not empleo_especializado_tipologia.empty:
                bars8 = plt.bar(empleo_especializado_tipologia.index, empleo_especializado_tipologia.values,
                                color=[colores_tipologia[tipo] for tipo in empleo_especializado_tipologia.index],
                                alpha=0.7, edgecolor='black')
                plt.title('Empleo especializado por tipología regional', fontweight='bold', fontsize=14)
                plt.ylabel('Empleo especializado', fontsize=12)
                plt.xlabel('Tipología regional', fontsize=12)
                for i, v in enumerate(empleo_especializado_tipologia.values):
                    plt.text(i, v + max(empleo_especializado_tipologia.values) * 0.02, f'{v:.1f}', ha='center', fontweight='bold')
            else:
                plt.text(0.5, 0.5, 'No hay datos válidos\npara empleo especializado', ha='center', va='center',
                        transform=plt.gca().transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
                plt.title('Empleo especializado por tipología regional\n(Datos no disponibles)', fontweight='bold', fontsize=14)
        else:
            plt.text(0.5, 0.5, 'No hay datos de\nempleo especializado', ha='center', va='center',
                    transform=plt.gca().transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
            plt.title('Empleo especializado por tipología regional\n(Datos no disponibles)', fontweight='bold', fontsize=14)
    else:
      plt.text(0.5, 0.5, 'Columna empleo_especializado\nno encontrada', ha='center', va='center',
                transform=plt.gca().transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
      plt.title('Empleo especializado por tipología regional\n(Error: columna no encontrada)', fontweight='bold', fontsize=14)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '08_empleo_especializado_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 9. EMPLEO TOTAL
    plt.figure(figsize=(10, 6))
    # Verificar que la columna existe y limpiar datos
    if 'empleo_total' in resultados.columns:
        empleo_total_limpio = resultados.dropna(subset=['empleo_total'])
        if not empleo_total_limpio.empty:
            empleo_total_tipologia = empleo_total_limpio.groupby('tipo_region_economica_inicial')['empleo_total'].mean()

            # Verificar que hay datos válidos
            if not empleo_total_tipologia.empty:
                bars9 = plt.bar(empleo_total_tipologia.index, empleo_total_tipologia.values,
                                color=[colores_tipologia[tipo] for tipo in empleo_total_tipologia.index],
                                alpha=0.7, edgecolor='black')
                plt.title('Empleo total por tipología regional', fontweight='bold', fontsize=14)
                plt.ylabel('Empleo total', fontsize=12)
                plt.xlabel('Tipología regional', fontsize=12)
                for i, v in enumerate(empleo_total_tipologia.values):
                    plt.text(i, v + max(empleo_total_tipologia.values) * 0.02, f'{v:.1f}', ha='center', fontweight='bold')
            else:
                plt.text(0.5, 0.5, 'No hay datos válidos\npara empleo total', ha='center', va='center',
                        transform=plt.gca().transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
                plt.title('Empleo total por tipología regional\n(Datos no disponibles)', fontweight='bold', fontsize=14)
        else:
            plt.text(0.5, 0.5, 'No hay datos de\nempleo total', ha='center', va='center',
                    transform=plt.gca().transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
            plt.title('Empleo total por tipología regional\n(Datos no disponibles)', fontweight='bold', fontsize=14)
    else:
        plt.text(0.5, 0.5, 'Columna empleo_total\nno encontrada', ha='center', va='center',
                transform=plt.gca().transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
        plt.title('Empleo total por tipología regional\n(Error: columna no encontrada)', fontweight='bold', fontsize=14)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '09_empleo_total_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 10. EVOLUCIÓN TEMPORAL - CAPACIDAD TECNOLÓGICA
    plt.figure(figsize=(12, 6))
    for tipologia in resultados['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados[resultados['tipo_region_economica_inicial'] == tipologia]
        evolucion = datos_tipologia.groupby('paso_tiempo')['capacidad_tecnologica'].mean()
        plt.plot(evolucion.index, evolucion.values,
                color=colores_tipologia[tipologia], label=tipologia, linewidth=2, marker='o', markersize=4)

    plt.title('Evolución de la capacidad tecnológica por tipología', fontweight='bold', fontsize=14)
    plt.xlabel('Paso de simulación', fontsize=12)
    plt.ylabel('Capacidad tecnológica', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '10_evolucion_capacidad_tecnologica.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 11. EVOLUCIÓN TEMPORAL - TASA DE INNOVACIÓN
    plt.figure(figsize=(12, 6))
    for tipologia in resultados['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados[resultados['tipo_region_economica_inicial'] == tipologia]
        evolucion = datos_tipologia.groupby('paso_tiempo')['tasa_innovacion'].mean()
        plt.plot(evolucion.index, evolucion.values,
                color=colores_tipologia[tipologia], label=tipologia, linewidth=2, marker='s', markersize=4)

    plt.title('Evolución de la tasa de innovación por tipología', fontweight='bold', fontsize=14)
    plt.xlabel('Paso de simulación', fontsize=12)
    plt.ylabel('Tasa de innovación', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '11_evolucion_tasa_innovacion.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 12. PORCENTAJE DE REGIONES ATRAPADAS
    plt.figure(figsize=(10, 6))
    # Verificar si existe la columna 'atrapada' o crearla basada en criterios
    if 'atrapada' in resultados.columns:
        atrapadas_limpio = resultados.dropna(subset=['atrapada'])
        if not atrapadas_limpio.empty:
            atrapadas_tipologia = atrapadas_limpio.groupby('tipo_region_economica_inicial')['atrapada'].mean() * 100

            if not atrapadas_tipologia.empty:
                bars12 = plt.bar(atrapadas_tipologia.index, atrapadas_tipologia.values,
                                 color=[colores_tipologia[tipo] for tipo in atrapadas_tipologia.index],
                                 alpha=0.7, edgecolor='black')
                plt.title('Regiones en trampa de innovación (%)', fontweight='bold', fontsize=14)
                plt.ylabel('Porcentaje atrapadas (%)', fontsize=12)
                plt.xlabel('Tipología regional', fontsize=12)
                for i, v in enumerate(atrapadas_tipologia.values):
                    plt.text(i, v + max(atrapadas_tipologia.values) * 0.02, f'{v:.1f}%', ha='center', fontweight='bold')
            else:
                plt.text(0.5, 0.5, 'No hay datos válidos\npara atrapadas', ha='center', va='center',
                        transform=plt.gca().transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
                plt.title('Regiones en Trampa de Innovación (%)\n(Datos no disponibles)', fontweight='bold', fontsize=14)
        else:
            plt.text(0.5, 0.5, 'No hay datos de\natrapadas', ha='center', va='center',
                    transform=plt.gca().transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
            plt.title('Regiones en Trampa de Innovación (%)\n(Datos no disponibles)', fontweight='bold', fontsize=14)
    else:
        # Crear proxy de atrapadas basado en criterios alternativos
        try:
            # Criterio: altas regiones con baja capacidad tecnológica y alta especialización
            resultados_proxy = resultados.copy()
            if 'capacidad_tecnologica' in resultados_proxy.columns and 'especializacion' in resultados_proxy.columns:
                # Normalizar las variables
                cap_tec_norm = (resultados_proxy['capacidad_tecnologica'] - resultados_proxy['capacidad_tecnologica'].min()) / (resultados_proxy['capacidad_tecnologica'].max() - resultados_proxy['capacidad_tecnologica'].min())
                espec_norm = (resultados_proxy['especializacion'] - resultados_proxy['especializacion'].min()) / (resultados_proxy['especializacion'].max() - resultados_proxy['especializacion'].min())

                # Criterio: alta especialización + baja capacidad tecnológica = atrapada
                resultados_proxy['atrapada_proxy'] = (espec_norm > 0.7) & (cap_tec_norm < 0.3)

                atrapadas_tipologia = resultados_proxy.groupby('tipo_region_economica_inicial')['atrapada_proxy'].mean() * 100

                if not atrapadas_tipologia.empty:
                    bars12 = plt.bar(atrapadas_tipologia.index, atrapadas_tipologia.values,
                                     color=[colores_tipologia[tipo] for tipo in atrapadas_tipologia.index],
                                     alpha=0.7, edgecolor='black')
                    plt.title('Regiones en trampa de innovación (%)\n(Criterio: Alta especialización + baja cap. tec)', fontweight='bold', fontsize=14)
                    plt.ylabel('Porcentaje atrapadas (%)', fontsize=12)
                    plt.xlabel('Tipología regional', fontsize=12)
                    for i, v in enumerate(atrapadas_tipologia.values):
                        plt.text(i, v + max(atrapadas_tipologia.values) * 0.02, f'{v:.1f}%', ha='center', fontweight='bold')
                else:
                    raise ValueError("No se pudieron calcular datos proxy")
            else:
                raise ValueError("Faltan variables para crear proxy")
        except Exception as e:
            plt.text(0.5, 0.5, 'No se pudo calcular\nporcentaje de atrapadas', ha='center', va='center',
                    transform=plt.gca().transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
            plt.title('Regiones en trampa de innovación (%)\n(Error en cálculo)', fontweight='bold', fontsize=14)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '12_porcentaje_atrapadas_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 13. PRODUCTIVIDAD POR EMPLEADO ESPECIALIZADO
    plt.figure(figsize=(10, 6))
    # Calcular productividad por empleado especializado
    resultados['productividad_por_empleado'] = resultados['productividad_promedio'] / np.maximum(1, resultados['empleo_especializado'])
    prod_empleo_tipologia = resultados.groupby('tipo_region_economica_inicial')['productividad_por_empleado'].mean()
    bars13 = plt.bar(prod_empleo_tipologia.index, prod_empleo_tipologia.values,
                     color=[colores_tipologia[tipo] for tipo in prod_empleo_tipologia.index],
                     alpha=0.7, edgecolor='black')
    plt.title('Productividad por empleado especializado por tipología', fontweight='bold', fontsize=14)
    plt.ylabel('Productividad por empleado', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(prod_empleo_tipologia.values):
        plt.text(i, v + 0.0005, f'{v:.4f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '13_productividad_por_empleado_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 14. EFICIENCIA INNOVADORA
    plt.figure(figsize=(10, 6))
    # Calcular eficiencia innovadora (productividad/tasa de innovación)
    resultados['eficiencia_innovadora'] = resultados['productividad_promedio'] / np.maximum(0.001, resultados['tasa_innovacion'])
    efic_innov_tipologia = resultados.groupby('tipo_region_economica_inicial')['eficiencia_innovadora'].mean()
    bars14 = plt.bar(efic_innov_tipologia.index, efic_innov_tipologia.values,
                     color=[colores_tipologia[tipo] for tipo in efic_innov_tipologia.index],
                     alpha=0.7, edgecolor='black')
    plt.title('Eficiencia innovadora (Productividad/Tasa innovación) por tipología', fontweight='bold', fontsize=14)
    plt.ylabel('Eficiencia innovadora', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(efic_innov_tipologia.values):
        plt.text(i, v + 5, f'{v:.1f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '14_eficiencia_innovadora_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 15. PRODUCTIVIDAD TECNOLÓGICA
    plt.figure(figsize=(10, 6))
    # Calcular productividad tecnológica (productividad/capacidad tecnológica)
    resultados['productividad_tecnologica'] = resultados['productividad_promedio'] / np.maximum(0.01, resultados['capacidad_tecnologica'])
    prod_tec_tipologia = resultados.groupby('tipo_region_economica_inicial')['productividad_tecnologica'].mean()
    bars15 = plt.bar(prod_tec_tipologia.index, prod_tec_tipologia.values,
                     color=[colores_tipologia[tipo] for tipo in prod_tec_tipologia.index],
                     alpha=0.7, edgecolor='black')
    plt.title('Productividad tecnológica (Productividad/Capacidad Tecnológica) por tipología', fontweight='bold', fontsize=14)
    plt.ylabel('Productividad tecnológica', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(prod_tec_tipologia.values):
        plt.text(i, v + 0.2, f'{v:.1f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '15_productividad_tecnologica_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 16. ÍNDICE DE COMPETITIVIDAD REGIONAL
    plt.figure(figsize=(10, 6))
    # Calcular índice de competitividad (productividad * innovación / brecha calificación)
    resultados['indice_competitividad'] = (resultados['productividad_promedio'] * resultados['tasa_innovacion']) / np.maximum(0.001, resultados['brecha_calificacion'])
    comp_reg_tipologia = resultados.groupby('tipo_region_economica_inicial')['indice_competitividad'].mean()
    bars16 = plt.bar(comp_reg_tipologia.index, comp_reg_tipologia.values,
                     color=[colores_tipologia[tipo] for tipo in comp_reg_tipologia.index],
                     alpha=0.7, edgecolor='black')
    plt.title('Índice de competitividad regional por tipología', fontweight='bold', fontsize=14)
    plt.ylabel('Índice de competitividad', fontsize=12)
    plt.xlabel('Tipología regional', fontsize=12)
    for i, v in enumerate(comp_reg_tipologia.values):
        plt.text(i, v + 0.001, f'{v:.3f}', ha='center', fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '16_indice_competitividad_tipologias.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 17. EVOLUCIÓN TEMPORAL - PRODUCTIVIDAD
    plt.figure(figsize=(12, 6))
    for tipologia in resultados['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados[resultados['tipo_region_economica_inicial'] == tipologia]
        evolucion = datos_tipologia.groupby('paso_tiempo')['productividad_promedio'].mean()
        plt.plot(evolucion.index, evolucion.values,
                color=colores_tipologia[tipologia], label=tipologia, linewidth=2, marker='^', markersize=4)

    plt.title('Evolución de la productividad por tipología', fontweight='bold', fontsize=14)
    plt.xlabel('Paso de simulación', fontsize=12)
    plt.ylabel('Productividad promedio', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '17_evolucion_productividad.png'), dpi=300, bbox_inches='tight')
    plt.close()

    # 18. EVALUACIÓN DINÁMICA DE TIPOLOGÍAS
    if 'estado_dinamico' in resultados.columns:
        plt.figure(figsize=(18, 10))

        # Subplot 1: Distribución de estados dinámicos
        plt.subplot(2, 2, 1)
        estados_dinamicos = resultados['estado_dinamico'].value_counts()
        colores_estados = {'Atrapada': '#FF7F0E', 'No_Atrapada': '#1F77B4', 'En_transicion': '#2CA02C'}
        colors = [colores_estados.get(estado, '#D62728') for estado in estados_dinamicos.index]
        plt.pie(estados_dinamicos.values, labels=estados_dinamicos.index, autopct='%1.1f%%',
                colors=colors, startangle=90)
        plt.title('Distribución de estados dinámicos', fontweight='bold')

        # Subplot 2: Propensión a estar atrapada por estado
        plt.subplot(2, 2, 2)
        propension_estado = resultados.groupby('estado_dinamico')['propension_atrappada'].mean()
        bars = plt.bar(propension_estado.index, propension_estado.values,
                       color=[colores_estados.get(estado, '#D62728') for estado in propension_estado.index],
                       alpha=0.7, edgecolor='black')
        plt.title('Propensión entrampadas', fontweight='bold')
        plt.ylabel('Propensión promedio')
        for i, v in enumerate(propension_estado.values):
            plt.text(i, v + 0.01, f'{v:.3f}', ha='center', fontweight='bold')

        # Subplot 3: Capacidad tecnológica por estado dinámico
        plt.subplot(2, 2, 3)
        cap_tec_estado = resultados.groupby('estado_dinamico')['capacidad_tecnologica'].mean()
        bars = plt.bar(cap_tec_estado.index, cap_tec_estado.values,
                       color=[colores_estados.get(estado, '#D62728') for estado in cap_tec_estado.index],
                       alpha=0.7, edgecolor='black')
        plt.title('Capacidad tecnológica por estado dinámico', fontweight='bold')
        plt.ylabel('Capacidad tecnológica promedio')
        for i, v in enumerate(cap_tec_estado.values):
            plt.text(i, v + 0.02, f'{v:.3f}', ha='center', fontweight='bold')

        # Subplot 4: Evolución temporal de estados
        plt.subplot(2, 2, 4)
        evolucion_temporal = resultados.groupby(['paso_tiempo', 'estado_dinamico']).size().unstack(fill_value=0)
        if 'Atrapada' in evolucion_temporal.columns:
            evolucion_temporal['porcentaje_atrapadas'] = (evolucion_temporal['Atrapada'] /
                                                        evolucion_temporal.sum(axis=1) * 100)
            plt.plot(evolucion_temporal.index, evolucion_temporal['porcentaje_atrapadas'],
                     marker='o', linewidth=2, color='#FF7F0E')
            plt.title('Evolución % regiones atrapadas', fontweight='bold')
            plt.ylabel('Porcentaje atrapadas')
            plt.xlabel('Paso temporal')
            plt.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.savefig(os.path.join(save_path, '18_evaluacion_dinamica.png'), dpi=300, bbox_inches='tight')
        plt.close()

        print("✓ 18. Evaluación dinámica generada exitosamente")

    print("✓ 18 gráficas individuales generadas exitosamente (incluyendo evaluación dinámica)")

    return {
        'resumen_estadistico': df_resumen,
        'analisis_trampa': trap_analysis,
        'evolucion_temporal': evolucion_temporal
    }

def crear_graficos_correlacion_optimizados(resultados: pd.DataFrame, save_path: str):
    """
    Función optimizada de correlación que incluye:
    1. Análisis por categorías: Regional, Sectorial, Corporativo, Tecnológico
    2. Correlaciones por tipologías regionales
    3. Análisis temporal de correlaciones
    4. Correlaciones cruzadas entre tipologías
    5. Identificación de patrones de dependencia
    """
    setup_matplotlib_for_plotting()

    # Definir variables por categoría con nombres mejorados
    variables_regionales = [
        'desarrollo_economico_geo', 'cercania_frontera_eeuu', 'riqueza_natural_geo',
        'factor_aridez', 'rezago_social_geo', 'conectividad_transport', 'inversion_extranjera_geo'
    ]

    variables_sectoriales = [
        'diversidad_sectorial', 'especializacion', 'coordinacion_promedio',
        'eficiencia_asignacion', 'flujos_internos'
    ]

    variables_corporativas = [
        'empleo_especializado', 'empleo_total', 'empleo_especializado_region',
        'empleo_total_region', 'productividad_promedio', 'innovaciones_realizadas'
    ]

    variables_tecnologicas = [
        'capacidad_tecnologica', 'tasa_innovacion', 'actualizacion_tecnologica'
    ]

    # Variables adicionales clave
    variables_clave = [
        'capacidad_tecnologica', 'tasa_innovacion', 'productividad_promedio',
        'diversidad_sectorial', 'especializacion', 'empleo_total', 'brecha_calificacion'
    ]

    # Filtrar solo las columnas numéricas que existen en el DataFrame
    columnas_existentes = [col for col in resultados.columns if resultados[col].dtype in ['int64', 'float64']]

    def filtrar_variables_existentes(variables_lista):
        return [var for var in variables_lista if var in columnas_existentes]

    variables_regionales_filt = filtrar_variables_existentes(variables_regionales)
    variables_sectoriales_filt = filtrar_variables_existentes(variables_sectoriales)
    variables_corporativas_filt = filtrar_variables_existentes(variables_corporativas)
    variables_tecnologicas_filt = filtrar_variables_existentes(variables_tecnologicas)
    variables_clave_filt = filtrar_variables_existentes(variables_clave)

    print("\n=== GENERANDO GRÁFICOS DE CORRELACIÓN OPTIMIZADOS ===")

    # =============================================
    # 1. MATRIZ DE CORRELACIONES PRINCIPALES
    # =============================================

    if variables_clave_filt:
        fig, ax = plt.subplots(1, 1, figsize=(12, 10))

        corr_principal = calcular_correlacion_segura(resultados[variables_clave_filt])

        if not corr_principal.empty:
            # Crear máscara para la mitad superior
            mask = np.triu(np.ones_like(corr_principal, dtype=bool))

            sns.heatmap(corr_principal, mask=mask, annot=True, cmap='RdBu_r', center=0,
                       square=True, linewidths=0.5, cbar_kws={"shrink": .8}, ax=ax,
                       fmt='.3f', annot_kws={'size': 9, 'weight': 'bold'})

            ax.set_title('Matriz de correlaciones principales\nModelo económico regional',
                        fontweight='bold', fontsize=14, pad=20)

            # Mejorar etiquetas
            labels_mejorados = {
                'capacidad_tecnologica': 'Cap.\nTecnológica',
                'tasa_innovacion': 'Tasa\nInnovación',
                'productividad_promedio': 'Productividad\nPromedio',
                'diversidad_sectorial': 'Diversidad\nSectorial',
                'especializacion': 'Especialización',
                'empleo_total': 'Empleo\nTotal',
                'brecha_calificacion': 'Brecha\nCalificación'
            }

            labels_finales = [labels_mejorados.get(col, col.replace('_', '\n')) for col in corr_principal.columns]
            ax.set_xticklabels(labels_finales, rotation=45, ha='right')
            ax.set_yticklabels(labels_finales, rotation=0)

            # Añadir líneas de separación para correlaciones fuertes
            for i in range(len(corr_principal)):
                for j in range(len(corr_principal)):
                    if abs(corr_principal.iloc[i, j]) > 0.7 and i != j:
                        ax.add_patch(plt.Rectangle((j-0.4, i-0.4), 0.8, 0.8,
                                                 fill=False, edgecolor='red', lw=2))
        else:
            ax.text(0.5, 0.5, 'No hay correlaciones válidas\npara variables principales',
                   ha='center', va='center', transform=ax.transAxes, fontsize=14,
                   bbox=dict(boxstyle='round', facecolor='lightgray'))
            ax.set_title('Matriz de correlaciones principales\n(Error: Sin datos)', fontweight='bold')

        plt.tight_layout()
        plt.savefig(os.path.join(save_path, '01_matriz_correlaciones_principales.png'),
                    dpi=300, bbox_inches='tight')
        plt.close()

    # =============================================
    # 2. CORRELACIONES POR CATEGORÍAS ESPECIALIZADAS
    # =============================================

    fig, axes = plt.subplots(2, 2, figsize=(24, 20))
    fig.suptitle('Matrices de correlación por categorías especializadas\nAnálisis multidimensional del sistema',
                 fontsize=16, fontweight='bold', y=0.95)

    # Configurar categorías con títulos mejorados
    categorias = [
        (variables_regionales_filt, axes[0,0], 'Correlaciones regionales\n(Geográficas, Desarrollo, Entorno)', 'Regional'),
        (variables_sectoriales_filt, axes[0,1], 'Correlaciones sectoriales\n(Diversidad, Especialización, Coordinación)', 'Sectorial'),
        (variables_corporativas_filt, axes[1,0], 'Correlaciones corporativas\n(Empleo, Productividad, Innovación)', 'Corporativa'),
        (variables_tecnologicas_filt, axes[1,1], 'Correlaciones tecnológicas\n(Capacidad, Innovación, Actualización)', 'Tecnológica')
    ]

    for variables_cat, ax, titulo, categoria_nombre in categorias:
        if variables_cat and len(variables_cat) > 1:
            df_cat = resultados[variables_cat]
            corr_cat = calcular_correlacion_segura(df_cat)

            if not corr_cat.empty:
                # Crear mapa de calor con anotaciones mejoradas
                sns.heatmap(corr_cat, annot=True, cmap='RdBu_r', center=0,
                           square=True, linewidths=0.5, cbar_kws={"shrink": .8}, ax=ax,
                           fmt='.3f', annot_kws={'size': 8, 'weight': 'bold'})

                ax.set_title(titulo, fontweight='bold', fontsize=12)

                # Mejorar etiquetas de ejes
                labels_cortos = [col.replace('_', '\n') for col in corr_cat.columns]
                ax.set_xticklabels(labels_cortos, rotation=45, ha='right', fontsize=9)
                ax.set_yticklabels(labels_cortos, rotation=0, fontsize=9)

                # Añadir indicadores de correlaciones fuertes
                for i in range(len(corr_cat)):
                    for j in range(len(corr_cat)):
                        if abs(corr_cat.iloc[i, j]) > 0.6 and i != j:
                            ax.add_patch(plt.Rectangle((j-0.4, i-0.4), 0.8, 0.8,
                                                     fill=False, edgecolor='orange', lw=1.5))
            else:
                ax.text(0.5, 0.5, f'No hay correlaciones\nválidas para {categoria_nombre}',
                       ha='center', va='center', transform=ax.transAxes, fontsize=12,
                       bbox=dict(boxstyle='round', facecolor='lightyellow'))
                ax.set_title(titulo + '\n(Sin datos válidos)', fontweight='bold')
        else:
            ax.text(0.5, 0.5, f'No hay variables\n{categoria_nombre.lower()} disponibles',
                   ha='center', va='center', transform=ax.transAxes, fontsize=12,
                   bbox=dict(boxstyle='round', facecolor='lightgray'))
            ax.set_title(titulo + '\n(Sin variables)', fontweight='bold')

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '02_correlaciones_por_categorias.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 3. ANÁLISIS DE CORRELACIONES POR TIPOLOGÍA
    # =============================================

    if 'tipo_region_economica_inicial' in resultados.columns:
        tipologias = resultados['tipo_region_economica_inicial'].unique()

        if len(tipologias) > 1:
            n_tipologias = len(tipologias)
            fig, axes = plt.subplots(1, n_tipologias, figsize=(8*n_tipologias, 8))

            if n_tipologias == 1:
                axes = [axes]

            fig.suptitle('Correlaciones por tipología regional\nAnálisis diferencial del sistema',
                        fontsize=16, fontweight='bold')

            colores_tipologia = {'Atrapada': '#E74C3C', 'No_Atrapada': '#27AE60', 'En_transicion': '#F39C12'}

            correlaciones_tipologia = {}

            for idx, tipologia in enumerate(tipologias):
                datos_tipologia = resultados[resultados['tipo_region_economica_inicial'] == tipologia]

                if len(datos_tipologia) > 5 and variables_clave_filt:
                    corr_tipologia = datos_tipologia[variables_clave_filt].corr()
                    correlaciones_tipologia[tipologia] = corr_tipologia

                    # Crear heatmap
                    sns.heatmap(corr_tipologia, annot=True, cmap='RdBu_r', center=0,
                               square=True, linewidths=0.5, cbar_kws={"shrink": .8}, ax=axes[idx],
                               fmt='.3f', annot_kws={'size': 9, 'weight': 'bold'})

                    color_tipologia = colores_tipologia.get(tipologia, '#95A5A6')
                    axes[idx].set_title(f'{tipologia}\n(n={len(datos_tipologia):,} obs.)',
                                       fontweight='bold', fontsize=12, color=color_tipologia)

                    # Etiquetas mejoradas
                    labels_mejorados = [col.replace('_', '\n') for col in corr_tipologia.columns]
                    axes[idx].set_xticklabels(labels_mejorados, rotation=45, ha='right', fontsize=8)
                    axes[idx].set_yticklabels(labels_mejorados, rotation=0, fontsize=8)
                else:
                    axes[idx].text(0.5, 0.5, f'Insuficientes datos\npara {tipologia}\n(n={len(datos_tipologia)})',
                                  ha='center', va='center', transform=axes[idx].transAxes,
                                  fontsize=11, bbox=dict(boxstyle='round', facecolor='lightgray'))
                    axes[idx].set_title(f'{tipologia}\n(Datos insuficientes)', fontweight='bold')

            plt.tight_layout()
            plt.savefig(os.path.join(save_path, '03_correlaciones_por_tipologia.png'),
                        dpi=300, bbox_inches='tight')
            plt.close()

            # =============================================
            # 4. COMPARACIÓN DE CORRELACIONES ENTRE TIPOLOGÍAS
            # =============================================

            if len(correlaciones_tipologia) > 1:
                fig, ax = plt.subplots(1, 1, figsize=(16, 10))

                # Seleccionar variable principal para comparación
                variable_principal = 'capacidad_tecnologica'
                if variable_principal not in variables_clave_filt:
                    variable_principal = variables_clave_filt[0] if variables_clave_filt else None

                if variable_principal and all(variable_principal in corr for corr in correlaciones_tipologia.values()):
                    # Crear DataFrame de comparaciones
                    comparacion_corr = pd.DataFrame(index=variables_clave_filt)

                    for tipologia, corr_matrix in correlaciones_tipologia.items():
                        comparacion_corr[tipologia] = corr_matrix[variable_principal]

                    # Gráfico de barras agrupadas
                    x_pos = np.arange(len(comparacion_corr.index))
                    width = 0.35 if len(correlaciones_tipologia) == 2 else 0.25

                    for idx, tipologia in enumerate(comparacion_corr.columns):
                        offset = (idx - len(comparacion_corr.columns)/2 + 0.5) * width
                        bars = ax.bar(x_pos + offset, comparacion_corr[tipologia], width,
                                    label=tipologia, alpha=0.8,
                                    color=colores_tipologia.get(tipologia, '#95A5A6'))

                        # Añadir valores en las barras
                        for bar, valor in zip(bars, comparacion_corr[tipologia]):
                            height = bar.get_height()
                            ax.text(bar.get_x() + bar.get_width()/2., height + 0.01 if height >= 0 else height - 0.03,
                                   f'{valor:.3f}', ha='center', va='bottom' if height >= 0 else 'top',
                                   fontweight='bold', fontsize=9)

                    ax.set_xlabel('Variables', fontsize=12, fontweight='bold')
                    ax.set_ylabel(f'Correlación con {variable_principal.replace("_", " ").title()}',
                                 fontsize=12, fontweight='bold')
                    ax.set_title(f'Comparación de correlaciones con {variable_principal.replace("_", " ").title()}\npor Tipología Regional',
                                fontweight='bold', fontsize=14)
                    ax.set_xticks(x_pos)
                    ax.set_xticklabels([var.replace('_', '\n') for var in comparacion_corr.index],
                                     rotation=45, ha='right')
                    ax.legend(title='Tipología Regional')
                    ax.grid(True, alpha=0.3)
                    ax.axhline(y=0, color='black', linestyle='-', alpha=0.5)

                    plt.tight_layout()
                    plt.savefig(os.path.join(save_path, '04_comparacion_correlaciones_tipologias.png'),
                                dpi=300, bbox_inches='tight')
                    plt.close()

    # =============================================
    # 5. RESUMEN EJECUTIVO DE CORRELACIONES
    # =============================================

    # Crear resumen estadístico de correlaciones
    resumen_correlaciones = {
        'categoria': [],
        'correlacion_promedio': [],
        'correlacion_maxima': [],
        'correlacion_minima': [],
        'num_variables': [],
        'correlaciones_fuertes': []  # > 0.7
    }

    categorias_resumen = [
        (variables_clave_filt, 'Variables principales'),
        (variables_regionales_filt, 'Regionales'),
        (variables_sectoriales_filt, 'Sectoriales'),
        (variables_corporativas_filt, 'Corporativas'),
        (variables_tecnologicas_filt, 'Tecnológicas')
    ]

    for variables_cat, nombre_cat in categorias_resumen:
        if variables_cat and len(variables_cat) > 1:
            corr_cat = calcular_correlacion_segura(resultados[variables_cat])

            if not corr_cat.empty:
                # Obtener valores de correlación (excluyendo diagonal)
                corr_vals = corr_cat.values
                corr_vals_sin_diag = corr_vals[~np.eye(corr_vals.shape[0], dtype=bool)]

                resumen_correlaciones['categoria'].append(nombre_cat)
                resumen_correlaciones['correlacion_promedio'].append(f"{np.mean(corr_vals_sin_diag):.4f}")
                resumen_correlaciones['correlacion_maxima'].append(f"{np.max(corr_vals_sin_diag):.4f}")
                resumen_correlaciones['correlacion_minima'].append(f"{np.min(corr_vals_sin_diag):.4f}")
                resumen_correlaciones['num_variables'].append(len(variables_cat))
                resumen_correlaciones['correlaciones_fuertes'].append(f"{(np.abs(corr_vals_sin_diag) > 0.7).sum()}")

    df_resumen_corr = pd.DataFrame(resumen_correlaciones)
    df_resumen_corr.to_csv(os.path.join(save_path, 'resumen_correlaciones_optimizado.csv'), index=False)

    print(f"✓ Gráficos de correlación optimizados generados:")
    if variables_clave_filt:
        print(f"  - Matriz de correlaciones principales ({len(variables_clave_filt)} variables)")
    print(f"  - Correlaciones por categorías especializadas")
    if 'tipo_region_economica_inicial' in resultados.columns:
        print(f"  - Análisis por tipologías regionales")
        print(f"  - Comparación entre tipologías")
    print(f"  - Resumen ejecutivo de correlaciones")

    return {
        'resumen_correlaciones': df_resumen_corr,
        'correlaciones_tipologia': correlaciones_tipologia if 'correlaciones_tipologia' in locals() else None
    }

    # Crear tabla de correlaciones más importantes
    correlaciones_importantes = []

    # Analizar cada categoría
    categorias_info = [
        ('Regional', variables_regionales_filt, 'Geográficas, Desarrollo, Entorno'),
        ('Sectorial', variables_sectoriales_filt, 'Diversificación, Especialización, Coordinación'),
        ('Corporativa', variables_corporativas_filt, 'Empleo, Productividad, Innovación'),
        ('Tecnológica', variables_tecnologicas_filt, 'Capacidad, Innovación, Actualización')
    ]

    for nombre_cat, variables_cat, descripcion in categorias_info:
        if len(variables_cat) > 1:
            df_cat = resultados[variables_cat]
            corr_cat = df_cat.corr()

            # Encontrar correlaciones más fuertes (excluyendo diagonal)
            corr_sin_diag = corr_cat.values
            np.fill_diagonal(corr_sin_diag, 0)

            # Encontrar correlaciones más altas
            correlaciones_planas = corr_sin_diag.flatten()
            correlaciones_planas = correlaciones_planas[correlaciones_planas != 0]

            if len(correlaciones_planas) > 0:
                corr_max = np.max(np.abs(correlaciones_planas))
                corr_promedio = np.mean(np.abs(correlaciones_planas))

                correlaciones_importantes.append({
                    'Categoría': nombre_cat,
                    'Descripción': descripcion,
                    'Variables': len(variables_cat),
                    'Correlación_Máxima': round(corr_max, 3),
                    'Correlación_Promedio': round(corr_promedio, 3)
                })

    # Guardar tabla de correlaciones
    if correlaciones_importantes:
        df_correlaciones = pd.DataFrame(correlaciones_importantes)
        df_correlaciones.to_csv(os.path.join(save_path, 'correlaciones_por_categoria.csv'),
                               index=False)

    print("✓ 19. Matriz de correlación categorizada generada exitosamente")
    print("✓ 20. Correlaciones cruzadas entre categorías generada exitosamente")
    print("✓ Tabla de correlaciones importantes guardada (correlaciones_por_categoria.csv)")

def evaluar_procesos_emergentes_optimizados(resultados: pd.DataFrame, save_path: str):
    """
    Función optimizada para evaluar procesos emergentes que incluye:
    1. Análisis de capital humano y aprendizaje por tipologías
    2. Evaluación de loops de retroalimentación
    3. Identificación de procesos acumulativos
    4. Análisis de persistencia y divergencia
    5. Métricas de autoorganización del sistema
    """
    setup_matplotlib_for_plotting()

    print("\n=== EVALUACIÓN OPTIMIZADA DE PROCESOS EMERGENTES ===")
    print("Analizando dinámicas de capital humano, loops de retroalimentación y procesos acumulativos...")

    # =============================================
    # 1. ANÁLISIS DE CAPITAL HUMANO POR TIPOLOGÍAS
    # =============================================

    resultados_con_capital = resultados.copy()

    # Calcular indicadores de formación de capital humano por tipología
    if 'tipo_region_economica_inicial' in resultados.columns:
        capital_por_tipologia = resultados.groupby('tipo_region_economica_inicial').agg({
            'brecha_calificacion': ['mean', 'std', 'min', 'max'],
            'capacidad_tecnologica': ['mean', 'std'],
            'empleo_especializado': ['mean', 'std'] if 'empleo_especializado' in resultados.columns else ['mean'],
            'productividad_promedio': ['mean', 'std']
        })

        # Aplanar columnas multi-nivel
        capital_por_tipologia.columns = ['_'.join(col).strip() for col in capital_por_tipologia.columns.values]

    # Crear variables de capital humano y aprendizaje
    resultados_con_capital['capital_humano_acumulado'] = (
        resultados_con_capital.groupby('id_region')['brecha_calificacion'].cummin()
    )
    resultados_con_capital['tasa_aprendizaje'] = (
        resultados_con_capital.groupby('id_region')['brecha_calificacion'].pct_change().abs()
    ).fillna(0)
    resultados_con_capital['progreso_formacion'] = (
        1 - resultados_con_capital['brecha_calificacion']
    )

    # =============================================
    # 2. IDENTIFICACIÓN DE LOOPS DE RETROALIMENTACIÓN
    # =============================================

    loops_refuerzo = []
    variables_loop = ['capacidad_tecnologica', 'productividad_promedio', 'tasa_innovacion', 'diversidad_sectorial']
    variables_loop = [var for var in variables_loop if var in resultados.columns]

    for tipologia in resultados['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados[resultados['tipo_region_economica_inicial'] == tipologia]

        for region_id in datos_tipologia['id_region'].unique():
            datos_region = datos_tipologia[datos_tipologia['id_region'] == region_id].copy()

            if len(datos_region) > 3:
                datos_region_clean = datos_region[variables_loop].dropna()

                if len(datos_region_clean) > 2:
                    matriz_corr = datos_region_clean.corr()

                    # Calcular indicadores de loops
                    if 'capacidad_tecnologica' in matriz_corr.columns and 'productividad_promedio' in matriz_corr.columns:
                        refuerzo_tech_prod = matriz_corr.loc['capacidad_tecnologica', 'productividad_promedio']
                    else:
                        refuerzo_tech_prod = 0

                    if 'productividad_promedio' in matriz_corr.columns and 'tasa_innovacion' in matriz_corr.columns:
                        refuerzo_prod_innov = matriz_corr.loc['productividad_promedio', 'tasa_innovacion']
                    else:
                        refuerzo_prod_innov = 0

                    if 'tasa_innovacion' in matriz_corr.columns and 'diversidad_sectorial' in matriz_corr.columns:
                        refuerzo_innov_div = matriz_corr.loc['tasa_innovacion', 'diversidad_sectorial']
                    else:
                        refuerzo_innov_div = 0

                    if 'diversidad_sectorial' in matriz_corr.columns and 'capacidad_tecnologica' in matriz_corr.columns:
                        refuerzo_div_tech = matriz_corr.loc['diversidad_sectorial', 'capacidad_tecnologica']
                    else:
                        refuerzo_div_tech = 0

                    # Evaluar presencia de loop de refuerzo
                    loop_strength = np.mean([refuerzo_tech_prod, refuerzo_prod_innov,
                                           refuerzo_innov_div, refuerzo_div_tech])

                    loops_refuerzo.append({
                        'id_region': region_id,
                        'tipologia': tipologia,
                        'loop_strength': loop_strength,
                        'tech_prod_corr': refuerzo_tech_prod,
                        'prod_innov_corr': refuerzo_prod_innov,
                        'innov_div_corr': refuerzo_innov_div,
                        'div_tech_corr': refuerzo_div_tech,
                        'loop_detectado': loop_strength > 0.3
                    })

    # =============================================
    # 3. ANÁLISIS DE PROCESOS ACUMULATIVOS
    # =============================================

    procesos_acumulativos = []

    for region_id in resultados['id_region'].unique():
        datos_region = resultados[resultados['id_region'] == region_id].copy()
        tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

        if len(datos_region) > 5:
            # Calcular trayectorias acumulativas
            trayectorias = {
                'capacidad_tecnologica': datos_region['capacidad_tecnologica'].values,
                'productividad': datos_region['productividad_promedio'].values,
                'innovacion': datos_region['tasa_innovacion'].values
            }

            # Evaluar auto-reforzo (persistencia)
            autocorr_capacity = datos_region['capacidad_tecnologica'].autocorr(lag=1)
            autocorr_productivity = datos_region['productividad_promedio'].autocorr(lag=1)

            # Evaluar crecimiento acumulativo (tendencia)
            x = np.arange(len(datos_region))
            slope_capacity = np.polyfit(x, trayectorias['capacidad_tecnologica'], 1)[0]
            slope_productivity = np.polyfit(x, trayectorias['productividad'], 1)[0]

            procesos_acumulativos.append({
                'id_region': region_id,
                'tipologia': tipologia,
                'autocorr_capacity': autocorr_capacity,
                'autocorr_productivity': autocorr_productivity,
                'slope_capacity': slope_capacity,
                'slope_productivity': slope_productivity,
                'proceso_acumulativo': (autocorr_capacity > 0.5 and slope_capacity > 0.001) or
                                     (autocorr_productivity > 0.5 and slope_productivity > 0.001)
            })

    # =============================================
    # 4. VISUALIZACIÓN INTEGRAL DE PROCESOS EMERGENTES
    # =============================================

    fig, axes = plt.subplots(2, 3, figsize=(24, 16))
    fig.suptitle('Análisis de procesos emergentes: Autoorganización y dinámicas complejas\n' +
                'Capital humano • Loops de retroalimentación • Procesos acumulativos',
                fontsize=16, fontweight='bold', y=0.95)

    # Panel 1: Capital humano por tipología
    if 'tipo_region_economica_inicial' in resultados.columns:
        colores_tipologia = {'Atrapada': '#E74C3C', 'No_Atrapada': '#27AE60', 'En_transicion': '#F39C12'}

        datos_capital = resultados.groupby('tipo_region_economica_inicial')['brecha_calificacion'].mean()
        errores_capital = resultados.groupby('tipo_region_economica_inicial')['brecha_calificacion'].std()

        bars = axes[0,0].bar(datos_capital.index, datos_capital.values,
                           yerr=errores_capital.values, capsize=5,
                           color=[colores_tipologia.get(tip, '#95A5A6') for tip in datos_capital.index],
                           alpha=0.8, edgecolor='black')

        axes[0,0].set_title('Capital humano por tipología\n(Breve calificación)', fontweight='bold')
        axes[0,0].set_ylabel('Brecha de calificación (Media ± Desv)', fontsize=12)
        axes[0,0].tick_params(axis='x', rotation=45)
        axes[0,0].grid(True, alpha=0.3)

        # Añadir valores
        for bar, valor in zip(bars, datos_capital.values):
            height = bar.get_height()
            axes[0,0].text(bar.get_x() + bar.get_width()/2., height + errores_capital.mean()*0.1,
                          f'{valor:.3f}', ha='center', va='bottom', fontweight='bold')

    # Panel 2: Loops de retroalimentación detectados
    if loops_refuerzo:
        df_loops = pd.DataFrame(loops_refuerzo)

        loops_por_tipologia = df_loops.groupby('tipologia')['loop_detectado'].agg(['sum', 'count'])
        loops_por_tipologia['proporcion'] = loops_por_tipologia['sum'] / loops_por_tipologia['count']

        bars = axes[0,1].bar(loops_por_tipologia.index, loops_por_tipologia['proporcion'],
                           color=[colores_tipologia.get(tip, '#95A5A6') for tip in loops_por_tipologia.index],
                           alpha=0.8, edgecolor='black')

        axes[0,1].set_title('Proporción de regiones con\nLoops de retroalimentación', fontweight='bold')
        axes[0,1].set_ylabel('Proporción de regiones', fontsize=12)
        axes[0,1].set_ylim(0, 1)
        axes[0,1].tick_params(axis='x', rotation=45)
        axes[0,1].grid(True, alpha=0.3)

        # Añadir porcentajes
        for bar, prop in zip(bars, loops_por_tipologia['proporcion']):
            height = bar.get_height()
            axes[0,1].text(bar.get_x() + bar.get_width()/2., height + 0.02,
                          f'{prop:.1%}', ha='center', va='bottom', fontweight='bold')

    # Panel 3: Intensidad de loops por tipología
    if loops_refuerzo:
        df_loops = pd.DataFrame(loops_refuerzo)

        box_data = []
        labels_box = []
        colors_box = []

        for tipologia in df_loops['tipologia'].unique():
            datos_tip = df_loops[df_loops['tipologia'] == tipologia]['loop_strength']
            if len(datos_tip) > 0:
                box_data.append(datos_tip.values)
                labels_box.append(tipologia)
                colors_box.append(colores_tipologia.get(tipologia, '#95A5A6'))

        if box_data:
            bp = axes[0,2].boxplot(box_data, labels=labels_box, patch_artist=True)

            for patch, color in zip(bp['boxes'], colors_box):
                patch.set_facecolor(color)
                patch.set_alpha(0.7)

            axes[0,2].set_title('Intensidad de loops de\nRetroalimentación por tipología', fontweight='bold')
            axes[0,2].set_ylabel('Intensidad del loop', fontsize=12)
            axes[0,2].tick_params(axis='x', rotation=45)
            axes[0,2].grid(True, alpha=0.3)
            axes[0,2].axhline(y=0.3, color='red', linestyle='--', alpha=0.7, label='Umbral Loop')
            axes[0,2].legend()

    # Panel 4: Procesos acumulativos por tipología
    if procesos_acumulativos:
        df_procesos = pd.DataFrame(procesos_acumulativos)

        acum_por_tipologia = df_procesos.groupby('tipologia')['proceso_acumulativo'].agg(['sum', 'count'])
        acum_por_tipologia['proporcion'] = acum_por_tipologia['sum'] / acum_por_tipologia['count']

        bars = axes[1,0].bar(acum_por_tipologia.index, acum_por_tipologia['proporcion'],
                           color=[colores_tipologia.get(tip, '#95A5A6') for tip in acum_por_tipologia.index],
                           alpha=0.8, edgecolor='black')

        axes[1,0].set_title('Regiones con procesos\nacumulativos detectados', fontweight='bold')
        axes[1,0].set_ylabel('Proporción de regiones', fontsize=12)
        axes[1,0].set_ylim(0, 1)
        axes[1,0].tick_params(axis='x', rotation=45)
        axes[1,0].grid(True, alpha=0.3)

        # Añadir porcentajes
        for bar, prop in zip(bars, acum_por_tipologia['proporcion']):
            height = bar.get_height()
            axes[1,0].text(bar.get_x() + bar.get_width()/2., height + 0.02,
                          f'{prop:.1%}', ha='center', va='bottom', fontweight='bold')

    # Panel 5: Autocorrelación como indicador de persistencia
    if procesos_acumulativos:
        df_procesos = pd.DataFrame(procesos_acumulativos)

        scatter_data = []
        for tipologia in df_procesos['tipologia'].unique():
            datos_tip = df_procesos[df_procesos['tipologia'] == tipologia]
            scatter_data.append((datos_tip['autocorr_capacity'], datos_tip['autocorr_productivity'], tipologia))

        for autocorr_cap, autocorr_prod, tipologia in scatter_data:
            axes[1,1].scatter(autocorr_cap, autocorr_prod,
                            label=tipologia, alpha=0.7, s=100,
                            color=colores_tipologia.get(tipologia, '#95A5A6'))

        axes[1,1].set_xlabel('Autocorrelación cap.tecnológica', fontsize=12)
        axes[1,1].set_ylabel('Autocorrelación productividad', fontsize=12)
        axes[1,1].set_title('Persistencia de variables\n(Autocorrelación)', fontweight='bold')
        axes[1,1].legend()
        axes[1,1].grid(True, alpha=0.3)
        axes[1,1].axhline(y=0, color='red', linestyle='--', alpha=0.5)
        axes[1,1].axvline(x=0, color='red', linestyle='--', alpha=0.5)

    # Panel 6: Matriz de correlación entre indicadores emergentes
    if loops_refuerzo and procesos_acumulativos:
        df_emergentes = pd.DataFrame(loops_refuerzo).merge(
            pd.DataFrame(procesos_acumulativos), on=['id_region', 'tipologia'], how='inner'
        )

        vars_emergentes = ['loop_strength', 'autocorr_capacity', 'slope_capacity', 'proceso_acumulativo']
        corr_emergentes = df_emergentes[vars_emergentes].corr()

        im = axes[1,2].imshow(corr_emergentes, cmap='RdBu_r', aspect='auto', vmin=-1, vmax=1)
        axes[1,2].set_xticks(range(len(vars_emergentes)))
        axes[1,2].set_yticks(range(len(vars_emergentes)))
        axes[1,2].set_xticklabels([var.replace('_', '\n') for var in vars_emergentes], rotation=45, ha='right')
        axes[1,2].set_yticklabels([var.replace('_', '\n') for var in vars_emergentes])
        axes[1,2].set_title('Correlaciones entre\nindicadores emergentes', fontweight='bold')

        # Añadir valores
        for i in range(len(vars_emergentes)):
            for j in range(len(vars_emergentes)):
                text = axes[1,2].text(j, i, f'{corr_emergentes.iloc[i, j]:.2f}',
                                    ha="center", va="center", color="black", fontweight='bold')

        plt.colorbar(im, ax=axes[1,2], shrink=0.8)

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '06_procesos_emergentes_optimizados.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 5. GUARDAR RESULTADOS
    # =============================================

    if loops_refuerzo:
        df_loops = pd.DataFrame(loops_refuerzo)
        df_loops.to_csv(os.path.join(save_path, 'loops_retroalimentacion_detectados.csv'), index=False)

    if procesos_acumulativos:
        df_procesos = pd.DataFrame(procesos_acumulativos)
        df_procesos.to_csv(os.path.join(save_path, 'procesos_acumulativos_detectados.csv'), index=False)

    if 'tipo_region_economica_inicial' in resultados.columns:
        capital_por_tipologia.to_csv(os.path.join(save_path, 'capital_humano_por_tipologia.csv'))

    # Crear resumen ejecutivo
    resumen_emergentes = {
        'total_regiones_analizadas': len(resultados['id_region'].unique()),
        'loops_retroalimentacion_detectados': len([l for l in loops_refuerzo if l['loop_detectado']]) if loops_refuerzo else 0,
        'procesos_acumulativos_detectados': len([p for p in procesos_acumulativos if p['proceso_acumulativo']]) if procesos_acumulativos else 0,
        'regiones_atrapadas_analizadas': len(resultados[resultados['tipo_region_economica_inicial'] == 'Atrapada']['id_region'].unique()) if 'tipo_region_economica_inicial' in resultados.columns else 0,
        'regiones_no_atrapadas_analizadas': len(resultados[resultados['tipo_region_economica_inicial'] == 'No_Atrapada']['id_region'].unique()) if 'tipo_region_economica_inicial' in resultados.columns else 0
    }

    pd.DataFrame([resumen_emergentes]).to_csv(os.path.join(save_path, 'resumen_procesos_emergentes.csv'), index=False)

    print(f"✓ Análisis de procesos emergentes optimizado completado")
    print(f"  - Loops de retroalimentación detectados: {resumen_emergentes['loops_retroalimentacion_detectados']}")
    print(f"  - Procesos acumulativos identificados: {resumen_emergentes['procesos_acumulativos_detectados']}")
    print(f"  - Regiones analizadas: {resumen_emergentes['total_regiones_analizadas']}")

    return {
        'loops_refuerzo': loops_refuerzo,
        'procesos_acumulativos': procesos_acumulativos,
        'capital_humano_tipologia': capital_por_tipologia if 'capital_por_tipologia' in locals() else None,
        'resumen': resumen_emergentes
    }

    # =============================================
    # 3. ANÁLISIS DE LOOPS DE RETROALIMENTACIÓN POSITIVA
    # =============================================

    # Identificar loops de refuerzo entre productividad, tecnología, innovación y diversificación
    loops_refuerzo = []
    variables_loop = ['capacidad_tecnologica', 'productividad_promedio', 'tasa_innovacion', 'diversidad_sectorial']

    for region_id in resultados_con_capital['id_region'].unique():
        datos_region = resultados_con_capital[resultados_con_capital['id_region'] == region_id].copy()

        if len(datos_region) > 1:
            # Calcular correlaciones temporales entre variables del loop
            datos_region_clean = datos_region[variables_loop].dropna()

            if len(datos_region_clean) > 2:
                matriz_corr = datos_region_clean.corr()

                # Identificar patrones de refuerzo
                refuerzo_tech_prod = matriz_corr.loc['capacidad_tecnologica', 'productividad_promedio']
                refuerzo_prod_innov = matriz_corr.loc['productividad_promedio', 'tasa_innovacion']
                refuerzo_innov_div = matriz_corr.loc['tasa_innovacion', 'diversidad_sectorial']
                refuerzo_div_tech = matriz_corr.loc['diversidad_sectorial', 'capacidad_tecnologica']

                # Loop completo de refuerzo
                loop_completo = (
                    refuerzo_tech_prod > 0.3 and
                    refuerzo_prod_innov > 0.3 and
                    refuerzo_innov_div > 0.3 and
                    refuerzo_div_tech > 0.3
                )

                loops_refuerzo.append({
                    'id_region': region_id,
                    'tech_prod_corr': refuerzo_tech_prod,
                    'prod_innov_corr': refuerzo_prod_innov,
                    'innov_div_corr': refuerzo_innov_div,
                    'div_tech_corr': refuerzo_div_tech,
                    'loop_completo': loop_completo,
                    'intensidad_refuerzo': (refuerzo_tech_prod + refuerzo_prod_innov +
                                          refuerzo_innov_div + refuerzo_div_tech) / 4
                })

    # =============================================
    # 4. VISUALIZACIONES DE PROCESOS EMERGENTES
    # =============================================

    # Crear figura con subplots para procesos emergentes
    fig, axes = plt.subplots(2, 2, figsize=(28, 16))
    fig.suptitle('Procesos emergentes dinámicos: Capital humano, brechas y loops de refuerzo\n' +
                'Modelo ABM económico regional - Evaluación integral',
                fontsize=14, fontweight='bold', y=0.95)

    # Panel 1: Evolución del Capital Humano
    if len(resultados_con_capital) > 0:
        cap_humano_por_tipo = resultados_con_capital.groupby(['tipo_region_economica_inicial', 'paso_tiempo'])['progreso_formacion'].mean().reset_index()

        for tipo in cap_humano_por_tipo['tipo_region_economica_inicial'].unique():
            datos_tipo = cap_humano_por_tipo[cap_humano_por_tipo['tipo_region_economica_inicial'] == tipo]
            axes[0,0].plot(datos_tipo['paso_tiempo'], datos_tipo['progreso_formacion'],
                          marker='o', linewidth=2, label=f'{tipo}', alpha=0.8)

        axes[0,0].set_title('Progreso en formación de capital humano\n(A mayor valor = menor brecha de calificación)',
                           fontweight='bold', fontsize=11)
        axes[0,0].set_xlabel('Paso de tiempo')
        axes[0,0].set_ylabel('Progreso en formación (1 - Brecha)')
        axes[0,0].legend()
        axes[0,0].grid(True, alpha=0.3)

    # Panel 2: Brechas Inter-Regionales
    if brechas_inter_regionales:
        df_brechas_inter = pd.DataFrame(brechas_inter_regionales)

        barras = axes[0,1].bar(range(len(df_brechas_inter)), df_brechas_inter['coeficiente_variacion'],
                              color='coral', alpha=0.7, edgecolor='black')
        axes[0,1].set_title('Brechas interregionales\n(Coeficiente de variación por tipo de región)',
                           fontweight='bold', fontsize=11)
        axes[0,1].set_xlabel('Tipo de región')
        axes[0,1].set_ylabel('Coeficiente de variación\n(mayor = más heterogéneo)')
        axes[0,1].set_xticks(range(len(df_brechas_inter)))
        axes[0,1].set_xticklabels(df_brechas_inter['tipo_region'], rotation=45, ha='right')

        # Añadir valores en las barras
        for i, barra in enumerate(barras):
            altura = barra.get_height()
            axes[0,1].text(barra.get_x() + barra.get_width()/2., altura + 0.01,
                          f'{altura:.3f}', ha='center', va='bottom', fontsize=9)

    # Panel 3: Variabilidad Intra-Regional
    if brechas_intra_regionales:
        df_brechas_intra = pd.DataFrame(brechas_intra_regionales)

        # Histograma de cambios en brechas
        axes[1,0].hist(df_brechas_intra['cambio_total'], bins=15, alpha=0.7,
                      color='lightblue', edgecolor='black')
        axes[1,0].set_title('Cambios en brechas intraregionales\n(Distribución de cambios temporales)',
                           fontweight='bold', fontsize=11)
        axes[1,0].set_xlabel('Cambio en brecha de calificación')
        axes[1,0].set_ylabel('Frecuencia')
        axes[1,0].axvline(x=0, color='red', linestyle='--', alpha=0.7, label='Sin cambio')
        axes[1,0].legend()
        axes[1,0].grid(True, alpha=0.3)

    # Panel 4: Intensidad de Loops de Refuerzo
    if loops_refuerzo:
        df_loops = pd.DataFrame(loops_refuerzo)
        loops_completos = df_loops['loop_completo'].sum()
        intensidad_promedio = df_loops['intensidad_refuerzo'].mean()

        # Gráfico de dispersión: intensidad vs regiones
        colores = ['green' if loop else 'orange' for loop in df_loops['loop_completo']]
        axes[1,1].scatter(range(len(df_loops)), df_loops['intensidad_refuerzo'],
                         c=colores, alpha=0.7, s=60, edgecolors='black')
        axes[1,1].set_title(f'Intensidad de loops de refuerzo\n' +
                           f'{loops_completos} regiones con loops completos\n' +
                           f'Intensidad promedio: {intensidad_promedio:.3f}',
                           fontweight='bold', fontsize=11)
        axes[1,1].set_xlabel('ID de región')
        axes[1,1].set_ylabel('Intensidad de refuerzo')
        axes[1,1].grid(True, alpha=0.3)
        axes[1,1].axhline(y=0.3, color='red', linestyle='--', alpha=0.7, label='Umbral mínimo')
        axes[1,1].legend()

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '21_procesos_emergentes_dinamicos.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 5. ANÁLISIS DE CONVERGENCIA Y DIVERGENCIA
    # =============================================

    # Analizar si las regiones convergen o divergen en el tiempo
    convergencia_divergecia = []

    for region_id in resultados_con_capital['id_region'].unique():
        datos_region = resultados_con_capital[resultados_con_capital['id_region'] == region_id]

        if len(datos_region) > 3:
            # Calcular tendencia temporal de la productividad (proxy del desarrollo)
            productividad = datos_region['productividad_promedio'].values
            pasos = datos_region['paso_tiempo'].values

            # Regresión lineal simple
            coeficiente = np.corrcoef(pasos, productividad)[0,1] * (np.std(productividad) / np.std(pasos))

            # Clasificar tendencia
            if coeficiente > 0.05:
                tendencia = 'Convergencia'
            elif coeficiente < -0.05:
                tendencia = 'Divergencia'
            else:
                tendencia = 'Estable'

            convergencia_divergecia.append({
                'id_region': region_id,
                'tendencia': tendencia,
                'coeficiente_tendencia': coeficiente,
                'productividad_inicial': productividad[0],
                'productividad_final': productividad[-1],
                'cambio_productividad': productividad[-1] - productividad[0]
            })

    # =============================================
    # 6. GUARDAR RESULTADOS DETALLADOS
    # =============================================

    # Guardar datos de procesos emergentes
    resultados_con_capital.to_csv(os.path.join(save_path, 'resultados_procesos_emergentes.csv'), index=False)

    # Crear tabla resumen de procesos emergentes
    resumen_emergentes = {
        'Proceso': [
            'Formación Capital Humano',
            'Brechas Inter-Regionales',
            'Brechas Intra-Regionales',
            'Loops de Refuerzo Positivo',
            'Procesos de Convergencia'
        ],
        'Descripción': [
            'Evolución temporal de habilidades y aprendizaje',
            'Heterogeneidad entre regiones del mismo tipo',
            'Variabilidad temporal dentro de cada región',
            'Refuerzo mutuo entre productividad, tech, innovación',
            'Convergencia vs divergencia de regiones'
        ],
        'Regiones_Analizadas': [
            len(resultados_con_capital['id_region'].unique()),
            len(brechas_inter_regionales),
            len(brechas_intra_regionales),
            len(loops_refuerzo),
            len(convergencia_divergecia)
        ],
        'Indicador_Principal': [
            f"{resultados_con_capital['progreso_formacion'].mean():.3f}",
            f"{np.mean([b['coeficiente_variacion'] for b in brechas_inter_regionales]):.3f}",
            f"{np.mean([b['variabilidad_temporal'] for b in brechas_intra_regionales]):.3f}",
            f"{np.mean([l['intensidad_refuerzo'] for l in loops_refuerzo]):.3f}",
            f"{len([c for c in convergencia_divergecia if c['tendencia'] == 'Convergencia'])}"
        ]
    }

    df_resumen_emergentes = pd.DataFrame(resumen_emergentes)
    df_resumen_emergentes.to_csv(os.path.join(save_path, 'resumen_procesos_emergentes.csv'), index=False)

    # Guardar datos detallados por proceso
    if brechas_inter_regionales:
        pd.DataFrame(brechas_inter_regionales).to_csv(
            os.path.join(save_path, 'brechas_inter_regionales.csv'), index=False)

    if brechas_intra_regionales:
        pd.DataFrame(brechas_intra_regionales).to_csv(
            os.path.join(save_path, 'brechas_intra_regionales.csv'), index=False)

    if loops_refuerzo:
        pd.DataFrame(loops_refuerzo).to_csv(
            os.path.join(save_path, 'loops_refuerzo_positivo.csv'), index=False)

    if convergencia_divergecia:
        pd.DataFrame(convergencia_divergecia).to_csv(
            os.path.join(save_path, 'convergencia_divergecia_regiones.csv'), index=False)

    print("✓ 21. Procesos emergentes dinámicos evaluados exitosamente")
    print(f"  - Formación capital humano: {len(resultados_con_capital['id_region'].unique())} regiones analizadas")
    print(f"  - Brechas inter-regionales: {len(brechas_inter_regionales)} tipos de región")
    print(f"  - Brechas intra-regionales: {len(brechas_intra_regionales)} regiones temporales")
    print(f"  - Loops de refuerzo: {len(loops_refuerzo)} regiones con análisis de loops")
    print(f"  - Convergencia/divergencia: {len(convergencia_divergecia)} regiones evaluadas")

def crear_tabla_resumen_tipologico(resultados: pd.DataFrame, save_path: str):
    """Crea tabla resumen por tipología regional con todas las métricas"""

    # Crear tabla de resumen por tipología inicial con todas las métricas

    # Definir columnas base para agregación
    columnas_base = {
        'capacidad_tecnologica': ['mean', 'std', 'min', 'max'],
        'innovaciones_realizadas': ['mean', 'std', 'sum'],
        'tasa_innovacion': ['mean', 'std', 'min', 'max'],
        'actualizacion_tecnologica': ['mean', 'std', 'min', 'max'],
        'diversidad_sectorial': ['mean', 'std', 'min', 'max'],
        'especializacion': ['mean', 'std', 'min', 'max'],
        'productividad_promedio': ['mean', 'std'],
        'coordinacion_promedio': ['mean', 'std'],
        'empleo_especializado': ['mean', 'std'],
        'empleo_total': ['mean', 'std'],
        'empleo_especializado_region': ['mean', 'std'],
        'empleo_total_region': ['mean', 'std'],
        'brecha_calificacion': ['mean', 'std', 'min', 'max'],
        'eficiencia_asignacion': ['mean', 'std']
    }

    # Agregar columna 'atrapada' si existe
    if 'atrapada' in resultados.columns:
        columnas_base['atrapada'] = 'mean'

    tabla_resumen = resultados.groupby('tipo_region_economica_inicial').agg(columnas_base).round(4)

    # Aplanar columnas multi-nivel
    tabla_resumen.columns = ['_'.join(col).strip() for col in tabla_resumen.columns.values]

    # Añadir métricas calculadas
    tabla_resumen['Tasa_Empleo_Especializado_Pct'] = (
        tabla_resumen['empleo_especializado_mean'] / tabla_resumen['empleo_total_mean'] * 100
    ).round(2)

    tabla_resumen['Tasa_Empleo_Especializado_Region_Pct'] = (
        tabla_resumen['empleo_especializado_region_mean'] / tabla_resumen['empleo_total_region_mean'] * 100
    ).round(2)

    # Calcular Porcentaje_Atrapadas solo si existe la columna
    if 'atrapada_mean' in tabla_resumen.columns:
        tabla_resumen['Porcentaje_Atrapadas'] = (
            tabla_resumen['atrapada_mean'] * 100
        ).round(2)
    else:
        # Crear proxy basado en criterios alternativos
        if 'capacidad_tecnologica_mean' in tabla_resumen.columns and 'especializacion_mean' in tabla_resumen.columns:
            # Criterio: regiones con alta especialización y baja capacidad tecnológica
            cap_tec_norm = tabla_resumen['capacidad_tecnologica_mean'] / tabla_resumen['capacidad_tecnologica_mean'].max()
            espec_norm = tabla_resumen['especializacion_mean'] / tabla_resumen['especializacion_mean'].max()
            tabla_resumen['Porcentaje_Atrapadas'] = ((espec_norm > 0.7) & (cap_tec_norm < 0.3)).astype(float) * 100
        else:
            tabla_resumen['Porcentaje_Atrapadas'] = 0.0  # Valor por defecto

    # Calcular métricas de productividad
    tabla_resumen['Productividad_Por_Empleado'] = (
        tabla_resumen['productividad_promedio_mean'] / np.maximum(0.01, tabla_resumen['empleo_especializado_mean'])
    ).round(4)

    tabla_resumen['Eficiencia_Innovadora'] = (
        tabla_resumen['productividad_promedio_mean'] / np.maximum(0.001, tabla_resumen['tasa_innovacion_mean'])
    ).round(2)

    tabla_resumen['Productividad_Tecnologica'] = (
        tabla_resumen['productividad_promedio_mean'] / np.maximum(0.01, tabla_resumen['capacidad_tecnologica_mean'])
    ).round(2)

    tabla_resumen['Indice_Competitividad'] = (
        (tabla_resumen['productividad_promedio_mean'] * tabla_resumen['tasa_innovacion_mean']) /
        np.maximum(0.001, tabla_resumen['brecha_calificacion_mean'])
    ).round(4)

    tabla_resumen['Productividad_Especializada'] = (
        tabla_resumen['productividad_promedio_mean'] * tabla_resumen['especializacion_mean']
    ).round(3)

    tabla_resumen['Productividad_Diversificada'] = (
        tabla_resumen['productividad_promedio_mean'] * tabla_resumen['diversidad_sectorial_mean']
    ).round(3)

    tabla_resumen['Eficiencia_Capital_Humano'] = (
        tabla_resumen['productividad_promedio_mean'] * (1 - tabla_resumen['brecha_calificacion_mean'])
    ).round(3)

    # Renombrar columnas para claridad con todas las métricas
    new_column_names = {
        'capacidad_tecnologica_mean': 'CapTech_Media',
        'capacidad_tecnologica_std': 'CapTech_Std',
        'tasa_innovacion_mean': 'TasaInnov_Media',
        'tasa_innovacion_std': 'TasaInnov_Std',
        'actualizacion_tecnologica_mean': 'ActualizacionTec_Media',
        'actualizacion_tecnologica_std': 'ActualizacionTec_Std',
        'innovaciones_realizadas_mean': 'Innovaciones_Media',
        'innovaciones_realizadas_sum': 'Innovaciones_Total',
        'diversidad_sectorial_mean': 'Diversidad_Media',
        'diversidad_sectorial_std': 'Diversidad_Std',
        'especializacion_mean': 'Especializacion_Media',
        'especializacion_std': 'Especializacion_Std',
        'productividad_promedio_mean': 'Productividad_Media',
        'productividad_promedio_std': 'Productividad_Std',
        'coordinacion_promedio_mean': 'Coordinacion_Media',
        'coordinacion_promedio_std': 'Coordinacion_Std',
        'empleo_especializado_mean': 'EmpleoEsp_Media',
        'empleo_especializado_std': 'EmpleoEsp_Std',
        'empleo_total_mean': 'EmpleoTotal_Media',
        'empleo_total_std': 'EmpleoTotal_Std',
        'empleo_especializado_region_mean': 'EmpleoEspReg_Media',
        'empleo_especializado_region_std': 'EmpleoEspReg_Std',
        'empleo_total_region_mean': 'EmpleoTotalReg_Media',
        'empleo_total_region_std': 'EmpleoTotalReg_Std',
        'brecha_calificacion_mean': 'BrechaCalif_Media',
        'brecha_calificacion_std': 'BrechaCalif_Std',
        'brecha_calificacion_min': 'BrechaCalif_Min',
        'brecha_calificacion_max': 'BrechaCalif_Max',
        'eficiencia_asignacion_mean': 'EficienciaAsig_Media',
        'eficiencia_asignacion_std': 'EficienciaAsig_Std',
        # Agregar todas las métricas calculadas
        'Tasa_Empleo_Especializado_Pct': 'Tasa_Empleo_Especializado_Pct',
        'Tasa_Empleo_Especializado_Region_Pct': 'Tasa_Empleo_Especializado_Region_Pct',
        'Porcentaje_Atrapadas': 'Porcentaje_Atrapadas',
        'Productividad_Por_Empleado': 'Productividad_Por_Empleado',
        'Eficiencia_Innovadora': 'Eficiencia_Innovadora',
        'Productividad_Tecnologica': 'Productividad_Tecnologica',
        'Indice_Competitividad': 'Indice_Competitividad',
        'Productividad_Especializada': 'Productividad_Especializada',
        'Productividad_Diversificada': 'Productividad_Diversificada',
        'Eficiencia_Capital_Humano': 'Eficiencia_Capital_Humano'
    }

    tabla_resumen.rename(columns=new_column_names, inplace=True)

    # Guardar tabla
    tabla_resumen.to_csv(os.path.join(save_path, 'tabla_resumen_tipologico.csv'), encoding='utf-8')
    print("\n=== TABLA RESUMEN TIPOLÓGICO COMPLETA ===")
    print(tabla_resumen)
    return tabla_resumen

def analizar_trampa_innovacion_mercado_laboral(resultados: pd.DataFrame, save_path: str):
    """
    Análisis específico de la trampa de innovación relacionada con la estructura del mercado laboral

    Evalúa:
    - Polarización de empleos (alta calidad vs baja calidad)
    - Ventaja competitiva estática del mercado laboral
    - Círculo vicioso experiencia-valor diluido en entornos de baja tecnología
    - Dependencia de sectores específicos
    - Perpetuación de empleos de baja calidad
    """

    from scipy import stats
    from scipy.stats import pearsonr, spearmanr

    print("\n=== ANÁLISIS DE TRAMPA DE INNOVACIÓN: MERCADO LABORAL ===")

    # Preparar datos para análisis del mercado laboral
    resultados_laboral = resultados[['id_region', 'paso_tiempo', 'tipo_region_economica_inicial',
                                   'empleo_especializado', 'empleo_total', 'brecha_calificacion',
                                   'capacidad_tecnologica', 'tasa_innovacion', 'productividad_promedio',
                                   'especializacion', 'diversidad_sectorial']].copy()

    # =============================================
    # 1. POLARIZACIÓN DEL MERCADO LABORAL
    # =============================================

    # Clasificar empleos por calidad
    def clasificar_calidad_empleo(row):
        """Clasifica empleos según su calidad basada en múltiples factores"""
        empleo_especializado_ratio = row['empleo_especializado'] / max(1, row['empleo_total'])
        baja_brecha = (1 - row['brecha_calificacion'])  # Invertir brecha
        alta_capacidad = row['capacidad_tecnologica']
        alta_productividad = row['productividad_promedio'] / 50  # Normalizar productividad

        # Índice compuesto de calidad de empleo
        indice_calidad = (
            0.3 * empleo_especializado_ratio +
            0.25 * baja_brecha +
            0.25 * min(1.0, alta_capacidad / 1.5) +
            0.2 * min(1.0, alta_productividad)
        )

        if indice_calidad > 0.6:
            return 'Alta_Calidad'
        elif indice_calidad > 0.3:
            return 'Media_Calidad'
        else:
            return 'Baja_Calidad'

    resultados_laboral['calidad_empleo'] = resultados_laboral.apply(clasificar_calidad_empleo, axis=1)

    # Analizar polarización por región y tipología
    polarizacion_regional = []

    for region_id in resultados_laboral['id_region'].unique():
        datos_region = resultados_laboral[resultados_laboral['id_region'] == region_id]
        tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

        # Contar empleos por calidad
        conteo_calidades = datos_region['calidad_empleo'].value_counts()
        total_empleos = len(datos_region)

        alta_calidad_pct = conteo_calidades.get('Alta_Calidad', 0) / total_empleos * 100
        media_calidad_pct = conteo_calidades.get('Media_Calidad', 0) / total_empleos * 100
        baja_calidad_pct = conteo_calidades.get('Baja_Calidad', 0) / total_empleos * 100

        # Índice de polarización (diferencia entre empleos alta y baja calidad)
        indice_polarizacion = abs(alta_calidad_pct - baja_calidad_pct)

        polarizacion_regional.append({
            'id_region': region_id,
            'tipologia': tipologia,
            'empleos_alta_calidad_pct': alta_calidad_pct,
            'empleos_media_calidad_pct': media_calidad_pct,
            'empleos_baja_calidad_pct': baja_calidad_pct,
            'indice_polarizacion': indice_polarizacion,
            'empleos_alta_calidad_abs': conteo_calidades.get('Alta_Calidad', 0),
            'empleos_baja_calidad_abs': conteo_calidades.get('Baja_Calidad', 0)
        })

    df_polarizacion = pd.DataFrame(polarizacion_regional)

    # =============================================
    # 2. VENTAJA COMPETITIVA ESTÁTICA
    # =============================================

    # Calcular ventaja competitiva estática basada en estructura laboral
    resultados_laboral['ventaja_competitiva_estatica'] = (
        resultados_laboral['empleo_especializado'] / np.maximum(1, resultados_laboral['empleo_total']) *
        (1 - resultados_laboral['brecha_calificacion']) *
        resultados_laboral['productividad_promedio'] / 100
    )

    # =============================================
    # 3. CÍRCULO VICIOSO EXPERIENCIA-VALOR DILUIDO
    # =============================================

    # Simular el efecto de experiencia que se diluye en baja tecnología
    circulo_vicioso = []

    for region_id in resultados_laboral['id_region'].unique():
        datos_region = resultados_laboral[resultados_laboral['id_region'] == region_id].sort_values('paso_tiempo')
        tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

        if len(datos_region) > 3:
            # Calcular métricas de experiencia acumulada vs valor diluido
            capacidad_tech_promedio = datos_region['capacidad_tecnologica'].mean()
            brecha_calif_promedio = datos_region['brecha_calificacion'].mean()

            # Simular experiencia acumulada (basada en continuidad laboral)
            experiencia_simulada = np.cumsum(datos_region['empleo_especializado'] + datos_region['empleo_total'])

            # Valor diluido por baja tecnología (inversamente proporcional a capacidad tech)
            factor_dilucion = 1 / (1 + capacidad_tech_promedio)
            valor_real_experiencia = experiencia_simulada * factor_dilucion

            # Valor potencial en alta tecnología
            valor_potencial_experiencia = experiencia_simulada * 1.2

            # Pérdida de valor por dilución tecnológica
            perdida_valor = np.mean((valor_potencial_experiencia - valor_real_experiencia) / valor_potencial_experiencia)

            # Correlación entre experiencia y productividad (debe ser baja en trampa)
            if len(datos_region) > 5:
                corr_exp_prod = datos_region['empleo_total'].corr(datos_region['productividad_promedio'])
                corr_exp_innov = datos_region['empleo_total'].corr(datos_region['tasa_innovacion'])
            else:
                corr_exp_prod = 0
                corr_exp_innov = 0

            circulo_vicioso.append({
                'id_region': region_id,
                'tipologia': tipologia,
                'capacidad_tech_promedio': capacidad_tech_promedio,
                'brecha_calif_promedio': brecha_calif_promedio,
                'factor_dilucion': factor_dilucion,
                'perdida_valor_experiencia': perdida_valor,
                'corr_experiencia_productividad': corr_exp_prod,
                'corr_experiencia_innovacion': corr_exp_innov,
                'en_trampa_experiencia': (perdida_valor > 0.3) and (corr_exp_prod < 0.3)
            })

    df_circulo_vicioso = pd.DataFrame(circulo_vicioso)

    # =============================================
    # 4. DEPENDENCIA SECTORIAL ESPECÍFICA
    # =============================================

    # Calcular índice de dependencia sectorial
    dependencia_sectorial = []

    for region_id in resultados_laboral['id_region'].unique():
        datos_region = resultados_laboral[resultados_laboral['id_region'] == region_id]
        tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

        # Índice de especialización (Herfindahl-Hirschman invertido)
        especializacion_promedio = datos_region['especializacion'].mean()
        diversidad_promedio = datos_region['diversidad_sectorial'].mean()

        # Dependencia sectorial como proporción inversa de diversidad
        indice_dependencia = especializacion_promedio / (especializacion_promedio + diversidad_promedio + 0.01)

        # Vulnerabilidad por dependencia (alta cuando dependencia > 0.7)
        vulnerabilidad_dependencia = 'Alta' if indice_dependencia > 0.7 else 'Media' if indice_dependencia > 0.4 else 'Baja'

        dependencia_sectorial.append({
            'id_region': region_id,
            'tipologia': tipologia,
            'especializacion_promedio': especializacion_promedio,
            'diversidad_promedio': diversidad_promedio,
            'indice_dependencia_sectorial': indice_dependencia,
            'vulnerabilidad_dependencia': vulnerabilidad_dependencia
        })

    df_dependencia = pd.DataFrame(dependencia_sectorial)

    # =============================================
    # 5. PERPETUACIÓN DE EMPLEOS DE BAJA CALIDAD
    # =============================================

    # Analizar autosuficiencia en generación de empleos de alta calidad
    perpetuacion_empleos = []

    for tipologia in resultados_laboral['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados_laboral[resultados_laboral['tipo_region_economica_inicial'] == tipologia]

        # Proporción de empleos de baja calidad
        empleos_baja_calidad = len(datos_tipologia[datos_tipologia['calidad_empleo'] == 'Baja_Calidad'])
        total_empleos = len(datos_tipologia)
        proporcion_baja_calidad = empleos_baja_calidad / total_empleos

        # Capacidad de auto-mejora (correlación entre tiempo y mejora en calidad)
        if len(datos_tipologia) > 10:
            datos_tiempo = datos_tipologia.groupby('paso_tiempo')['calidad_empleo'].apply(
                lambda x: (x == 'Alta_Calidad').sum() / len(x)
            ).reset_index()
            datos_tiempo.columns = ['paso_tiempo', 'proporcion_alta_calidad']

            corr_tiempo_calidad = datos_tiempo['paso_tiempo'].corr(datos_tiempo['proporcion_alta_calidad'])
        else:
            corr_tiempo_calidad = 0

        # Tasa de transición empleos baja->alta calidad
        transiciones_baja_alta = 0
        regiones_con_transicion = 0

        for region_id in datos_tipologia['id_region'].unique():
            datos_region = datos_tipologia[datos_tipologia['id_region'] == region_id].sort_values('paso_tiempo')
            secuencia_calidad = datos_region['calidad_empleo'].tolist()

            # Detectar transición de baja a alta calidad
            if 'Baja_Calidad' in secuencia_calidad and 'Alta_Calidad' in secuencia_calidad:
                indices_baja = [i for i, cal in enumerate(secuencia_calidad) if cal == 'Baja_Calidad']
                indices_alta = [i for i, cal in enumerate(secuencia_calidad) if cal == 'Alta_Calidad']

                if min(indices_alta) > min(indices_baja):  # Transición real
                    transiciones_baja_alta += 1

            regiones_con_transicion += 1

        tasa_transicion = transiciones_baja_alta / max(1, regiones_con_transicion)

        perpetuacion_empleos.append({
            'tipologia': tipologia,
            'proporcion_empleos_baja_calidad': proporcion_baja_calidad,
            'corr_tiempo_mejora_calidad': corr_tiempo_calidad,
            'tasa_transicion_baja_alta': tasa_transicion,
            'regiones_con_transicion': transiciones_baja_alta,
            'total_regiones': regiones_con_transicion,
            'perpetuacion_alta': proporcion_baja_calidad > 0.6 and tasa_transicion < 0.3
        })

    df_perpetuacion = pd.DataFrame(perpetuacion_empleos)

    # =============================================
    # 6. VISUALIZACIÓN INTEGRAL
    # =============================================

    fig, axes = plt.subplots(2, 3, figsize=(28, 16))
    fig.suptitle('Trampa de innovación: Estructura del mercado laboral\\n' +
                'Polarización • Ventaja estática • Círculo vicioso • Dependencia',
                fontsize=16, fontweight='bold', y=0.95)

    # Panel 1: Distribución de empleos por calidad y tipología
    if not df_polarizacion.empty:
        try:
            tipologias = df_polarizacion['tipologia'].unique()
            if len(tipologias) > 0:
                x_pos = np.arange(len(tipologias))
                width = 0.25

                # Manejar valores NaN en el cálculo de promedios
                alta_calidad = []
                media_calidad = []
                baja_calidad = []

                for t in tipologias:
                    datos_tip = df_polarizacion[df_polarizacion['tipologia'] == t]
                    alta_mean = datos_tip['empleos_alta_calidad_pct'].mean()
                    media_mean = datos_tip['empleos_media_calidad_pct'].mean()
                    baja_mean = datos_tip['empleos_baja_calidad_pct'].mean()

                    alta_calidad.append(alta_mean if not pd.isna(alta_mean) else 0)
                    media_calidad.append(media_mean if not pd.isna(media_mean) else 0)
                    baja_calidad.append(baja_mean if not pd.isna(baja_mean) else 0)

                axes[0,0].bar(x_pos - width, alta_calidad, width, label='Alta calidad', color='blue', alpha=0.7)
                axes[0,0].bar(x_pos, media_calidad, width, label='Media calidad', color='black', alpha=0.7)
                axes[0,0].bar(x_pos + width, baja_calidad, width, label='Baja calidad', color='red', alpha=0.7)

                axes[0,0].set_xlabel('Tipología regional')
                axes[0,0].set_ylabel('Porcentaje de empleos')
                axes[0,0].set_title('Polarización del mercado laboral\\npor tipología', fontweight='bold')
                axes[0,0].set_xticks(x_pos)
                axes[0,0].set_xticklabels(tipologias, rotation=45, ha='right')
                axes[0,0].legend()
                axes[0,0].grid(True, alpha=0.3)
            else:
                axes[0,0].text(0.5, 0.5, 'Sin tipologías válidas', ha='center', va='center',
                              transform=axes[0,0].transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
                axes[0,0].set_title('Polarización del mercado laboral\\n(Sin tipologías)', fontweight='bold')
        except Exception as e:
            axes[0,0].text(0.5, 0.5, f'Error en polarización: {str(e)[:30]}', ha='center', va='center',
                          transform=axes[0,0].transAxes, fontsize=12, bbox=dict(boxstyle='round', facecolor='lightyellow'))
            axes[0,0].set_title('Polarización del mercado laboral\n(Error)', fontweight='bold')
    else:
        axes[0,0].text(0.5, 0.5, 'Sin datos de\npolarización', ha='center', va='center',
                      transform=axes[0,0].transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightblue'))
        axes[0,0].set_title('Polarización del mercado laboral\n(Sin datos)', fontweight='bold')

    # Panel 2: Ventaja competitiva estática vs capacidad innovadora
    axes[0,1].scatter(resultados_laboral['ventaja_competitiva_estatica'],
                     resultados_laboral['tasa_innovacion'],
                     c=resultados_laboral['capacidad_tecnologica'],
                     cmap='viridis', alpha=0.6)
    axes[0,1].set_xlabel('Ventaja competitiva estática')
    axes[0,1].set_ylabel('Tasa de innovación')
    axes[0,1].set_title('Ventaja estática vs\\nCapacidad innovadora', fontweight='bold')

    # Panel 3: Círculo vicioso - Pérdida de valor por dilución tecnológica
    if not df_circulo_vicioso.empty:
        scatter = axes[0,2].scatter(df_circulo_vicioso['capacidad_tech_promedio'],
                                   df_circulo_vicioso['perdida_valor_experiencia'],
                                   c=df_circulo_vicioso['brecha_calif_promedio'],
                                   cmap='RdYlBu_r', alpha=0.7, s=80)
        axes[0,2].set_xlabel('Capacidad tecnológica promedio')
        axes[0,2].set_ylabel('Pérdida de valor de experiencia')
        axes[0,2].set_title('Círculo vicioso:\\nExperiencia diluida por baja tecnología', fontweight='bold')

        # Línea de trampa (>30% pérdida)
        axes[0,2].axhline(y=0.3, color='red', linestyle='--', alpha=0.7, label='Umbral Trampa (30%)')
        axes[0,2].legend()
        plt.colorbar(scatter, ax=axes[0,2], label='Brecha Calificación')

    # Panel 4: Dependencia sectorial y vulnerabilidad
    if not df_dependencia.empty:
        dependencia_counts = df_dependencia['vulnerabilidad_dependencia'].value_counts()
        colores_vuln = {'Baja': 'green', 'Media': 'yellow', 'Alta': 'red'}
        colores_ordenados = [colores_vuln.get(vuln, 'gray') for vuln in dependencia_counts.index]

        axes[1,0].pie(dependencia_counts.values, labels=dependencia_counts.index,
                     autopct='%1.1f%%', colors=colores_ordenados, startangle=90)
        axes[1,0].set_title('Vulnerabilidad por\\nDependencia sectorial', fontweight='bold')

    # Panel 5: Evolución de la calidad de empleos en el tiempo
    evolucion_calidad = resultados_laboral.groupby(['paso_tiempo', 'calidad_empleo']).size().unstack(fill_value=0)
    if not evolucion_calidad.empty and 'Alta_Calidad' in evolucion_calidad.columns and 'Baja_Calidad' in evolucion_calidad.columns:
        axes[1,1].plot(evolucion_calidad.index, evolucion_calidad['Alta_Calidad'],
                      'g-', linewidth=2, label='Empleos alta calidad', marker='o')
        axes[1,1].plot(evolucion_calidad.index, evolucion_calidad['Baja_Calidad'],
                      'r-', linewidth=2, label='Empleos baja calidad', marker='s')
        axes[1,1].set_xlabel('Paso de tiempo')
        axes[1,1].set_ylabel('Número de empleos')
        axes[1,1].set_title('Evolución temporal de\\ncalidad de empleos', fontweight='bold')
        axes[1,1].legend()
        axes[1,1].grid(True, alpha=0.3)

    # Panel 6: Matriz de correlaciones - Trampa de innovación
    variables_trampa = ['ventaja_competitiva_estatica', 'brecha_calificacion', 'capacidad_tecnologica',
                       'empleo_especializado', 'productividad_promedio']
    datos_correlacion = resultados_laboral[variables_trampa]

    if not datos_correlacion.empty:
        matriz_corr = calcular_correlacion_segura(datos_correlacion)
        if not matriz_corr.empty:
            im = axes[1,2].imshow(matriz_corr, cmap='RdBu_r', aspect='auto', vmin=-1, vmax=1)
            axes[1,2].set_xticks(range(len(variables_trampa)))
            axes[1,2].set_yticks(range(len(variables_trampa)))
            axes[1,2].set_xticklabels([var.replace('_', '\\n') for var in variables_trampa], rotation=45, ha='right')
            axes[1,2].set_yticklabels([var.replace('_', '\\n') for var in variables_trampa])
            axes[1,2].set_title('Correlaciones en la\\ntrampa de innovacion', fontweight='bold')

            # Añadir valores de correlación
            for i in range(len(matriz_corr)):
                for j in range(len(matriz_corr)):
                    text = axes[1,2].text(j, i, f'{matriz_corr.iloc[i, j]:.2f}',
                                        ha="center", va="center", color="black", fontsize=8)

            plt.colorbar(im, ax=axes[1,2], shrink=0.8)
        else:
            axes[1,2].text(0.5, 0.5, 'No hay correlaciones\nválidas en la trampa',
                          ha='center', va='center', transform=axes[1,2].transAxes)
            axes[1,2].set_title('Correlaciones en la\nTrampa de innovacion', fontweight='bold')

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '23_trampa_innovacion_mercado_laboral.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 7. EVALUACIÓN INTEGRAL DE LA TRAMPA
    # =============================================

    # Crear índice compuesto de trampa de innovación
    resultados_trampa = resultados_laboral.groupby('id_region').agg({
        'ventaja_competitiva_estatica': 'mean',
        'brecha_calificacion': 'mean',
        'capacidad_tecnologica': 'mean',
        'empleo_especializado': 'mean',
        'empleo_total': 'mean',
        'tasa_innovacion': 'mean',
        'productividad_promedio': 'mean'
    }).round(4)

    # Calcular índice de trampa de innovación
    resultados_trampa['indice_polarizacion'] = df_polarizacion.set_index('id_region')['indice_polarizacion']
    resultados_trampa['perdida_valor_experiencia'] = df_circulo_vicioso.set_index('id_region')['perdida_valor_experiencia']
    resultados_trampa['indice_dependencia_sectorial'] = df_dependencia.set_index('id_region')['indice_dependencia_sectorial']

    # Normalizar variables para el índice (0-1)
    for col in ['ventaja_competitiva_estatica', 'indice_polarizacion', 'perdida_valor_experiencia', 'indice_dependencia_sectorial']:
        if col in resultados_trampa.columns:
            max_val = resultados_trampa[col].max()
            min_val = resultados_trampa[col].min()
            if max_val > min_val:
                resultados_trampa[f'{col}_norm'] = (resultados_trampa[col] - min_val) / (max_val - min_val)
            else:
                resultados_trampa[f'{col}_norm'] = 0

    # Índice compuesto de trampa (ponderado)
    if all(col in resultados_trampa.columns for col in ['ventaja_competitiva_estatica_norm', 'indice_polarizacion_norm',
                                                       'perdida_valor_experiencia_norm', 'indice_dependencia_sectorial_norm']):
        resultados_trampa['indice_trampa_innovacion'] = (
            0.3 * resultados_trampa['ventaja_competitiva_estatica_norm'] +
            0.25 * resultados_trampa['indice_polarizacion_norm'] +
            0.25 * resultados_trampa['perdida_valor_experiencia_norm'] +
            0.2 * resultados_trampa['indice_dependencia_sectorial_norm']
        )
    else:
        resultados_trampa['indice_trampa_innovacion'] = 0.5  # Valor por defecto

    # Añadir tipología
    tipologias_map = resultados_laboral.groupby('id_region')['tipo_region_economica_inicial'].first()
    resultados_trampa['tipologia'] = tipologias_map

    # =============================================
    # 8. GUARDAR RESULTADOS
    # =============================================

    df_polarizacion.to_csv(os.path.join(save_path, 'polarizacion_mercado_laboral.csv'), index=False)
    df_circulo_vicioso.to_csv(os.path.join(save_path, 'circulo_vicioso_experiencia_valor.csv'), index=False)
    df_dependencia.to_csv(os.path.join(save_path, 'dependencia_sectorial.csv'), index=False)
    df_perpetuacion.to_csv(os.path.join(save_path, 'perpetuacion_empleos_baja_calidad.csv'), index=False)
    resultados_trampa.to_csv(os.path.join(save_path, 'indice_trampa_innovacion.csv'), index=False)

    # Resumen ejecutivo
    resumen_trampa = {
        'total_regiones_analizadas': len(df_polarizacion),
        'regiones_en_trampa_experiencia': len(df_circulo_vicioso[df_circulo_vicioso['en_trampa_experiencia'] == True]),
        'regiones_alta_dependencia_sectorial': len(df_dependencia[df_dependencia['vulnerabilidad_dependencia'] == 'Alta']),
        'tipologias_perpetuacion_alta': len(df_perpetuacion[df_perpetuacion['perpetuacion_alta'] == True]),
        'polarizacion_promedio': df_polarizacion['indice_polarizacion'].mean(),
        'perdida_valor_experiencia_promedio': df_circulo_vicioso['perdida_valor_experiencia'].mean(),
        'indice_trampa_promedio': resultados_trampa['indice_trampa_innovacion'].mean(),
        'tipologia_mayor_trampa': resultados_trampa.groupby('tipologia')['indice_trampa_innovacion'].mean().idxmax() if not resultados_trampa.empty else 'N/A'
    }

    pd.DataFrame([resumen_trampa]).to_csv(os.path.join(save_path, 'resumen_trampa_innovacion.csv'), index=False)

    # =============================================
    # 9. IMPRIMIR RESULTADOS
    # =============================================

    print(f"✓ Análisis de trampa de innovación completado")
    print(f"  - Polarización del mercado laboral: {len(df_polarizacion)} regiones analizadas")
    print(f"  - Círculo vicioso experiencia-valor: {len(df_circulo_vicioso)} regiones evaluadas")
    print(f"  - Dependencia sectorial: {len(df_dependencia)} regiones clasificadas")
    print(f"  - Perpetuación empleos baja calidad: {len(df_perpetuacion)} tipologías analizadas")
    print(f"  - Índice trampa innovación: {len(resultados_trampa)} regiones medidas")
    print(f"\\n  📊 HALLAZGOS CLAVE:")
    print(f"  - Regiones en trampa experiencia: {resumen_trampa['regiones_en_trampa_experiencia']}")
    print(f"  - Alta dependencia sectorial: {resumen_trampa['regiones_alta_dependencia_sectorial']}")
    print(f"  - Polarización promedio: {resumen_trampa['polarizacion_promedio']:.2f}%")
    print(f"  - Pérdida valor experiencia promedio: {resumen_trampa['perdida_valor_experiencia_promedio']:.1%}")
    print(f"  - Tipología con mayor trampa: {resumen_trampa['tipologia_mayor_trampa']}")

    return {
        'polarizacion': df_polarizacion,
        'circulo_vicioso': df_circulo_vicioso,
        'dependencia': df_dependencia,
        'perpetuacion': df_perpetuacion,
        'indice_trampa': resultados_trampa,
        'resumen': resumen_trampa
    }

def analizar_evolucion_cambio_tecnico(resultados: pd.DataFrame, save_path: str):
    """
    Análisis integral de la evolución del cambio técnico

    Incluye:
    - Trayectorias tecnológicas por región y tipología
    - Velocidades de cambio técnico
    - Convergencia tecnológica entre regiones
    - Índices de madurez tecnológica compuestos
    - Análisis de spillovers y difusión tecnológica
    - Clasificación de tipos de cambio (incremental vs radical)
    - Análisis temporal multiescala
    """

    from scipy import stats
    from scipy.stats import linregress
    from sklearn.preprocessing import StandardScaler
    from sklearn.cluster import KMeans

    print("\n=== ANÁLISIS DE EVOLUCIÓN DEL CAMBIO TÉCNICO ===")

    # Preparar datos para análisis temporal
    resultados_tecnologia = resultados[['id_region', 'paso_tiempo', 'tipo_region_economica_inicial',
                                       'capacidad_tecnologica', 'tasa_innovacion', 'actualizacion_tecnologica',
                                       'productividad_promedio', 'diversidad_sectorial']].copy()

    # =============================================
    # 1. ANÁLISIS DE TRAYECTORIAS TECNOLÓGICAS
    # =============================================

    trayectorias_tecnologicas = []

    for region_id in resultados_tecnologia['id_region'].unique():
        datos_region = resultados_tecnologia[resultados_tecnologia['id_region'] == region_id].copy()
        datos_region = datos_region.sort_values('paso_tiempo')

        if len(datos_region) > 3:  # Mínimo 4 puntos para análisis de tendencia
            tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

            # Calcular métricas de trayectoria
            x = datos_region['paso_tiempo'].values
            y_cap_tec = datos_region['capacidad_tecnologica'].values
            y_innov = datos_region['tasa_innovacion'].values
            y_actualiz = datos_region['actualizacion_tecnologica'].values

            # Regresiones lineales para tendencia
            slope_cap, intercept_cap, r_cap, p_cap, se_cap = linregress(x, y_cap_tec)
            slope_innov, intercept_innov, r_innov, p_innov, se_innov = linregress(x, y_innov)
            slope_act, intercept_act, r_act, p_act, se_act = linregress(x, y_actualiz)

            # Clasificar tipo de trayectoria
            crecimiento_tecnologico = slope_cap > 0.01
            crecimiento_innovacion = slope_innov > 0.001
            volatilidad_tecnologica = np.std(y_cap_tec) / np.mean(y_cap_tec) if np.mean(y_cap_tec) > 0 else 0

            if crecimiento_tecnologico and crecimiento_innovacion:
                tipo_trayectoria = 'Acelerada'
            elif crecimiento_tecnologico or crecimiento_innovacion:
                tipo_trayectoria = 'Moderada'
            else:
                tipo_trayectoria = 'Estancada'

            trayectorias_tecnologicas.append({
                'id_region': region_id,
                'tipologia': tipologia,
                'slope_capacidad_tecnologica': slope_cap,
                'r2_capacidad_tecnologica': r_cap**2,
                'p_value_capacidad_tecnologica': p_cap,
                'slope_tasa_innovacion': slope_innov,
                'r2_tasa_innovacion': r_innov**2,
                'p_value_tasa_innovacion': p_innov,
                'slope_actualizacion_tecnologica': slope_act,
                'r2_actualizacion_tecnologica': r_act**2,
                'p_value_actualizacion_tecnologica': p_act,
                'volatilidad_tecnologica': volatilidad_tecnologica,
                'tipo_trayectoria': tipo_trayectoria,
                'capacidad_inicial': y_cap_tec[0],
                'capacidad_final': y_cap_tec[-1],
                'cambio_absoluto_tecnologia': y_cap_tec[-1] - y_cap_tec[0],
                'tasa_crecimiento_promedio': slope_cap * 100
            })

    df_trayectorias = pd.DataFrame(trayectorias_tecnologicas)

    # =============================================
    # 2. ÍNDICES DE MADUREZ TECNOLÓGICA COMPUESTOS
    # =============================================

    # Crear índice compuesto de madurez tecnológica
    def calcular_indice_madurez(row):
        """Índice compuesto de 0-1 basado en múltiples variables tecnológicas"""
        capacidad_norm = min(1.0, row['capacidad_tecnologica'] / 1.5)  # Normalizar
        innovacion_norm = min(1.0, row['tasa_innovacion'] / 0.20)     # Normalizar
        actualizacion_norm = min(1.0, row['actualizacion_tecnologica'] / 0.10)  # Normalizar
        productividad_norm = min(1.0, row['productividad_promedio'] / 1.0)     # Normalizar

        # Índice ponderado
        indice = (0.35 * capacidad_norm + 0.25 * innovacion_norm +
                 0.25 * actualizacion_norm + 0.15 * productividad_norm)
        return min(1.0, indice)

    resultados_tecnologia['indice_madurez_tecnologica'] = resultados_tecnologia.apply(
        calcular_indice_madurez, axis=1
    )

    # Calcular evolución del índice de madurez por región
    madurez_temporal = []
    for region_id in resultados_tecnologia['id_region'].unique():
        datos_region = resultados_tecnologia[resultados_tecnologia['id_region'] == region_id]
        tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

        madurez_inicial = datos_region['indice_madurez_tecnologica'].iloc[0]
        madurez_final = datos_region['indice_madurez_tecnologica'].iloc[-1]

        madurez_temporal.append({
            'id_region': region_id,
            'tipologia': tipologia,
            'madurez_inicial': madurez_inicial,
            'madurez_final': madurez_final,
            'mejora_madurez': madurez_final - madurez_inicial,
            'tasa_mejora_madurez': ((madurez_final - madurez_inicial) / max(0.01, madurez_inicial)) * 100
        })

    df_madurez_temporal = pd.DataFrame(madurez_temporal)

    # =============================================
    # 3. ANÁLISIS DE CONVERGENCIA TECNOLÓGICA
    # =============================================

    convergencia_tecnologica = []

    for tipologia in resultados_tecnologia['tipo_region_economica_inicial'].unique():
        datos_tipologia = resultados_tecnologia[resultados_tecnologia['tipo_region_economica_inicial'] == tipologia]

        for paso in datos_tipologia['paso_tiempo'].unique():
            datos_paso = datos_tipologia[datos_tipologia['paso_tiempo'] == paso]

            # Calcular coeficiente de variación (brecha relativa)
            cv_capacidad = datos_paso['capacidad_tecnologica'].std() / datos_paso['capacidad_tecnologica'].mean() if datos_paso['capacidad_tecnologica'].mean() > 0 else 0
            cv_innovacion = datos_paso['tasa_innovacion'].std() / datos_paso['tasa_innovacion'].mean() if datos_paso['tasa_innovacion'].mean() > 0 else 0
            cv_madurez = datos_paso['indice_madurez_tecnologica'].std() / datos_paso['indice_madurez_tecnologica'].mean() if datos_paso['indice_madurez_tecnologica'].mean() > 0 else 0

            convergencia_tecnologica.append({
                'tipologia': tipologia,
                'paso_tiempo': paso,
                'cv_capacidad_tecnologica': cv_capacidad,
                'cv_tasa_innovacion': cv_innovacion,
                'cv_indice_madurez': cv_madurez,
                'num_regiones': len(datos_paso)
            })

    df_convergencia = pd.DataFrame(convergencia_tecnologica)

    # =============================================
    # 4. ANÁLISIS DE SPILLOVERS TECNOLÓGICOS
    # =============================================

    spillovers_tecnologicos = []

    # Optimización: Pre-calcular datos para evitar cálculos repetitivos
    regiones_unicas = resultados_tecnologia['id_region'].unique()
    datos_regionales = {}

    for region_id in regiones_unicas:
        datos_region = resultados_tecnologia[resultados_tecnologia['id_region'] == region_id].sort_values('paso_tiempo')
        datos_regionales[region_id] = {
            'datos': datos_region,
            'tipologia': datos_region['tipo_region_economica_inicial'].iloc[0],
            'len': len(datos_region)
        }

    # Análisis mejorado de spillovers con validaciones robustas
    for i, region_a in enumerate(regiones_unicas):
        datos_a_info = datos_regionales[region_a]
        datos_a = datos_a_info['datos']
        tipologia_a = datos_a_info['tipologia']

        for j, region_b in enumerate(regiones_unicas):
            if i != j:
                datos_b_info = datos_regionales[region_b]
                datos_b = datos_b_info['datos']
                tipologia_b = datos_b_info['tipologia']

                # Solo analizar spillovers entre regiones de diferente tipología
                if tipologia_a != tipologia_b:
                    # Validaciones robustas para correlaciones
                    if datos_a_info['len'] == datos_b_info['len'] and datos_a_info['len'] > 3:
                        # Verificar que hay variación en los datos
                        var_cap_a = datos_a['capacidad_tecnologica'].var()
                        var_cap_b = datos_b['capacidad_tecnologica'].var()
                        var_innov_a = datos_a['tasa_innovacion'].var()
                        var_innov_b = datos_b['tasa_innovacion'].var()

                        if var_cap_a > 0 and var_cap_b > 0 and var_innov_a > 0 and var_innov_b > 0:
                            corr_capacidad = datos_a['capacidad_tecnologica'].corr(datos_b['capacidad_tecnologica'])
                            corr_innovacion = datos_a['tasa_innovacion'].corr(datos_b['tasa_innovacion'])

                            # Validación mejorada de correlaciones
                            if not (np.isnan(corr_capacidad) or np.isnan(corr_innovacion)):
                                # Calcular intensidad con ponderación
                                intensidad_spillover = (
                                    0.4 * abs(corr_capacidad) +
                                    0.3 * abs(corr_innovacion) +
                                    0.3 * (abs(corr_capacidad) + abs(corr_innovacion)) / 2
                                )

                                spillovers_tecnologicos.append({
                                    'region_origen': region_a,
                                    'tipologia_origen': tipologia_a,
                                    'region_destino': region_b,
                                    'tipologia_destino': tipologia_b,
                                    'correlacion_capacidad': corr_capacidad,
                                    'correlacion_innovacion': corr_innovacion,
                                    'intensidad_spillover': intensidad_spillover,
                                    'variacion_capacidad_origen': var_cap_a,
                                    'variacion_capacidad_destino': var_cap_b
                                })

    df_spillovers = pd.DataFrame(spillovers_tecnologicos)

    # Añadir métricas adicionales de spillovers
    if not df_spillovers.empty:
        # Calcular estadísticas de spillovers por tipología
        spillovers_por_tipologia = df_spillovers.groupby(['tipologia_origen', 'tipologia_destino']).agg({
            'intensidad_spillover': ['mean', 'std', 'count'],
            'correlacion_capacidad': 'mean',
            'correlacion_innovacion': 'mean'
        }).round(4)

        print(f"✓ Métricas de spillovers generadas: {len(df_spillovers)} interacciones detectadas")

    # =============================================
    # 5. CLASIFICACIÓN DE TIPOS DE CAMBIO TÉCNICO
    # =============================================

    clasificacion_cambio = []

    for region_id in resultados_tecnologia['id_region'].unique():
        datos_region = resultados_tecnologia[resultados_tecnologia['id_region'] == region_id].copy()
        datos_region = datos_region.sort_values('paso_tiempo')

        if len(datos_region) > 5:
            tipologia = datos_region['tipo_region_economica_inicial'].iloc[0]

            # Calcular métricas de cambio
            capacidad_inicial = datos_region['capacidad_tecnologica'].iloc[0]
            capacidad_final = datos_region['capacidad_tecnologica'].iloc[-1]
            capacidad_maxima = datos_region['capacidad_tecnologica'].max()

            cambio_absoluto = capacidad_final - capacidad_inicial
            cambio_relativo = cambio_absoluto / max(0.01, capacidad_inicial)

            # Detectar saltos tecnológicos (cambios abruptos)
            diferencias = np.diff(datos_region['capacidad_tecnologica'])
            salto_maximo = np.max(np.abs(diferencias))

            # Clasificar tipo de cambio
            if cambio_relativo > 0.5 and salto_maximo > 0.1:
                tipo_cambio = 'Disruptivo'
            elif cambio_relativo > 0.2 or salto_maximo > 0.05:
                tipo_cambio = 'Radical'
            elif cambio_relativo > 0.05:
                tipo_cambio = 'Incremental'
            else:
                tipo_cambio = 'Estable'

            # Evaluar consistencia del cambio
            tendencia_positiva = np.sum(diferencias > 0) / len(diferencias)

            clasificacion_cambio.append({
                'id_region': region_id,
                'tipologia': tipologia,
                'cambio_absoluto': cambio_absoluto,
                'cambio_relativo': cambio_relativo,
                'salto_maximo': salto_maximo,
                'tipo_cambio_tecnico': tipo_cambio,
                'consistencia_tendencia': tendencia_positiva,
                'capacit_inicial': capacidad_inicial,
                'capacidad_final': capacidad_final,
                'capacidad_maxima': capacidad_maxima
            })

    df_clasificacion_cambio = pd.DataFrame(clasificacion_cambio)

    # =============================================
    # 6. VISUALIZACIÓN INTEGRAL
    # =============================================

    # Crear figura principal con múltiples paneles
    fig, axes = plt.subplots(3, 2, figsize=(24, 16))
    # Título más corto para evitar solapamiento
    fig.suptitle('Evolución del cambio técnico: Análisis integral\n' +
                'Trayectorias · Madurez · Convergencia · Derramas · Clasificación',
                fontsize=16, fontweight='bold', y=0.95)

    # Panel 1: Distribución de tipos de trayectoria
    if not df_trayectorias.empty:
        conteo_trayectorias = df_trayectorias['tipo_trayectoria'].value_counts()
        if not conteo_trayectorias.empty:
            # Colores optimizados y etiquetas más cortas
            colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4']
            wedges, texts, autotexts = axes[0,0].pie(conteo_trayectorias.values,
                                                    labels=conteo_trayectorias.index,
                                                    autopct='%1.1f%%',
                                                    startangle=90,
                                                    colors=colors[:len(conteo_trayectorias)],
                                                    textprops={'fontsize': 9})
            # Título más corto
            axes[0,0].set_title('Distribución trayectorias\ntecnológicas', fontweight='bold', fontsize=11)
        else:
            axes[0,0].text(0.5, 0.5, 'Sin trayectorias\nválidas', ha='center', va='center',
                          transform=axes[0,0].transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
            axes[0,0].set_title('Distribución de trayectorias\ntecnológicas (Sin datos)', fontweight='bold')
    else:
        axes[0,0].text(0.5, 0.5, 'Sin datos de\ntrayectorias', ha='center', va='center',
                      transform=axes[0,0].transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightblue'))
        axes[0,0].set_title('Distribución de trayectorias\ntecnológicas (Sin datos)', fontweight='bold')

    # Panel 2: Evolución del índice de madurez tecnológica
    if not df_madurez_temporal.empty:
        try:
            for tipologia in df_madurez_temporal['tipologia'].unique():
                datos_tip = df_madurez_temporal[df_madurez_temporal['tipologia'] == tipologia]
                if not datos_tip.empty:
                    axes[0,1].scatter(datos_tip['madurez_inicial'], datos_tip['madurez_final'],
                                    label=tipologia, alpha=0.7, s=60)

            # Línea de referencia (sin cambio)
            min_mad = min(df_madurez_temporal['madurez_inicial'].min(), df_madurez_temporal['madurez_final'].min())
            max_mad = max(df_madurez_temporal['madurez_inicial'].max(), df_madurez_temporal['madurez_final'].max())
            if not np.isnan(min_mad) and not np.isnan(max_mad):
                axes[0,1].plot([min_mad, max_mad], [min_mad, max_mad], 'k--', alpha=0.5, label='Sin cambio')
            axes[0,1].set_xlabel('Madurez inicial')
            axes[0,1].set_ylabel('Madurez final')
            axes[0,1].set_title('Evolución de la madurez\ntecnológica por tipología', fontweight='bold')
            axes[0,1].legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        except Exception as e:
            axes[0,1].text(0.5, 0.5, f'Error en madurez: {str(e)[:30]}', ha='center', va='center',
                          transform=axes[0,1].transAxes, fontsize=12, bbox=dict(boxstyle='round', facecolor='lightyellow'))
            axes[0,1].set_title('Evolución de la madurez\ntecnológica (Error)', fontweight='bold')
    else:
        axes[0,1].text(0.5, 0.5, 'Sin datos de\nmadurez tecnológica', ha='center', va='center',
                      transform=axes[0,1].transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightblue'))
        axes[0,1].set_title('Evolución de la madurez\ntecnológica (Sin datos)', fontweight='bold')

    # Panel 3: Convergencia tecnológica por tipología
    if not df_convergencia.empty:
        for tipologia in df_convergencia['tipologia'].unique():
            datos_conv = df_convergencia[df_convergencia['tipologia'] == tipologia]
            axes[1,0].plot(datos_conv['paso_tiempo'], datos_conv['cv_capacidad_tecnologica'],
                          marker='o', label=tipologia, linewidth=2)
        axes[1,0].set_xlabel('Paso de tiempo')
        axes[1,0].set_ylabel('Coeficiente de variación\n(Capacidad tecnológica)')
        axes[1,0].set_title('Convergencia Tecnológica\nEntre regiones del mismo tipo', fontweight='bold')
        axes[1,0].legend()
        axes[1,0].grid(True, alpha=0.3)

    # Panel 4: Heatmap de spillovers entre tipologías
    if not df_spillovers.empty:
        # Crear matriz de spillovers promedio por par de tipologías
        tipologias = sorted(df_spillovers['tipologia_origen'].unique())
        matriz_spillover = np.zeros((len(tipologias), len(tipologias)))

        for i, tip_a in enumerate(tipologias):
            for j, tip_b in enumerate(tipologias):
                if i != j:
                    spillovers_ab = df_spillovers[
                        (df_spillovers['tipologia_origen'] == tip_a) &
                        (df_spillovers['tipologia_destino'] == tip_b)
                    ]['intensidad_spillover']

                    if len(spillovers_ab) > 0:
                        matriz_spillover[i,j] = spillovers_ab.mean()

        if matriz_spillover.sum() > 0:
            im = axes[1,1].imshow(matriz_spillover, cmap='YlOrRd', aspect='auto')
            axes[1,1].set_xticks(range(len(tipologias)))
            axes[1,1].set_yticks(range(len(tipologias)))
            axes[1,1].set_xticklabels(tipologias, rotation=45, ha='right')
            axes[1,1].set_yticklabels(tipologias)
            axes[1,1].set_title('Intensidad de derramas\ntecnológicos entre tipologías', fontweight='bold')

            # Añadir valores en las celdas
            for i in range(len(tipologias)):
                for j in range(len(tipologias)):
                    if matriz_spillover[i,j] > 0:
                        axes[1,1].text(j, i, f'{matriz_spillover[i,j]:.3f}',
                                     ha='center', va='center', color='black', fontweight='bold')

            plt.colorbar(im, ax=axes[1,1], shrink=0.8)

    # Panel 5: Distribución de tipos de cambio técnico
    if not df_clasificacion_cambio.empty:
        conteo_cambios = df_clasificacion_cambio['tipo_cambio_tecnico'].value_counts()
        colores_cambio = {'Estable': '#ffcccc', 'Incremental': '#ffffcc', 'Radical': '#ccffcc', 'Disruptivo': '#ccccff'}
        colores_ordenados = [colores_cambio.get(tipo, '#cccccc') for tipo in conteo_cambios.index]

        axes[2,0].bar(conteo_cambios.index, conteo_cambios.values, color=colores_ordenados)
        axes[2,0].set_title('Distribución de tipos de\ncambio técnico', fontweight='bold')
        axes[2,0].set_ylabel('Número de regiones')

        # Añadir valores en las barras
        for i, v in enumerate(conteo_cambios.values):
            axes[2,0].text(i, v + 0.1, str(v), ha='center', va='bottom', fontweight='bold')

    # Panel 6: Relación entre cambio tecnológico y productividad
    if not df_clasificacion_cambio.empty:
        try:
            # Obtener datos de productividad por región
            productividad_promedio = resultados.groupby('id_region')['productividad_promedio'].mean()

            df_grafico = df_clasificacion_cambio.copy()
            df_grafico['productividad_promedio'] = df_grafico['id_region'].map(productividad_promedio)

            # Filtrar datos inválidos
            df_grafico = df_grafico.dropna(subset=['cambio_relativo', 'productividad_promedio'])

            if not df_grafico.empty:
                for tipo in df_grafico['tipo_cambio_tecnico'].unique():
                    datos_tipo = df_grafico[df_grafico['tipo_cambio_tecnico'] == tipo]
                    if not datos_tipo.empty:
                        axes[2,1].scatter(datos_tipo['cambio_relativo'], datos_tipo['productividad_promedio'],
                                        label=tipo, alpha=0.7, s=60, color=colores_cambio.get(tipo, '#cccccc'))

                axes[2,1].set_xlabel('Cambio tecnológico relativo')
                axes[2,1].set_ylabel('Productividad promedio')
                axes[2,1].set_title('Cambio técnico vs\nproductividad por región', fontweight='bold')
                axes[2,1].legend()
                axes[2,1].grid(True, alpha=0.3)
            else:
                axes[2,1].text(0.5, 0.5, 'No hay datos válidos\npara scatter plot', ha='center', va='center',
                              transform=axes[2,1].transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightgray'))
                axes[2,1].set_title('Cambio técnico vs\nproductividad por región\n(Datos no disponibles)', fontweight='bold')
        except Exception as e:
            axes[2,1].text(0.5, 0.5, f'Error en datos: {str(e)[:30]}', ha='center', va='center',
                          transform=axes[2,1].transAxes, fontsize=12, bbox=dict(boxstyle='round', facecolor='lightyellow'))
            axes[2,1].set_title('Cambio técnico vs\nproductividad por región\n(Error)', fontweight='bold')
    else:
        axes[2,1].text(0.5, 0.5, 'No hay datos de\nclasificación de cambio', ha='center', va='center',
                      transform=axes[2,1].transAxes, fontsize=14, bbox=dict(boxstyle='round', facecolor='lightblue'))
        axes[2,1].set_title('Cambio técnico vs\nproductividad por región\n(Datos no disponibles)', fontweight='bold')

    plt.tight_layout()
    plt.savefig(os.path.join(save_path, '22_evolucion_cambio_tecnico.png'),
                dpi=300, bbox_inches='tight')
    plt.close()

    # =============================================
    # 7. GUARDAR RESULTADOS
    # =============================================

    # Guardar todas las tablas de análisis
    df_trayectorias.to_csv(os.path.join(save_path, 'trayectorias_tecnologicas.csv'), index=False)
    df_madurez_temporal.to_csv(os.path.join(save_path, 'evolucion_madurez_tecnologica.csv'), index=False)
    df_convergencia.to_csv(os.path.join(save_path, 'convergencia_tecnologica.csv'), index=False)
    df_spillovers.to_csv(os.path.join(save_path, 'spillovers_tecnologicos.csv'), index=False)
    df_clasificacion_cambio.to_csv(os.path.join(save_path, 'clasificacion_cambio_tecnico.csv'), index=False)

    # Crear resumen ejecutivo
    resumen_evolucion = {
        'numero_regiones_analizadas': len(df_trayectorias),
        'trayectorias_aceleradas': len(df_trayectorias[df_trayectorias['tipo_trayectoria'] == 'Acelerada']),
        'trayectorias_moderadas': len(df_trayectorias[df_trayectorias['tipo_trayectoria'] == 'Moderada']),
        'trayectorias_estancadas': len(df_trayectorias[df_trayectorias['tipo_trayectoria'] == 'Estancada']),
        'cambio_disruptivo': len(df_clasificacion_cambio[df_clasificacion_cambio['tipo_cambio_tecnico'] == 'Disruptivo']),
        'cambio_radical': len(df_clasificacion_cambio[df_clasificacion_cambio['tipo_cambio_tecnico'] == 'Radical']),
        'cambio_incremental': len(df_clasificacion_cambio[df_clasificacion_cambio['tipo_cambio_tecnico'] == 'Incremental']),
        'cambio_estable': len(df_clasificacion_cambio[df_clasificacion_cambio['tipo_cambio_tecnico'] == 'Estable']),
        'spillovers_detectados': len(df_spillovers),
        'mejora_promedio_madurez': df_madurez_temporal['mejora_madurez'].mean() if not df_madurez_temporal.empty else 0,
        'convergencia_promedio_final': df_convergencia.groupby('tipologia')['cv_capacidad_tecnologica'].last().mean() if not df_convergencia.empty else 0
    }

    pd.DataFrame([resumen_evolucion]).to_csv(os.path.join(save_path, 'resumen_evolucion_cambio_tecnico.csv'), index=False)

    # =============================================
    # 8. IMPRIMIR RESULTADOS
    # =============================================

    print(f"✓ Análisis de evolución del cambio técnico completado")
    print(f"  - Trayectorias tecnológicas: {len(df_trayectorias)} regiones")
    print(f"  - Madurez tecnológica: {len(df_madurez_temporal)} regiones temporales")
    print(f"  - Convergencia tecnológica: {len(df_convergencia)} observaciones por tipología")
    print(f"  - Spillovers tecnológicos: {len(df_spillovers)} interacciones detectadas")
    print(f"  - Clasificación de cambio: {len(df_clasificacion_cambio)} regiones clasificadas")

    return {
        'trayectorias': df_trayectorias,
        'madurez': df_madurez_temporal,
        'convergencia': df_convergencia,
        'spillovers': df_spillovers,
        'clasificacion': df_clasificacion_cambio,
        'resumen': resumen_evolucion
    }

"""# ***Ejecución***"""

if __name__ == "__main__":
    # Uso simple de la distribución de trabajadores
    print("Creando pool de trabajadores con distribución optimizada...")

    # Crear pool con los nuevos porcentajes: 60% servicios, 30% industria, 10% primario
    pool_trabajadores = DistribucionTrabajadores.crear_pool_trabajadores(tamaño_pool=2260000)

    print(f"Pool creado con {len(pool_trabajadores):,} trabajadores")
    print("Distribución aplicada:")
    print("• Sector Terciario (Servicios): 60%")
    print("• Sector Secundario (Industrial): 30%")
    print("• Sector Primario (Agropecuario): 10%")

    # Ejecutar análisis del modelo
    print("\nEjecutando análisis del modelo económico...")
    modelo, resultados, resumen = ejecutar_analisis_completo()

    # Mostrar resumen final
    print("\n=== ANÁLISIS COMPLETADO ===")
    print(f"Regiones simuladas: {len(resultados)}")
    print(f"Pasos de simulación: {len(resumen)}")
    print("Distribución de trabajadores integrada exitosamente.")

# Configurar directorio de salida
    save_path = '/content/drive/MyDrive/modelo_economico_resultados'
    os.makedirs(save_path, exist_ok=True)

 # Guardar datos
    resultados.to_csv(os.path.join(save_path, 'resultados_abm_tipologico.csv'), index=False)
    resumen.to_csv(os.path.join(save_path, 'resumen_abm_tipologico.csv'), index=False)
     # Guardar resultados
    resultados.to_csv(os.path.join(save_path, 'resultados_modelo_economico.csv'), index=False)
    resumen.to_csv(os.path.join(save_path, 'resumen_modelo_economico.csv'), index=False)

# Crear visualizaciones optimizadas por clase y categorías
    print("\nGenerando visualizaciones optimizadas por clase y categorías...")
    crear_visualizaciones_optimizadas_por_clase(resultados, save_path)
    print("✓ Visualizaciones optimizadas generadas")

    # Crear gráficos de correlación optimizados
    print("\nGenerando gráficos de correlación optimizados...")
    crear_graficos_correlacion_optimizados(resultados, save_path)
    print("✓ Gráficos de correlación optimizados guardados")

    # Evaluar procesos emergentes optimizados
    print("\nEvaluando procesos emergentes optimizados y dinámicas de capital humano...")
    evaluar_procesos_emergentes_optimizados(resultados, save_path)
    print("✓ Procesos emergentes optimizados evaluados")

    # Analizar evolución del cambio técnico
    print("\nAnalizando evolución del cambio técnico...")
    analisis_cambio_tecnico = analizar_evolucion_cambio_tecnico(resultados, save_path)
    print("✓ Evolución del cambio técnico analizada")

    # Analizar trampa de innovación en mercado laboral
    print("\nAnalizando trampa de innovación del mercado laboral...")
    analisis_trampa_laboral = analizar_trampa_innovacion_mercado_laboral(resultados, save_path)
    print("✓ Trampa de innovación del mercado laboral analizada")

    # Crear tabla resumen tipológico
    print("\nGenerando tabla resumen tipológico...")
    tabla_tipologica = crear_tabla_resumen_tipologico(resultados, save_path)
    print("✓ Tabla resumen tipológico guardada")