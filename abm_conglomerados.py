# -*- coding: utf-8 -*-
"""abm_conglomerados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CdRktmPZfk7r5MQdL9Zhq6G3xRhZu4-5
"""

!pip install scikit-learn seaborn matplotlib pandas numpy fpdf -q SALib
!ls -la

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
import os
from collections import defaultdict
from matplotlib.gridspec import GridSpec
from fpdf import FPDF
from datetime import datetime
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from google.colab import files
from SALib.analyze import sobol
from SALib.sample import saltelli

# === SEMILLA PARA REPRODUCIBILIDAD ===
SEED = 56
random.seed(SEED)
np.random.seed(SEED)

# === DEFINICIÓN DE ZONAS GEOGRÁFICAS ===
ZONAS_GEOGRAFICAS = {
    'norte': {
        'nombre': 'Norte',
        'descripcion': 'Mayor desarrollo económico, cercanía comercial con EE.UU., clima árido/semiárido',
        'tech_inicial_mult': 1.3,
        'acceso_mercado': 0.9,
        'riqueza_natural': 0.4,
        'diversidad_cultural': 0.3,
        'inversion_extranjera': 0.8,
        'infraestructura': 0.85
    },
    'sur_sureste': {
        'nombre': 'Sur/Sureste',
        'descripcion': 'Mayor rezago social, riqueza natural y cultural, pueblos indígenas, selvas húmidas',
        'tech_inicial_mult': 0.7,
        'acceso_mercado': 0.5,
        'riqueza_natural': 0.9,
        'diversidad_cultural': 0.9,
        'inversion_extranjera': 0.3,
        'infraestructura': 0.5
    },
    'occidente': {
        'nombre': 'Occidente',
        'descripcion': 'Características geográficas y dinámicas económicas intermedias',
        'tech_inicial_mult': 1.0,
        'acceso_mercado': 0.7,
        'riqueza_natural': 0.6,
        'diversidad_cultural': 0.5,
        'inversion_extranjera': 0.5,
        'infraestructura': 0.7
    },
    'oriente': {
        'nombre': 'Oriente',
        'descripcion': 'Características geográficas y dinámicas económicas intermedias',
        'tech_inicial_mult': 1.0,
        'acceso_mercado': 0.6,
        'riqueza_natural': 0.7,
        'diversidad_cultural': 0.6,
        'inversion_extranjera': 0.4,
        'infraestructura': 0.65
    }
}

# Implementación del coeficiente Gini
def gini_coefficient(x):
    """Coeficiente de Gini"""
    x = np.abs(x)
    x = np.sort(x)
    n = len(x)
    cumx = np.cumsum(x)
    return (n + 1 - 2 * np.sum(cumx) / cumx[-1]) / n

# Parámetros globales
INITIAL_TECH = 0.1  # Nivel tecnológico inicial
PROFIT_MARGIN_IMPACT = 0.68  # Impacto en la inversión tecnológica (ajustado por menor sensibilidad a utilidades en algunos contextos)
TECH_DEVELOPMENT_COST = 0.25  # Costo de desarrollo tecnológico (por costos burocráticos e inseguridad)
INITIAL_WORKFORCE_SKILL = 0.28  # Habilidad inicial de la fuerza laboral
EDUCATION_INVESTMENT_RATE = 0.04  # Tasa de inversión en educación (Aumentado del 0.03 oficial por esfuerzos de capacitación)
INNOVATION_BASE_RATE = 0.01  # Tasa base de innovación
MIN_INNOVATION_THRESHOLD = 0.05  # Umbral mínimo de tecnología para innovar significativamente
KNOWLEDGE_SPILLOVER = 0.09  # Efecto de derrame de conocimiento (Bajo por desconexión entre sectores)
INNOVATION_ACCELERATION = 0.02  # Aceleración de la innovación con el tiempo/experiencia
WORKER_POOL_SIZE = 10000000
PRODUCTIVITY_BASE_VARIABILITY = 0.15 # Variabilidad base de la productividad
LEARNING_RATE = 0.06 # Tasa de aprendizaje para mejora de habilidades
TECH_PRODUCTIVITY_IMPACT = 0.45 # Impacto de la tecnología en la productividad
WORKFORCE_PRODUCTIVITY_IMPACT = 0.6 # Impacto de las habilidades de la fuerza laboral en la productividad
SECTOR_CHANGE_BASE_RATE = 0.02 # Tasa base de cambio de sector económico para una región
KNOWLEDGE_INTENSITY_THRESHOLD = 0.3 # Umbral de intensidad de conocimiento para ciertas dinámicas
SECTOR_RELATEDNESS_THRESHOLD = 0.2 # Umbral de relación entre sectores para facilitar cambios
EMPLOYMENT_BASE_VOLATILITY = 0.06 # Volatilidad base del empleo
SKILL_MISMATCH_PENALTY = 0.38 # Penalización por desajuste de habilidades
TECH_EMPLOYMENT_IMPACT = 0.5 # Impacto de la tecnología en la demanda de empleo
ECONOMIC_CYCLE_LENGTH = 6 # Duración del ciclo económico (en pasos de simulación)
DIVERSITY_INNOVATION_BONUS = 0.1 # Bonus a la innovación por diversidad sectorial
DIVERSITY_SHOCK_RESILIENCE = 0.8 # Resiliencia a shocks aumentada por diversidad
MIN_DIVERSITY_FOR_CHANGE = 0.4 # Diversidad mínima para facilitar ciertos cambios estructurales
DIVERSITY_DYNAMICS = { # Parámetros para la dinámica de la diversidad
    'base_rate': 0.05,
    'tech_influence': 0.3,
    'mobility_factor': 0.2,
    'min_variation': 0.1
}
ABSORPTION_CAPACITY_FACTOR = 0.1  # Influencia de habilidades/tecnología en la capacidad de absorción de conocimiento externo
POLICY_SUPPORT_INNOVATION = 0.07  # Multiplicador base para apoyo de políticas a la innovación (puede variar en escenarios)
FDI_ATTRACTIVENESS_FACTOR = 0.15  # Influencia en spillovers basado en tecnología/margen para atraer Inversión Extranjera Directa
PRIVATE_RD_PROPENSITY = 0.05  # Propensión base a invertir en I+D privado
TRAP_ESCAPE_PROBABILITY = 0.03  # Probabilidad base de escapar de la trampa de bajo desarrollo si mejoran condiciones
SKILL_GAP_INNOVATION_PENALTY = 0.66  # Penalización a la innovación por brecha de habilidades (Ajustado por informalidad)

# Sectores económicos:
SECTORS = {
    1: "Agricultura Tradicional",
    2: "Agricultura Tecnificada",
    3: "Minería Básica",
    4: "Minería Tecnológica",
    5: "Manufactura Básica",
    6: "Manufactura Avanzada",
    7: "Servicios Básicos",
    8: "Servicios Financieros",
    9: "Servicios Tecnológicos",
    10: "Turismo Masivo",
    11: "Turismo Especializado"
}

# Distribución de sectores económicos
SECTOR_DISTRIBUTION = {
    'Agricultura Tradicional': 0.103,
    'Agricultura Tecnificada': 0.025,
    'Minería Básica': 0.005,
    'Minería Tecnológica': 0.002,
    'Manufactura Básica': 0.15,
    'Manufactura Avanzada': 0.097,
    'Servicios Básicos': 0.402,
    'Servicios Financieros': 0.031,
    'Servicios Tecnológicos': 0.048,
    'Turismo Masivo': 0.068,
    'Turismo Especializado': 0.030
}

INNOVATION_FACTOR = {k: v for k, v in zip(
    SECTOR_DISTRIBUTION.keys(),
    [0.1, 0.7, 0.3, 0.8, 0.4, 0.9, 0.2, 0.6, 0.95, 0.3, 0.6]
)}

PRODUCTIVITY_FACTOR = {k: v for k, v in zip(
    SECTOR_DISTRIBUTION.keys(),
    [0.3, 0.8, 0.5, 0.9, 0.6, 0.85, 0.4, 0.7, 0.9, 0.5, 0.8]
)}

# Perfil de sectores por tipo y nivel tecnológico
SECTOR_TYPES = {
    'Primario_Bajo': [1, 3],
    'Primario_Alto': [2, 4],
    'Manufactura_Baja': [5],
    'Manufactura_Alta': [6],
    'Servicios_Bajos': [7],
    'Servicios_Intermedios': [8],
    'Servicios_Avanzados': [9],
    'Turismo_Masivo': [10],
    'Turismo_Especializado': [11]
}

# Parámetros detallados por tipo de sector
SECTOR_PARAMS = {
    'Primario_Bajo': {
        'margin_range': (0.25, 0.45),
        'tech_invest': 0.05,
        'volatility': 0.35,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.7, 0.8),
        'training_investment': 0.05,
        'innovation_capacity': 0.1,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.75,
        'productivity': 3.8, # USD/hora
        'product_range': (3, 7),
        'max_employment': 1
    },
    'Primario_Alto': {
        'margin_range': (0.35, 0.55),
        'tech_invest': 0.25,
        'volatility': 0.25,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.75, 0.85),
        'training_investment': 0.15,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.66,
        'productivity': 9.2,
        'product_range': (5, 9),
        'max_employment': 1
    },
    'Manufactura_Baja': {
        'margin_range': (0.15, 0.3),
        'tech_invest': 0.2,
        'volatility': 0.2,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.85),
        'training_investment': 0.1,
        'innovation_capacity': 0.25,
        'knowledge_intensity': 0.35,
        'linkages': 0.6,
        'specialization_coeff': 0.58,
        'productivity': 8.7,
        'product_range': (6, 10),
        'max_employment': 1
    },
    'Manufactura_Alta': {
        'margin_range': (0.25, 0.4),
        'tech_invest': 0.4,
        'volatility': 0.15,
        'skill_requirements': (0.6, 0.8),
        'employment_rate': (0.8, 0.9),
        'training_investment': 0.2,
        'innovation_capacity': 0.5,
        'knowledge_intensity': 0.7,
        'linkages': 0.8,
        'specialization_coeff': 0.45,
        'productivity': 32.5,
        'product_range': (8, 18),
        'max_employment': 1
    },
    'Servicios_Bajos': {
        'margin_range': (0.2, 0.4),
        'tech_invest': 0.1,
        'volatility': 0.15,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.75, 0.9),
        'training_investment': 0.08,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.3,
        'linkages': 0.4,
        'specialization_coeff': 0.35,
        'productivity': 5.2,
        'product_range': (4, 8),
        'max_employment': 1
    },
    'Servicios_Intermedios': {
        'margin_range': (0.3, 0.5),
        'tech_invest': 0.25,
        'volatility': 0.1,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.8, 0.95),
        'training_investment': 0.15,
        'innovation_capacity': 0.35,
        'knowledge_intensity': 0.5,
        'linkages': 0.7,
        'specialization_coeff': 0.25,
        'productivity': 38.7,
        'product_range': (7, 11),
        'max_employment': 1
    },
    'Servicios_Avanzados': {
        'margin_range': (0.4, 0.65),
        'tech_invest': 0.45,
        'volatility': 0.1,
        'skill_requirements': (0.7, 0.9),
        'employment_rate': (0.85, 0.8),
        'training_investment': 0.25,
        'innovation_capacity': 0.7,
        'knowledge_intensity': 0.9,
        'linkages': 0.9,
        'specialization_coeff': 0.18,
        'productivity': 48.9,
        'product_range': (10, 21),
        'max_employment': 1
    },
    'Turismo_Masivo': {
        'margin_range': (0.2, 0.5),
        'tech_invest': 0.05,
        'volatility': 0.4,
        'skill_requirements': (0.2, 0.4),
        'employment_rate': (0.6, 0.9),
        'training_investment': 0.03,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.85,
        'productivity': 6.5,
        'product_range': (3, 7),
        'max_employment': 1
    },
    'Turismo_Especializado': {
        'margin_range': (0.3, 0.6),
        'tech_invest': 0.15,
        'volatility': 0.3,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.9),
        'training_investment': 0.1,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.65,
        'productivity': 12.8,
        'product_range': (5, 9),
        'max_employment': 1
    }
}

# Parámetros para las aglomeraciones regionales
AGGLOMERATION_PARAMS = {
    'C1': {
        'description': 'Baja diversidad-especialización',
        'initial_specialization': (0.80, 1),
        'final_labor_intensity': 4,
        'initial_tech_capability': 0.1, # CT básicas
        'tech_decay_rate': 0.01, # Decrecen entre periodos
        'diversity_level': 'low',
        'tech_inertia': 0.95
    },
    'C2': {
        'description': 'Media diversidad-especialización',
        'initial_specialization': 1.09,
        'diversity_level': 'medium',
        'initial_tech_capability': 0.1, # Niveles muy similares de CT que C1
        'tech_decay_rate': 0.015, # Decrecen entre periodos
        'labor_intensity_factor': 4.5, # Mayor intensidad laboral que C1
        'tech_inertia': 0.85
    },
    'C3': {
        'description': 'Alta diversidad-especialización',
        'initial_specialization': 1.3,
        'diversity_level': 'high',
        'initial_tech_capability': 0.15, # CT ligeramente mayores
        'tech_decay_rate': 0.01, # Se ven mermadas entre periodos
        'labor_intensity_factor': 3.5, # Menor intensidad laboral que C2
        'tech_inertia': 0.75
    },
    'C4': {
        'description': 'Sobre especialización',
        'initial_specialization': 1.5,
        'diversity_level': 'high',
        'initial_tech_capability': 0.15, # CT ligeramente superiores
        'tech_decay_rate': 0.02, # Igual patrón decreciente
        'labor_intensity_factor': 3, # Menor intensidad laboral que C3
        'specialization_level': 'high', # Niveles superiores de especialización
        'tech_inertia': 0.7
    }
}

# === CATEGORÍAS DE SECTORES ===
SECTOR_CATEGORIES = list(SECTOR_TYPES.keys())
SECTOR_TO_INDEX = {name: idx for idx, name in enumerate(SECTOR_CATEGORIES)}
INDEX_TO_SECTOR = {idx: name for idx, name in enumerate(SECTOR_CATEGORIES)}

# === MATRICES DE TRANSICIÓN DE MARKOV ===
MARKOV_MATRICES = {
    'C1': [
        [0.97, 0.03, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
        [0.05, 0.95, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
        [0.00, 0.70, 0.30, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
        [0.00, 0.00, 0.85, 0.15, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Alta
        [0.00, 0.00, 0.00, 0.00, 0.97, 0.03, 0.00, 0.00, 0.00],  # Servicios_Bajos
        [0.00, 0.00, 0.00, 0.00, 0.05, 0.85, 0.10, 0.00, 0.00],  # Servicios_Intermedios
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.15, 0.75, 0.10, 0.00],  # Servicios_Avanzados
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.97, 0.03],  # Turismo_Masivo
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.95]
    ],
    'C2': [
        [0.85, 0.10, 0.05, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Bajo
        [0.10, 0.80, 0.10, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00],  # Primario_Alto
        [0.00, 0.15, 0.75, 0.10, 0.00, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Baja
        [0.00, 0.00, 0.25, 0.65, 0.10, 0.00, 0.00, 0.00, 0.00],  # Manufactura_Alta
        [0.00, 0.00, 0.00, 0.00, 0.85, 0.10, 0.05, 0.00, 0.00],  # Servicios_Bajos
        [0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.20, 0.00, 0.00],  # Servicios_Intermedios
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.15, 0.65, 0.20, 0.00],  # Servicios_Avanzados
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.85, 0.15],  # Turismo_Masivo
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.95]
    ],
    'C3': [
        [0.40, 0.15, 0.20, 0.10, 0.15, 0.00, 0.00, 0.00, 0.00],
        [0.05, 0.35, 0.25, 0.15, 0.20, 0.00, 0.00, 0.00, 0.00],
        [0.00, 0.05, 0.35, 0.30, 0.25, 0.05, 0.00, 0.00, 0.00],
        [0.00, 0.00, 0.10, 0.40, 0.25, 0.10, 0.15, 0.00, 0.00],
        [0.00, 0.00, 0.00, 0.00, 0.45, 0.30, 0.20, 0.05, 0.00],
        [0.00, 0.00, 0.00, 0.00, 0.05, 0.45, 0.30, 0.15, 0.05],
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.55, 0.25, 0.15],
        [0.00, 0.00, 0.00, 0.00, 0.05, 0.15, 0.00, 0.55, 0.25],
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.10, 0.15, 0.70]
    ],
    'C4': [
        [0.85, 0.05, 0.05, 0.00, 0.05, 0.00, 0.00, 0.00, 0.00],
        [0.05, 0.80, 0.10, 0.00, 0.05, 0.00, 0.00, 0.00, 0.00],
        [0.00, 0.03, 0.85, 0.10, 0.02, 0.00, 0.00, 0.00, 0.00],
        [0.00, 0.00, 0.05, 0.75, 0.10, 0.05, 0.05, 0.00, 0.00],
        [0.00, 0.00, 0.00, 0.00, 0.85, 0.10, 0.05, 0.00, 0.00],
        [0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.15, 0.05, 0.00],
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.05, 0.75, 0.15, 0.05],
        [0.00, 0.00, 0.00, 0.00, 0.05, 0.05, 0.00, 0.75, 0.15],
        [0.00, 0.00, 0.00, 0.00, 0.00, 0.03, 0.05, 0.05, 0.87]
    ]
}

class Product:
    """Clase para modelar productos/servicios de una región"""
    def __init__(self, sector_type, product_id):
        params = SECTOR_PARAMS[sector_type]
        self.id = product_id
        self.name = f"Product_{sector_type}_{product_id}"
        self.revenue = np.random.uniform(*params['product_range'])
        self.cost = np.random.uniform(0.4, 0.8) * self.revenue
        self.production = np.random.uniform(3, 16)
        self.tech_intensity = np.random.uniform(0.1, params['knowledge_intensity'])
        self.skill_required = np.random.uniform(*params['skill_requirements'])
        self.sector_type = sector_type
        self.sector_id = np.random.choice(SECTOR_TYPES[sector_type])

    def calculate_margin(self):
        return (self.revenue - self.cost) / self.revenue

class Worker:
    def __init__(self, sector_type=None):
        if sector_type:
            params = SECTOR_PARAMS[sector_type]
            self.skill = np.random.uniform(
                max(0.1, params['skill_requirements'][0] - 0.2),
                min(1.0, params['skill_requirements'][1] + 0.1)
            )
            self.specialized_skill = random.uniform(0.5, 1.1)
        else:
            self.skill = np.random.uniform(0.1, 0.6)
            self.specialized_skill = 0.0
        self.employed = False
        self.region_id = None
        self.region = None
        self.sector_type = sector_type
        self.experience = 0

    def improve_skills(self, training_investment, tech_exposure):
        training_effect = 0.4 * (1 - np.exp(-1.5 * training_investment))
        tech_effect = 0.5 * (1 - np.exp(-1.0 * tech_exposure))
        individual_factor = np.random.uniform(0.7, 1.0)
        experience_factor = 1 + np.log1p(self.experience) * 0.05
        skill_gain = (training_effect + tech_effect) * individual_factor * experience_factor * LEARNING_RATE * 0.66
        self.skill = np.clip(self.skill + skill_gain, 0.1, 1.0)
        if hasattr(self, 'region') and self.region is not None:
            if hasattr(self.region, 'tech_capability') and hasattr(self.region, 'tech_capability_history'):
                if len(self.region.tech_capability_history) > 1:
                    tech_change_rate = abs(self.region.tech_capability - self.region.tech_capability_history[-2])
                    if tech_change_rate > 0.02:
                        self.skill = max(0.1, self.skill * 0.98)

class Workforce:
    def __init__(self, sector_type, region_id):
        self.params = SECTOR_PARAMS[sector_type]
        self.workers = []
        self.sector_type = sector_type
        self.region_id = region_id
        self.region = None
        self.training_investment = self.params['training_investment'] * 0.7
        self.skill_requirements = np.random.uniform(*self.params['skill_requirements'])
        self.min_specialized_skill = 0.6
        self.avg_skill = 0.0
        self.avg_specialized_skill = 0.0
        self.qualification_gap = self.skill_requirements
        self.experience_decay = 0.01  # Obsolescencia de experiencia

    def update_metrics(self):
        tech_capability = 0.12
        if hasattr(self, 'region') and self.region is not None:
            tech_capability = getattr(self.region, 'tech_capability', tech_capability)
        tech_factor = 1 + tech_capability
        volatility = self.params['volatility']
        # Requisitos crecen con CT, pero con saturación
        base_req = np.random.uniform(*self.params['skill_requirements'])
        self.skill_requirements = np.clip(
            base_req * (1 + 0.75 * tech_capability),
            self.params['skill_requirements'][0],
            self.params['skill_requirements'][1] * 1.5
        )

        if self.workers:
            self.avg_skill = np.mean([w.skill for w in self.workers])
            self.avg_specialized_skill = np.mean([w.specialized_skill for w in self.workers])
            gap = max(0, self.skill_requirements - self.avg_skill)
            # Brecha amplificada por baja absorción
            self.qualification_gap = gap * (1 + 0.4 * np.random.uniform(-0.5, 0.5) * self.params['volatility'])
        else:
            self.avg_skill = 0.0
            self.avg_specialized_skill = 0.0
            self.qualification_gap = self.skill_requirements

    def hire_workers(self, num_workers, worker_pool):
        if num_workers <= 0: return 0
        hired = 0
        available_workers = [w for w in worker_pool if not w.employed]

        # Priorizar especializados, pero con costo de adaptación
        specialized_workers = [w for w in available_workers if w.sector_type == self.sector_type]
        for worker in specialized_workers[:min(num_workers - hired, len(specialized_workers))]:
            worker.employed = True
            worker.region_id = self.region_id
            worker.region = self.region
            worker.skill = max(worker.skill * 0.9, worker.skill - 0.05)  # Pérdida en transición
            self.workers.append(worker)
            hired += 1

        remaining = num_workers - hired
        if remaining > 0:
            general_workers = [w for w in available_workers if w not in specialized_workers]
            for worker in general_workers[:min(remaining, len(general_workers))]:
                worker.employed = True
                worker.region_id = self.region_id
                worker.region = self.region
                worker.sector_type = self.sector_type
                worker.skill = max(0.1, worker.skill * 0.7)  # Reset parcial de habilidad
                self.workers.append(worker)
                hired += 1
        self.update_metrics()
        return hired

    def fire_workers(self, num_workers):
        if not self.workers or num_workers <= 0: return 0
        self.workers.sort(key=lambda x: x.skill + x.specialized_skill)
        fired = 0
        for _ in range(min(num_workers, len(self.workers))):
            worker = self.workers.pop(0)
            worker.employed = False
            worker.region_id = None
            worker.region = None
            fired += 1
        self.update_metrics()
        return fired

    def adjust_workforce(self, required_workers, worker_pool):
        current = len(self.workers)
        if current < required_workers:
            self.hire_workers(required_workers - current, worker_pool)
        elif current > required_workers:
            self.fire_workers(current - required_workers)

    def evaluate_workers(self):
        # Despedir solo si muy por debajo, con inercia
        threshold = self.skill_requirements * 0.65
        to_fire = [w for w in self.workers if w.skill < threshold]
        for worker in to_fire:
            self.workers.remove(worker)
            worker.employed = False
            worker.region_id = None
            worker.region = None
        self.update_metrics()
        return len(to_fire)

    def increment_experience(self):
        for worker in self.workers:
            worker.experience += 1

    def train_workers(self, tech_exposure):
        if not self.workers: return
        for worker in self.workers:
            worker.improve_skills(self.training_investment, tech_exposure)
        self.update_metrics()

    def wage_inequality(self):
        if not self.workers: return 0.0
        wages = [worker.skill for worker in self.workers]
        return gini_coefficient(wages)

class Region:
    def __init__(self, region_id, num_sectors, worker_pool, agglomeration_type=None, initial_tech=None):
        self.id = region_id
        self.worker_pool = worker_pool
        self.agglomeration_type = agglomeration_type
        self._tech_locked = False
        self.tech_inertia = AGGLOMERATION_PARAMS.get(agglomeration_type, {}).get('tech_inertia', 0.1)
        self.steps = 0
        self.innovation_trap = False
        self.trap_duration = 0
        # === Historiales ===
        self.tech_capability_history = []
        self.innovation_rate_history = []
        self.diversification_history = []
        self.specialization_history = []
        self.qualification_gap_history = []
        self.profit_margin_history = []
        self.employment_rate_history = []
        self.productivity_history = []
        self.wages_inequality_history = []
         # === Actividades ===
        self.activities = []
        # Asignar CT inicial
        if initial_tech is not None:
            self.tech_capability = initial_tech
            self._tech_locked = True
        else:
            self.tech_capability = INITIAL_TECH
        base_tech = initial_tech if initial_tech is not None else INITIAL_TECH
        self.technological_inertia = self.tech_inertia
        # Definir posibles sectores según CT
        if base_tech < 0.2:
            possible_types = ['Primario_Bajo', 'Manufactura_Baja', 'Servicios_Bajos', 'Turismo_Masivo']
        elif base_tech < 0.5:
            possible_types = ['Primario_Alto', 'Manufactura_Baja', 'Servicios_Bajos', 'Servicios_Intermedios', 'Turismo_Masivo', 'Turismo_Especializado']
        else:
            possible_types = list(SECTOR_TYPES.keys())
        num_sectors = random.randint(2, 4) if num_sectors == "random" else max(2, num_sectors)
        for _ in range(num_sectors):
            sector_type = random.choice(possible_types)
            sector_id = random.choice(SECTOR_TYPES[sector_type])
            params = SECTOR_PARAMS[sector_type]
            num_products_sector = random.randint(*params['product_range'])
            products = [Product(sector_type, i) for i in range(num_products_sector)]
            total_production = sum(p.production for p in products)
            productivity = params["productivity"]
            required_workers = max(1, int(total_production / productivity))
            workforce = Workforce(sector_type, self.id)
            workforce.region = self
            workforce.hire_workers(required_workers, worker_pool)
            self.activities.append({
                'sector_type': sector_type, 'sector_id': sector_id, 'sector_name': SECTORS[sector_id],
                'products': products, 'workforce': workforce, 'params': params,
                'tech_capability': base_tech * random.uniform(0.9, 1.1),
                'innovation_rate': INNOVATION_BASE_RATE, 'profit_margin': random.uniform(*params["margin_range"]),
                'total_production': total_production, 'required_workers': required_workers,
                'specialization_coeff': params['specialization_coeff'], 'diversity_weight': 1.0
            })
        # === Actualizar métricas agregadas (esto puede sobrescribir algunos valores) ===
        self._update_aggregate_metrics()
        # === Aplicar parámetros de aglomeración ===
        self._apply_agglomeration_params()
        # === Guardar estado inicial en historiales ===
        self.tech_capability_history.append(self.tech_capability)
        self.innovation_rate_history.append(self.innovation_rate)
        self.diversification_history.append(self.diversification)
        self.specialization_history.append(self.specialization)
        self.qualification_gap_history.append(self.qualification_gap)
        self.profit_margin_history.append(self.profit_margin)
        self.employment_rate_history.append(self.employment_rate)
        self.productivity_history.append(self.productivity)

    def _get_sector_type(self, sector_id):
        for sector_type, ids in SECTOR_TYPES.items():
            if sector_id in ids:
                return sector_type
        return 'Desconocido'

    def get_primary_sector_type(self):
        if not self.activities: return 'Desconocido'
        return max(self.activities, key=lambda a: a['total_production'])['sector_type']

    def _update_aggregate_metrics(self):
        if not self.activities:
            self.tech_capability = INITIAL_TECH
            self.innovation_rate = INNOVATION_BASE_RATE
            self.diversification = 0.0
            self.specialization = 1.0
            self.qualification_gap = 0.5
            self.profit_margin = 0.3
            self.employment_rate = 0.7
            self.productivity = 10.0
            return

        weights = [act['total_production'] for act in self.activities]
        total_weight = sum(weights)
        if total_weight == 0:
            weights = [1 / len(self.activities)] * len(self.activities)
        else:
            weights = [w / total_weight for w in weights]

        # === CT agregada con inercia fuerte ===
        new_tech = sum(act['tech_capability'] * w for act, w in zip(self.activities, weights))
        inertia = 0.92 if self.tech_capability < 0.3 else 0.75
        if hasattr(self, 'technological_inertia'):
            inertia = self.technological_inertia
        self.tech_capability = (1 - inertia) * self.tech_capability + inertia * new_tech if hasattr(self, 'tech_capability') else new_tech
        self.innovation_rate = sum(act['innovation_rate'] * w for act, w in zip(self.activities, weights))
        self.profit_margin = sum(act['profit_margin'] * w for act, w in zip(self.activities, weights))
        concentration = sum(w ** 2 for w in weights)
        inertia_spec = 0.8
        self.specialization = inertia_spec * self.specialization + (1 - inertia_spec) * concentration if hasattr(self, 'specialization') else concentration
        self.diversification = 1 - self.specialization

        # === Diversificación limitada si CT baja ===
        if self.tech_capability < 0.5:
            max_div = 0.2 + self.tech_capability * 0.4
            if self.diversification > max_div:
                self.diversification = max_div
                self.specialization = 1 - max_div

        # === Brecha de calificación: persistente ===
        self.qualification_gap = sum(act['workforce'].qualification_gap * w for act, w in zip(self.activities, weights))

        # Productividad y margen
        productivities = [act['params']['productivity'] for act in self.activities]
        self.productivity = sum(p * w for p, w in zip(productivities, weights))
        self.employment_rate = np.clip(np.random.uniform(0.7, 0.9), 0.5, 1.0)

    def _apply_agglomeration_params(self):
        if not self.agglomeration_type or self.agglomeration_type not in AGGLOMERATION_PARAMS: return
        params = AGGLOMERATION_PARAMS[self.agglomeration_type]
        if 'initial_specialization' in params:
            if isinstance(params['initial_specialization'], tuple):
                self.specialization = np.random.uniform(*params['initial_specialization'])
            else:
                self.specialization = params['initial_specialization']
            self.diversification = 1 - self.specialization
        if 'initial_tech_capability' in params and not getattr(self, '_tech_locked', False):
            self.tech_capability = max(INITIAL_TECH, params['initial_tech_capability'] + np.random.uniform(-0.02, 0.02))
        if 'diversity_level' in params:
            dl = params['diversity_level']
            self.diversification = np.random.uniform(0.0, 0.18) if dl == 'low' else np.random.uniform(0.18, 0.42) if dl == 'medium' else np.random.uniform(0.42, 0.6)
            self.specialization = 1 - self.diversification
        self.labor_intensity_factor = params.get('labor_intensity_factor', 1.0)
        self.tech_decay_rate = params.get('tech_decay_rate', 0.0)

    def _update_activity(self, activity):
        self._apply_external_shocks(activity)
        self._innovate_activity(activity)
        self._adjust_products_activity(activity)
        self._update_workforce_activity(activity)

    def _apply_external_shocks(self, activity):
        shock_factor = np.random.uniform(0.97, 1.03) ** (1 + activity['params']['volatility'])
        margin_shock = random.normalvariate(0, 0.06) * activity['params']['volatility']
        productivity_shock = random.normalvariate(0, 0.08) * (1 - activity['tech_capability'] / 2)
        activity['total_production'] *= shock_factor
        activity['profit_margin'] = np.clip(activity['profit_margin'] + margin_shock, activity['params']['margin_range'][0] * 0.8, activity['params']['margin_range'][1] * 1.1)
        activity['total_production'] = max(1.0, activity['total_production'])

    def _innovate_activity(self, activity):
        base_innovation = INNOVATION_BASE_RATE
        tech_level = activity['tech_capability']
        skill_level = activity['workforce'].avg_skill
        div_factor = 0.1 + self.diversification * 0.5
        if hasattr(self, 'other_regions') and self.other_regions and self.agglomeration_type in ['C3', 'C4']:
            absorption_capacity = ABSORPTION_CAPACITY_FACTOR * (self.tech_capability * 0.7 + activity['workforce'].avg_skill * 0.3)
            absorption_capacity = np.clip(absorption_capacity, 0.001, 0.05)  # Mucho más bajo
            avg_neighbor_tech = np.mean([r.tech_capability for r in self.other_regions])
            potential_spillover = max(0, avg_neighbor_tech - self.tech_capability)
            effective_spillover = KNOWLEDGE_SPILLOVER * potential_spillover * absorption_capacity
            self.tech_capability = min(1.0, self.tech_capability + effective_spillover * 0.01)
            self.innovation_rate += effective_spillover * 0.001
        # === Innovación base baja y saturada ===
        if tech_level > MIN_INNOVATION_THRESHOLD:
            tech_factor = 0.1 + np.tanh(tech_level * 1.2) * 0.3  # Saturación
            skill_factor = 0.1 + np.tanh(skill_level * 1.2) * 0.3
            innovation_cap = activity['params']['innovation_capacity']
            learning_effect = np.log1p(self.steps * INNOVATION_ACCELERATION) / (1 + self.steps * 0.03)
            activity['innovation_rate'] = base_innovation + (tech_factor * skill_factor * innovation_cap) * (1 + learning_effect)
        else:
            activity['innovation_rate'] = base_innovation * 0.2  # Muy baja

        # === Penalización fuerte por brecha ===
        skill_gap = activity['workforce'].qualification_gap
        activity['innovation_rate'] *= (1 - SKILL_GAP_INNOVATION_PENALTY * skill_gap)
        activity['innovation_rate'] = max(0, min(activity['innovation_rate'], 0.08))  # Límite: 8%

    def _adjust_products_activity(self, activity):
        to_remove = [p for p in activity['products'] if p.calculate_margin() < activity['profit_margin'] * 0.7 and random.random() < 0.3]
        for p in to_remove:
            activity['products'].remove(p)
            activity['total_production'] -= p.production
        if random.random() < activity['innovation_rate']:
            innovation_type = random.choices(['incremental', 'sector_relacionado', 'radical'], weights=[0.6, 0.3, 0.1])[0]
            if innovation_type == 'incremental':
                new_sector = activity['sector_type']
            elif innovation_type == 'sector_relacionado':
                related_sectors = [k for k, v in SECTOR_PARAMS.items() if abs(v['knowledge_intensity'] - activity['params']['knowledge_intensity']) < 0.2 and k != activity['sector_type']]
                new_sector = random.choice(related_sectors) if related_sectors else activity['sector_type']
            else:
                new_sector = random.choice(list(SECTOR_PARAMS.keys()))
            new_product = Product(new_sector, len(activity['products']))
            activity['products'].append(new_product)
            activity['total_production'] += new_product.production
        required_workers = max(1, int(activity['total_production'] / activity['params']['productivity']))
        activity['workforce'].adjust_workforce(required_workers, self.worker_pool)
        activity['required_workers'] = required_workers

    def _update_workforce_activity(self, activity):
        activity['workforce'].train_workers(activity['tech_capability'])
        activity['workforce'].evaluate_workers()
        activity['workforce'].increment_experience()

    def consider_sector_change(self):
        if self.innovation_trap or self.tech_capability < 0.3:
            return  # No cambian si están atrapadas o CT muy baja

        # Inercia según diversificación
        inertia_factor = 0.2 if self.diversification < 0.15 else 1.0
        change_probability = SECTOR_CHANGE_BASE_RATE * inertia_factor

        # Supresión fuerte en C1 y C2
        if self.agglomeration_type in ['C1', 'C2']:
            change_probability *= 0.1  # Casi no cambian

        if random.random() < change_probability:
            try:
                primary_activity = max(self.activities, key=lambda a: a['total_production'])
                current_idx = SECTOR_TO_INDEX[primary_activity['sector_type']]
            except KeyError:
                return

            matrix = MARKOV_MATRICES[self.agglomeration_type]
            adjusted_probs = list(matrix[current_idx])

            # Solo permitir avanzar si CT > 0.5
            advanced_sectors = ['Manufactura_Alta', 'Servicios_Avanzados', 'Turismo_Especializado']
            tech_level = self.tech_capability
            for sec in advanced_sectors:
                if sec in SECTOR_TO_INDEX:
                    idx_adv = SECTOR_TO_INDEX[sec]
                    if tech_level < 0.5:
                        adjusted_probs[idx_adv] *= 0.1  # Muy baja probabilidad
                    elif tech_level < 0.7:
                        adjusted_probs[idx_adv] *= 0.5

            total = sum(adjusted_probs)
            if total > 0:
                adjusted_probs = [p / total for p in adjusted_probs]
            else:
                return

            next_idx = random.choices(range(len(adjusted_probs)), weights=adjusted_probs)[0]
            new_sector_type = INDEX_TO_SECTOR[next_idx]

            # Verificar que la nueva actividad no duplique
            if any(a['sector_type'] == new_sector_type for a in self.activities):
                return

            # Solo agregar si hay recursos
            if new_sector_type not in SECTOR_PARAMS:
                return

            sector_id = random.choice(SECTOR_TYPES[new_sector_type])
            products = [Product(new_sector_type, i) for i in range(random.randint(2, 4))]
            total_production = sum(p.production for p in products)
            required_workers = max(1, int(total_production / SECTOR_PARAMS[new_sector_type]['productivity']))

            # Costo de entrada alto
            if required_workers > 10000 or len([a for a in self.activities if a['sector_type'] == new_sector_type]) > 0:
                return

            workforce = Workforce(new_sector_type, self.id)
            workforce.region = self
            workforce.hire_workers(required_workers, self.worker_pool)

            self.activities.append({
                'sector_type': new_sector_type,
                'sector_id': sector_id,
                'sector_name': SECTORS[sector_id],
                'products': products,
                'workforce': workforce,
                'params': SECTOR_PARAMS[new_sector_type],
                'tech_capability': max(0.1, self.tech_capability * 0.7),
                'innovation_rate': INNOVATION_BASE_RATE * 0.8,
                'profit_margin': np.random.uniform(*SECTOR_PARAMS[new_sector_type]['margin_range']),
                'total_production': total_production,
                'required_workers': required_workers,
                'specialization_coeff': SECTOR_PARAMS[new_sector_type]['specialization_coeff'],
                'diversity_weight': 1.0
            })

    def apply_technological_decay(self):
        if self.agglomeration_type and hasattr(self, 'tech_decay_rate') and self.tech_decay_rate > 0:
            self.tech_capability = max(INITIAL_TECH, self.tech_capability * (1 - self.tech_decay_rate))

    def update(self):
        for activity in self.activities:
            self._update_activity(activity)
        if self.innovation_trap:
            self.trap_duration += 1
        else:
            self.trap_duration = 0
        self._update_aggregate_metrics()
        self.consider_sector_change()
        self.check_innovation_trap()
        self.innovation_rate = max(0, self.innovation_rate + np.random.uniform(-0.02, 0.03))
        self.employment_rate = np.clip(self.employment_rate + np.random.uniform(-0.03, 0.03), 0.5, 1.0)
        self.tech_capability_history.append(self.tech_capability)
        self.innovation_rate_history.append(self.innovation_rate)
        self.diversification_history.append(self.diversification)
        self.specialization_history.append(self.specialization)
        self.qualification_gap_history.append(self.qualification_gap)
        self.profit_margin_history.append(self.profit_margin)
        self.employment_rate_history.append(self.employment_rate)
        self.productivity_history.append(self.productivity)
        self.apply_technological_decay()
        self.steps += 1

    def check_innovation_trap(self):
        trap_conditions = [
            self.tech_capability < 0.25,
            self.innovation_rate < 0.015,
            self.qualification_gap > 0.42,
            self.diversification < 0.18,
            len([a for a in self.activities if a['params']['knowledge_intensity'] > 0.4]) == 0
        ]
        is_trapped = sum(trap_conditions) >= 3

        if not self.innovation_trap and is_trapped:
            self.innovation_trap = True
            self.tech_capability = max(0.05, self.tech_capability * 0.8)
            self.innovation_rate *= 0.5
            for activity in self.activities:
                activity['workforce'].training_investment *= 0.5
            self.productivity *= 0.85
            self.technological_inertia = 0.97  # Más inercia
            self.trap_duration = 0

        elif self.innovation_trap and not is_trapped:
            # Solo intentar escapar si se cumplen 4 condiciones
            escape_conditions = [
                self.tech_capability > 0.5,
                self.innovation_rate > 0.07,
                self.qualification_gap < 0.18,
                self.diversification > 0.35,
                any(a['params']['knowledge_intensity'] > 0.5 for a in self.activities)
            ]
            if sum(escape_conditions) >= 4:
                # Probabilidad muy baja
                if random.random() < TRAP_ESCAPE_PROBABILITY * 0.3:  # ~0.0003
                    self.innovation_trap = False
                    self.tech_capability *= 1.05
                    self.innovation_rate *= 1.1
                    for activity in self.activities:
                        activity['workforce'].training_investment = activity['params']['training_investment']
                    self.technological_inertia = 0.75
                    self.trap_duration = 0
            else:
                self.trap_duration += 1
        else:
            self.trap_duration = 0

class EconomicModel:
    def __init__(self, n_regions=32):
        self.n_regions = n_regions
        self.worker_pool = [Worker() for _ in range(WORKER_POOL_SIZE)]
        self.regions = []
        self.history = []
        self.steps = 0
        agglomeration_types = list(AGGLOMERATION_PARAMS.keys())
        for i in range(n_regions):
            agglomeration_type = np.random.choice(agglomeration_types)
            if i < 14:
                initial_tech = np.random.uniform(0.10, 0.15)
            elif i < 22:
                initial_tech = np.random.uniform(0.30, 0.45)
            elif i < 28:
                initial_tech = np.random.uniform(0.60, 0.75)
            else:
                initial_tech = np.random.uniform(0.80, 0.95)
            region = Region(region_id=i, num_sectors="random", worker_pool=self.worker_pool, agglomeration_type=agglomeration_type, initial_tech=initial_tech)
            self.regions.append(region)

    def run(self, steps=30):
        for step in range(steps):
            print(f"Simulación - Paso {step + 1}/{steps}")
            for region in self.regions:
                region.update()
            self.record_state()
            self.steps += 1
        return pd.DataFrame(self.history)

    def get_agent_data(self):
        agent_data_list = []
        for region in self.regions:
            if not hasattr(region, 'activities') or not region.activities: continue
            primary = max(region.activities, key=lambda a: a['total_production'])
            avg_skill = np.mean([a['workforce'].avg_skill for a in region.activities])
            avg_specialized = np.mean([a['workforce'].avg_specialized_skill for a in region.activities])
            agent_data_list.append({
                "id": region.id, "sector_type": region.get_primary_sector_type(), "sector_name": primary['sector_name'],
                "tech": region.tech_capability, "margin": region.profit_margin, "productivity": region.productivity,
                "innovation_rate": region.innovation_rate, "diversification": region.diversification,
                "specialization": region.specialization, "num_products": sum(len(a['products']) for a in region.activities),
                "qualification_gap": region.qualification_gap, "trapped": getattr(region, 'innovation_trap', False),
                "employment_rate": region.employment_rate, "agglomeration_type": region.agglomeration_type,
                "avg_skill": avg_skill, "avg_specialized_skill": avg_specialized, "num_sectors": len(region.activities),
                "trap_duration": getattr(region, 'trap_duration', 0)
            })
        return pd.DataFrame(agent_data_list)

    def record_state(self):
        current_state = {
            "step": self.steps,
            "avg_tech": np.mean([r.tech_capability for r in self.regions]),
            "std_tech": np.std([r.tech_capability for r in self.regions]),
            "avg_margin": np.mean([r.profit_margin for r in self.regions]),
            "avg_productivity": np.mean([r.productivity for r in self.regions]),
            "avg_innovation": np.mean([r.innovation_rate for r in self.regions]),
            "avg_diversification": np.mean([r.diversification for r in self.regions]),
            "avg_specialization": np.mean([r.specialization for r in self.regions]),
            "sector_diversity": self.calculate_sector_diversity(),
            "tech_diversity": self.calculate_tech_diversity(),
            "pct_trapped": np.mean([getattr(r, 'innovation_trap', False) for r in self.regions]),
            "employment_rate": np.mean([r.employment_rate for r in self.regions]),
            "tech_inequality": gini_coefficient([r.tech_capability for r in self.regions]),
            "qualification_gap": np.mean([r.qualification_gap for r in self.regions]),
            "max_qualification_gap": np.max([r.qualification_gap for r in self.regions]),
            "diversity_product_ratio": self.calculate_sector_diversity() / max(1, len(self.regions) / 10),
            "unique_products": len(set([p.name for r in self.regions for a in r.activities for p in a['products']]))
        }
        for agg_type in AGGLOMERATION_PARAMS.keys():
            regions_in_type = [r for r in self.regions if r.agglomeration_type == agg_type]
            if regions_in_type:
                current_state[f"tech_{agg_type}"] = np.mean([r.tech_capability for r in regions_in_type])
                current_state[f"innov_{agg_type}"] = np.mean([r.innovation_rate for r in regions_in_type])
                current_state[f"prod_{agg_type}"] = np.mean([r.productivity for r in regions_in_type])
                current_state[f"trapped_{agg_type}"] = np.mean([getattr(r, 'innovation_trap', False) for r in regions_in_type])
            else:
                current_state[f"tech_{agg_type}"] = 0.0
                current_state[f"innov_{agg_type}"] = 0.0
                current_state[f"prod_{agg_type}"] = 0.0
                current_state[f"trapped_{agg_type}"] = 0.0
        self.history.append(current_state)

        # Desigualdad salarial promedio (Gini por workforce, ponderado)
        wage_inequality_values = []
        for region in self.regions:
            if not region.activities:
                continue
            # Ponderar por tamaño del workforce
            for activity in region.activities:
                workforce = activity['workforce']
                if len(workforce.workers) > 1:
                    weight = len(workforce.workers)
                    gini_worker = workforce.wage_inequality()
                    wage_inequality_values.append(gini_worker)

        current_state["avg_wage_inequality"] = np.mean(wage_inequality_values) if wage_inequality_values else 0.0


    def calculate_sector_diversity(self):
        if not self.regions: return 0.0
        sector_counts = pd.Series([region.get_primary_sector_type() for region in self.regions]).value_counts()
        total = len(self.regions)
        proportions = (sector_counts + 1e-6) / (total + 1e-6 * len(SECTOR_PARAMS))
        return -np.sum(proportions * np.log(proportions))

    def calculate_tech_diversity(self):
        tech_levels = [r.tech_capability for r in self.regions]
        mean_tech = np.mean(tech_levels)
        return np.std(tech_levels) / mean_tech if mean_tech != 0 else 0.0

    def get_results(self):
        return pd.DataFrame(self.history), self.get_agent_data()

    def export_results(self, model_df, agent_df, base_filename="results", seed=None):
        if seed is not None:
            model_df["seed"] = seed
            agent_df["seed"] = seed
        model_df.to_csv(f"{base_filename}_model.csv", index=False)
        agent_df.to_csv(f"{base_filename}_agents.csv", index=False)
        print(f"Resultados exportados a {base_filename}_model.csv y {base_filename}_agents.csv")

    def plot_results(self):
        model_data, agent_data = self.get_results()
        agent_data_with_step = pd.DataFrame()
        for step in range(self.steps):
            temp_df = agent_data.copy()
            temp_df['step'] = step
            agent_data_with_step = pd.concat([agent_data_with_step, temp_df], ignore_index=True)
        metrics = ['avg_tech', 'avg_innovation', 'avg_productivity']
        fig, axes = plt.subplots(len(metrics), 1, figsize=(14, 28))
        fig.suptitle('Evolución de Métricas por Tipo de Aglomeración', fontsize=16)
        for i, metric in enumerate(metrics):
            for agg_type in AGGLOMERATION_PARAMS.keys():
                tech_col = f"tech_{agg_type}" if "tech" in metric else None
                innov_col = f"innov_{agg_type}" if "innovation" in metric else None
                prod_col = f"prod_{agg_type}" if "productivity" in metric else None
                col = tech_col or innov_col or prod_col
                if col in model_data.columns:
                    model_data.plot(x='step', y=col, ax=axes[i], label=agg_type, linewidth=2.5)
            axes[i].set_title(f'{metric.replace("avg_", "").replace("_", " ").title()}')
            axes[i].set_ylabel(metric.replace("avg_", "").title())
            axes[i].set_xlabel('Paso')
            axes[i].legend(title='Aglomeración')
            axes[i].grid(True, alpha=0.4)
        plt.tight_layout(rect=[0, 0, 1, 0.98])
        plt.savefig('metrics_by_agglomeration.png', dpi=300, bbox_inches='tight')
        plt.show()

        gini_metrics = ['innovation', 'tech', 'employment_rate']
        for metric in gini_metrics:
            plt.figure(figsize=(10, 6))
            gini_series = []
            for step in range(self.steps):
                step_data = agent_data_with_step[agent_data_with_step['step'] == step]
                if len(step_data) > 1 and metric in step_data.columns:
                    gini_val = gini_coefficient(step_data[metric].values)
                    gini_series.append(gini_val)
                else:
                    gini_series.append(0)
            plt.plot(range(self.steps), gini_series, marker='o', linewidth=2)
            plt.title(f'Coeficiente de Gini de {metric.title()}')
            plt.xlabel('Paso')
            plt.ylabel('Gini')
            plt.grid(True)
            plt.savefig(f'gini_{metric}.png', dpi=300, bbox_inches='tight')
            plt.show()

        plt.figure(figsize=(10, 6))
        sns.countplot(data=agent_data, x='agglomeration_type', hue='agglomeration_type', palette='Set2', legend=False)
        plt.title('Distribución de Aglomeraciones en el Período Final')
        plt.ylabel('Número de Regiones')
        plt.savefig('agglomeration_distribution.png', dpi=300, bbox_inches='tight')
        plt.show()

        corr_cols = ['avg_tech', 'avg_innovation', 'avg_productivity', 'sector_diversity', 'pct_trapped', 'tech_inequality']
        plt.figure(figsize=(12, 10))
        sns.heatmap(model_data[corr_cols].corr(), annot=True, cmap='coolwarm', fmt=".2f", center=0)
        plt.title('Correlación entre Métricas del Modelo')
        plt.savefig('correlation_matrix_model.png', dpi=300, bbox_inches='tight')
        plt.show()

        agent_numeric = agent_data.select_dtypes(include=np.number).columns.tolist()
        if len(agent_numeric) > 1:
            plt.figure(figsize=(14, 10))
            sns.heatmap(agent_data[agent_numeric].corr(), annot=True, cmap='viridis', fmt=".2f")
            plt.title('Correlación entre Variables de Regiones (Final)')
            plt.savefig('correlation_matrix_agents.png', dpi=300, bbox_inches='tight')
            plt.show()

        cluster_features = ['tech', 'innovation_rate', 'diversification', 'specialization', 'qualification_gap', 'productivity']
        cluster_data = agent_data[cluster_features].dropna()
        if len(cluster_data) > 1:
            scaler = StandardScaler()
            scaled_data = scaler.fit_transform(cluster_data)
            kmeans = KMeans(n_clusters=3, random_state=42)
            clusters = kmeans.fit_predict(scaled_data)
            pca = PCA(n_components=2)
            components = pca.fit_transform(scaled_data)
            plt.figure(figsize=(12, 8))
            scatter = plt.scatter(components[:, 0], components[:, 1], c=clusters, cmap='Set1', s=100, alpha=0.8, edgecolors='k')
            plt.colorbar(scatter, label='Cluster')
            plt.xlabel(f'PC1 (Varianza: {pca.explained_variance_ratio_[0]:.2%})')
            plt.ylabel(f'PC2 (Varianza: {pca.explained_variance_ratio_[1]:.2%})')
            plt.title('Agrupamiento de Regiones (PCA + K-means)')
            plt.grid(True, alpha=0.3)
            plt.savefig('region_clustering.png', dpi=300, bbox_inches='tight')
            plt.show()
            agent_data['cluster'] = clusters
            print("\n=== Distribución de Regiones por Cluster ===")
            print(agent_data['cluster'].value_counts())

        # 1. Evolución de métricas principales

        plt.figure(figsize=(18, 12))
        ax1 = plt.gca()
        metrics = ['tech_inequality', 'avg_tech']
        labels = ['Desigualdad Tecnológica (Índice Gini)', 'Nivel Tecnológico Promedio']
        colors = ['#1f77b4', '#ff7f0e']  # Azul y naranja
        for metric, label, color in zip(metrics, labels, colors):
            if metric in model_data.columns:
              ax1.plot(model_data['step'], model_data[metric], label=label, color=color)

        ax2 = ax1.twinx()
        if 'avg_innovation' in model_data.columns:
          ax2.plot(model_data['step'], model_data['avg_innovation'], label='Tasa de Innovación', color='black', linestyle='--')

        ax1.set_title('Evolución de Indicadores Tecnológicos y de Innovación')
        ax1.set_xlabel('Pasos de Simulación')
        ax1.set_ylabel('Valor de Métricas Tecnológicas')
        ax1.tick_params(axis='y')
        ax2.set_ylabel('Innovación')
        ax2.tick_params(axis='y')
        ax1.legend(loc='upper left', bbox_to_anchor=(0.01, 0.99), fontsize=10)
        ax2.legend(loc='upper right', bbox_to_anchor=(0.01, 0.94), fontsize=10)

        ax1.grid(True)

        plt.show()

        # 2. Diversidad sectorial y tecnológica
        plt.figure(figsize=(18, 12))
        ax1 = plt.gca()
        main_metrics = ['tech_diversity']
        for metric in main_metrics:
            if metric in model_data.columns:
              ax1.plot(model_data['step'], model_data[metric], label='Diversidad Tecnológica')
        ax2 = ax1.twinx()
        if 'sector_diversity' in model_data.columns:
          ax2.plot(model_data['step'], model_data['sector_diversity'], label='Diversidad Sectorial', color='black', linestyle='--')

        ax1.set_title('Diversidad Sectorial y Tecnológica')
        ax1.set_xlabel('Pasos de Simulación')
        ax1.set_ylabel('Diversidad Tecnológica')
        ax2.set_ylabel('Diversidad Sectorial')

        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')

        ax1.grid(True)

        plt.show()

        # 3. Productos por sector
        if all(col in agent_data.columns for col in ['sector_type', 'num_products']):
            plt.figure(figsize=(18, 12))
            sns.boxplot(data=agent_data, x='sector_type', y='num_products')
            plt.title('Productos por Sector')
            plt.xticks(rotation=45)
            plt.grid(True)
            plt.show()

        # 4. Innovación por sector
        if all(col in agent_data.columns for col in ['sector_type', 'innovation_rate']):
            plt.figure(figsize=(18, 12))
            sns.boxplot(data=agent_data, x='sector_type', y='innovation_rate')
            plt.title('Innovación por Sector')
            plt.xticks(rotation=45)
            plt.grid(True)
            plt.show()

        # 5. Tecnología por sector
        if all(col in agent_data.columns for col in ['sector_type', 'tech']):
            plt.figure(figsize=(18, 12))
            sns.boxplot(data=agent_data, x='sector_type', y='tech')
            plt.title('Tecnología por Sector')
            plt.xticks(rotation=45)
            plt.grid(True)
            plt.show()

        # 6. Correlaciones entre variables del modelo
        numeric_cols = [col for col in model_data.columns
                  if col != 'step'
                  and pd.api.types.is_numeric_dtype(model_data[col])
                  and col not in ['sector_volatility', 'skill_inequality']]  # Exclusión de columnas

        if len(numeric_cols) > 1:
          plt.figure(figsize=(20, 13))
          sns.heatmap(model_data[numeric_cols].corr(), annot=True, cmap='coolwarm', fmt='.2f')
          plt.title('Correlaciones entre Variables del Modelo')
          plt.xticks(rotation=45)
          plt.yticks(rotation=0)
          plt.tight_layout()
          plt.show()

        # 7. Correlaciones entre variables de agentes
        agent_numeric = agent_data.select_dtypes(include=np.number).columns.tolist()
        if len(agent_numeric) > 1:
            plt.figure(figsize=(18, 12))
            sns.heatmap(agent_data[agent_numeric].corr(), annot=True, cmap='viridis')
            plt.title('Correlaciones entre Variables de Regiones')
            plt.show()

        # 8. Regiones atrapadas vs no atrapadas
        if 'trapped' in agent_data.columns:
            trapped_vars = ['tech', 'innovation_rate', 'diversification', 'specialization', 'qualification_gap', 'employment_rate']
            trapped_vars = [var for var in trapped_vars if var in agent_data.columns]
            if trapped_vars:
                plt.figure(figsize=(18, 12))
                trapped_stats = agent_data.groupby('trapped')[trapped_vars].mean().T
                trapped_stats.plot(kind='bar')
                plt.title('Comparación Regiones Atrapadas vs No Atrapadas')
                plt.grid(True)
                plt.show()

        # 9. Evolución de productividad vs MBI
        plt.figure(figsize=(18, 12))
        ax1 = plt.gca()
        main_metrics = ['avg_productivity']
        for metric in main_metrics:
            if metric in model_data.columns:
              ax1.plot(model_data['step'], model_data[metric], label='Promedio Productividad')
        ax2 = ax1.twinx()
        if 'avg_margin' in model_data.columns:
          ax2.plot(model_data['step'], model_data['avg_margin'], label='MBI promedio', color='black', linestyle='--')

        ax1.set_title('Productividad vs. MBI (Promedios)')
        ax1.set_xlabel('Step')
        ax1.set_ylabel('Productividad')
        ax2.set_ylabel('MBI')

        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')

        ax1.grid(True)

        plt.show()

        # 10. Porcentaje de regiones atrapadas
        if 'pct_trapped' in model_data.columns:
            plt.figure(figsize=(18, 12))
            plt.plot(model_data['step'], model_data['pct_trapped'])
            plt.title('Porcentaje de Regiones Atrapadas')
            plt.grid(True)
            plt.show()

        # 11. Distribución de sectores a lo largo del tiempo (simplificada)
        if 'sector_type' in agent_data.columns and 'step' in model_data.columns:
            sector_counts = agent_data.groupby('sector_type').size().reset_index(name='count')
            plt.figure(figsize=(20, 13))
            plt.pie(sector_counts['count'], labels=sector_counts['sector_type'], autopct='%1.1f%%')
            plt.title('Distribución Sectorial')
            plt.show()

        # 12. Evolución de la brecha de calificación por sector
        if 'qualification_gap' in agent_data.columns:
            plt.figure(figsize=(18, 12))
            sns.lineplot(
                data=agent_data,
                x=model_data['step'],
                y='qualification_gap',
                hue='sector_type',
                errorbar=None
              )
            plt.title("Brecha de calificación por sector a lo largo del tiempo")
            plt.show()

        # 13. Diversidad vs Productividad
        plt.figure(figsize=(18, 12))
        ax1 = plt.gca()
        ax1.plot(model_data['step'], model_data['sector_diversity'], label='Diversidad Sectorial', color='blue')
        ax2 = ax1.twinx()
        ax2.plot(model_data['step'], model_data['avg_productivity'], label='Productividad', color='red', linestyle='--')
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Diversidad (Índice de Shannon)')
        ax2.set_ylabel('Productividad')
        plt.title('Relación entre Diversidad Sectorial y Productividad')
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.show()

        print("\n=== Estadísticas del Modelo (Final) ===")
        print(model_data.tail(1).T.round(3))
        if 'sector_type' in agent_data.columns:
            print("\n=== Estadísticas por Sector ===")
            sector_stats = agent_data.groupby('sector_type')[['tech', 'innovation_rate', 'productivity', 'diversification']].mean().round(3)
            print(sector_stats)

"""=== Corrida principal ==="""

if __name__ == "__main__":
    print("=== Iniciando simulación ===")

    # Crear el modelo
    model = EconomicModel(n_regions=32)
    print(f"Modelo creado con {len(model.regions)} regiones.")

    # === 2. Obtener estado INICIAL de las regiones (ANTES de correr) ===
    print("Recopilando estado inicial de las regiones...")
    agent_data_initial = []
    for region in model.regions:
        try:
            agent_data_initial.append({
                "id": region.id,
                "sector_type": region.get_primary_sector_type(),
                "tech": region.tech_capability_history[0] if region.tech_capability_history else region.tech_capability,
                "innovation_rate": region.innovation_rate_history[0] if region.innovation_rate_history else region.innovation_rate,
                "diversification": region.diversification_history[0] if region.diversification_history else region.diversification,
                "specialization": region.specialization_history[0] if region.specialization_history else region.specialization,
                "qualification_gap": region.qualification_gap_history[0] if region.qualification_gap_history else region.qualification_gap,
                "employment_rate": region.employment_rate_history[0] if region.employment_rate_history else region.employment_rate
            })
        except Exception as e:
            print(f"Error al recopilar datos iniciales de región {region.id}: {e}")
            continue

    agent_df_initial = pd.DataFrame(agent_data_initial)
    print(f"Estado inicial recopilado: {len(agent_df_initial)} regiones.")

    # === 3. Ejecutar la simulación ===
    print("Ejecutando simulación...")
    model_df = model.run(steps=30)
    print("Simulación completada.")

    # === 4. Obtener estado FINAL de las regiones (DESPUÉS de correr) ===
    print("Recopilando estado final de las regiones...")
    agent_df_final = model.get_agent_data()
    print(f"Estado final recopilado: {len(agent_df_final)} regiones.")

    # === 5. Función: Gráfico comparativo inicio vs. final por grupo ===
    def plot_group_comparison(agent_df_initial, agent_df_final):
        """Gráfico de barras comparando inicio y final por grupo de CT inicial."""
        def get_group(region_id):
            if region_id < 8:
                return "Baja CT"
            elif region_id < 16:
                return "Moderada CT"
            elif region_id < 24:
                return "Alta CT"
            else:
                return "Muy Alta CT"

        # Asegurar que ambos DataFrames tengan la columna 'id'
        if 'id' not in agent_df_initial.columns:
            print("Advertencia: 'id' no está en agent_df_initial")
            return
        if 'id' not in agent_df_final.columns:
            print("Advertencia: 'id' no está en agent_df_final")
            return

        agent_df_initial['group'] = agent_df_initial['id'].apply(get_group)
        agent_df_final['group'] = agent_df_final['id'].apply(get_group)

        metrics = ['tech', 'innovation_rate', 'diversification', 'specialization', 'qualification_gap', 'employment_rate']
        titles = {
            'tech': 'Capacidad Tecnológica',
            'innovation_rate': 'Tasa de Innovación',
            'diversification': 'Diversificación',
            'specialization': 'Especialización',
            'qualification_gap': 'Brecha de Calificación',
            'employment_rate': 'Tasa de Empleo'
        }

        fig, axes = plt.subplots(3, 2, figsize=(16, 14))
        axes = axes.flatten()

        for i, metric in enumerate(metrics):
            ax = axes[i]
            groups = ["Baja CT", "Moderada CT", "Alta CT", "Muy Alta CT"]
            x = np.arange(len(groups))
            width = 0.35

            # Calcular promedios por grupo
            try:
                initial_means = agent_df_initial.groupby('group')[metric].mean()
                final_means = agent_df_final.groupby('group')[metric].mean()
            except KeyError:
                print(f"Advertencia: métrica '{metric}' no encontrada.")
                continue

            bars1 = ax.bar(x - width/2, initial_means[groups], width, label='Inicio', color='skyblue', edgecolor='black', alpha=0.8)
            bars2 = ax.bar(x + width/2, final_means[groups], width, label='Final', color='salmon', edgecolor='black', alpha=0.8)

            ax.set_title(titles[metric], fontsize=12, fontweight='bold')
            ax.set_xlabel('Grupo por CT Inicial')
            ax.set_ylabel('Valor Promedio')
            ax.set_xticks(x)
            ax.set_xticklabels(groups, rotation=15)
            ax.legend()
            ax.grid(True, axis='y', alpha=0.3)

            # === ANOTAR VALORES CORRECTAMENTE ===
            for bars, means in [(bars1, initial_means), (bars2, final_means)]:
                for j, bar in enumerate(bars):
                    group = groups[j]
                    if group in means.index:
                        height = means[group]
                        ax.annotate(f'{height:.3f}',
                                    xy=(bar.get_x() + bar.get_width() / 2, height),
                                    xytext=(0, 3), textcoords="offset points",
                                    ha='center', va='bottom', fontsize=8, fontweight='bold')

        plt.suptitle('Comparación Inicio vs. Final por Grupo de Regiones (CT Inicial)', fontsize=16, fontweight='bold')
        plt.tight_layout(rect=[0, 0, 1, 0.97])
        plt.savefig('group_comparison_initial_vs_final.png', dpi=300, bbox_inches='tight')
        plt.show()

        # Mostrar tablas
        print("\n=== VALORES PROMEDIO AL INICIO ===")
        print(agent_df_initial.groupby('group')[metrics].mean().round(3))
        print("\n=== VALORES PROMEDIO AL FINAL ===")
        print(agent_df_final.groupby('group')[metrics].mean().round(3))

    # Llamar a la función de gráficos
    try:
        plot_group_comparison(agent_df_initial, agent_df_final)
    except Exception as e:
        print(f"Error al generar gráfico de comparación: {e}")

    # === 6. Exportar resultados ===
    try:
        model.export_results(model_df, agent_df_final, base_filename="main_run")
        print("Resultados exportados exitosamente.")
    except Exception as e:
        print(f"Error al exportar resultados: {e}")

    # === 7. Análisis final ===
    try:
        model_data, agent_data = model.get_results()
        print("\n=== ÚLTIMOS VALORES DEL MODELO ===")
        print(model_data[['step', 'avg_tech', 'sector_diversity', 'pct_trapped']].tail())
        print(f"\nRegiones atrapadas al final: {agent_data['trapped'].sum()}")
    except Exception as e:
        print(f"Error al obtener resultados finales: {e}")

    print("=== Simulación completada ===")

model_df, agent_df = model.get_results()
print("Regiones atrapadas al final:", agent_df['trapped'].sum())
print("Duración promedio de la trampa:", agent_df['trap_duration'].mean())
print("CT promedio de regiones atrapadas:", agent_df[agent_df['trapped']]['tech'].mean())

# Visualizar
model.plot_results()

# Cargar y mostrar el estado final de las regiones
agent_df = pd.read_csv('main_run_agents.csv')
print(agent_df.head())

# Mostrar métricas del modelo
model_df = pd.read_csv('main_run_model.csv')
print(model_df.tail())

# Descargar los archivos
files.download('main_run_model.csv')
files.download('main_run_agents.csv')

# Gráficos
files.download('group_comparison_initial_vs_final.png')

"""# === Simulación con diferentes semillas ==="""

SEEDS = [999, 15, 156, 789, 6666, 2024, 42, 6123, 456,556, 88, 746]

SEEDS = [42, 6123, 456]

SEEDS = [789, 6666, 2024]

SEEDS = [999, 15, 156]

# === DIRECTORIO PARA GUARDAR RESULTADOS ===
OUTPUT_DIR = "calibrated_runs"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# === PARÁMETROS BASE ===
BASE_PARAMS = {
    "INITIAL_TECH": 0.12,
    "PROFIT_MARGIN_IMPACT": 0.68,
    "TECH_DEVELOPMENT_COST": 0.15,
    "INITIAL_WORKFORCE_SKILL": 0.28,
    "EDUCATION_INVESTMENT_RATE": 0.04,
    "INNOVATION_BASE_RATE": 0.01,
    "MIN_INNOVATION_THRESHOLD": 0.05,
    "KNOWLEDGE_SPILLOVER": 0.1,
    "INNOVATION_ACCELERATION": 0.02,
    "WORKER_POOL_SIZE": 10000000,
    "PRODUCTIVITY_BASE_VARIABILITY": 0.15,
    "LEARNING_RATE": 0.08,
    "TECH_PRODUCTIVITY_IMPACT": 0.55,
    "WORKFORCE_PRODUCTIVITY_IMPACT": 0.6,
    "SECTOR_CHANGE_BASE_RATE": 0.03,
    "KNOWLEDGE_INTENSITY_THRESHOLD": 0.3,
    "SECTOR_RELATEDNESS_THRESHOLD": 0.2,
    "EMPLOYMENT_BASE_VOLATILITY": 0.06,
    "SKILL_MISMATCH_PENALTY": 0.38,
    "TECH_EMPLOYMENT_IMPACT": 0.5,
    "ECONOMIC_CYCLE_LENGTH": 6,
    "DIVERSITY_INNOVATION_BONUS": 0.2,
    "DIVERSITY_SHOCK_RESILIENCE": 0.8,
    "MIN_DIVERSITY_FOR_CHANGE": 0.4,
    "DIVERSITY_DYNAMICS": {
        'base_rate': 0.05,
        'tech_influence': 0.3,
        'mobility_factor': 0.2,
        'min_variation': 0.1
    },
    "ABSORPTION_CAPACITY_FACTOR": 0.1,
    "POLICY_SUPPORT_INNOVATION": 0.1,
    "FDI_ATTRACTIVENESS_FACTOR": 0.15,
    "PRIVATE_RD_PROPENSITY": 0.05,
    "TRAP_ESCAPE_PROBABILITY": 0.01,
    "SKILL_GAP_INNOVATION_PENALTY": 0.56,
}

"""Simulación con múltiples semillas (Calibración)"""

def run_calibrated_simulation(seed, params, n_regions=32, steps=30, run_id=""):
    """
    Ejecuta una simulación con una semilla y parámetros dados.
    :param seed: Semilla aleatoria
    :param params: Diccionario de parámetros
    :param n_regions: Número de regiones
    :param steps: Número de pasos
    :param run_id: Identificador de la corrida
    :return: Diccionario con resultados
    """
    # Aplicar parámetros
    for key, value in params.items():
        globals()[key] = value

    # Fijar semilla
    random.seed(seed)
    np.random.seed(seed)

    # Ejecutar simulación
    model = EconomicModel(n_regions=n_regions)
    model.run(steps=steps)
    model_data, agent_data = model.get_results()

    # Calcular métricas clave
    num_trapped = int(agent_data['trapped'].sum())
    pct_trapped = num_trapped / n_regions
    avg_tech = model_data['avg_tech'].iloc[-1]
    sector_diversity = model_data['sector_diversity'].iloc[-1]

    # Guardar resultados
    base_name = f"{OUTPUT_DIR}/run_{run_id}_seed_{seed}"
    model.export_results(model_data, agent_data, base_name, seed)
    model.plot_results()
    generate_pdf_report(model_data, agent_data, filename=f"{base_name}_report.pdf")

    return {
        'seed': seed,
        'run_id': run_id,
        'num_trapped': num_trapped,
        'pct_trapped': pct_trapped,
        'avg_tech_final': avg_tech,
        'sector_diversity_final': sector_diversity,
        'params': params.copy(),
        'output_prefix': base_name
    }


def search_calibrated_runs(target_min=23, target_max=28):
    """
    Busca corridas que tengan entre `target_min` y `target_max` regiones atrapadas.
    """
    results = []
    print(f"Buscando corridas con {target_min}–{target_max} regiones atrapadas...\n")

    for i, seed in enumerate(SEEDS):
        run_id = f"calib_{i+1:02d}"
        print(f"Corrida {run_id}: Semilla = {seed}")

        try:
            result = run_calibrated_simulation(seed, BASE_PARAMS, run_id=run_id)
            results.append(result)

            status = "✅ ¡Calibrado!" if target_min <= result['num_trapped'] <= target_max else "❌ Fuera de rango"
            print(f"  Regiones atrapadas: {result['num_trapped']}/32 → {status}\n")

        except Exception as e:
            print(f"  ❌ Error en la corrida: {e}\n")
            continue

    # Guardar resumen
    results_df = pd.DataFrame(results)
    results_df.to_csv(f"{OUTPUT_DIR}/resumen_corridas.csv", index=False)

    # Filtrar corridas exitosas
    calibrated = results_df[
        (results_df['num_trapped'] >= target_min) &
        (results_df['num_trapped'] <= target_max)
    ]
    calibrated.to_csv(f"{OUTPUT_DIR}/corridas_calibradas.csv", index=False)

    print(f"\n=== RESUMEN FINAL ===")
    print(f"Total de corridas: {len(results_df)}")
    print(f"Corridas calibradas ({target_min}–{target_max}): {len(calibrated)}")
    if len(calibrated) > 0:
        print(f"Semillas recomendadas: {calibrated['seed'].tolist()}")
    else:
        print("⚠️ No se encontraron corridas calibradas.")

    return results_df, calibrated

def generate_pdf_report(model_data, agent_data, filename="informe_simulacion.pdf"):
    """Genera un informe PDF con resultados."""
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", "B", 16)
    pdf.cell(0, 10, "Informe de Simulación Calibrada", ln=True, align="C")
    pdf.set_font("Arial", "", 10)
    pdf.cell(0, 10, f"Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M')}", ln=True, align="C")
    pdf.ln(10)

    # Resumen
    pdf.set_font("Arial", "B", 14)
    pdf.cell(0, 10, "1. Resumen Ejecutivo", ln=True)
    pdf.set_font("Arial", "", 10)
    pct_trapped = agent_data['trapped'].mean()
    num_trapped = int(pct_trapped * 32)
    pdf.multi_cell(0, 6, f"- Regiones atrapadas: {num_trapped} de 32 ({pct_trapped:.1%})".encode('latin-1', 'replace').decode('latin-1'))
    pdf.multi_cell(0, 6, f"- Tecnología promedio final: {model_data['avg_tech'].iloc[-1]:.3f}".encode('latin-1', 'replace').decode('latin-1'))
    pdf.multi_cell(0, 6, f"- Diversidad sectorial final: {model_data['sector_diversity'].iloc[-1]:.3f}".encode('latin-1', 'replace').decode('latin-1'))
    pdf.ln(5)

    # Gráficos
    charts = [
        'metrics_by_agglomeration.png',
        'gini_productivity.png',
        'gini_tech.png',
        'agglomeration_distribution.png',
        'correlation_matrix_model.png',
        'region_clustering.png',
        'trapped_distribution_final.png'
    ]

    for chart in charts:
        if os.path.exists(chart):
            pdf.image(chart, x=10, w=180)
            pdf.ln(5)

    # Conclusión
    pdf.add_page()
    pdf.set_font("Arial", "B", 14)
    pdf.cell(0, 10, "2. Conclusión", ln=True)
    if 23 <= num_trapped <= 28:
        conclusion = "✅ La simulación está bien calibrada."
    else:
        conclusion = "⚠️ La simulación necesita ajuste."
    pdf.multi_cell(0, 6, conclusion.encode('latin-1', 'replace').decode('latin-1'))
    pdf.output(filename)

"""Proceso de validación (independiente)"""

def run_multiple_simulations(n_runs=5, steps=30):
    all_model_dfs = []
    all_agent_dfs = []
    for seed in range(n_runs):
        np.random.seed(seed)
        random.seed(seed)
        model = EconomicModel(n_regions=32)
        model_df = model.run(steps=steps)
        agent_df = model.get_agent_data()
        agent_df['run'] = seed
        all_model_dfs.append(model_df)
        all_agent_dfs.append(agent_df)
    return pd.concat(all_model_dfs), pd.concat(all_agent_dfs)

    model_df_avg = run_multiple_simulations().groupby('step').mean()


def check_stability_and_convergence(df, metric='pct_trapped', threshold=0.02):
    """Verifica estabilidad (baja varianza) y convergencia (tendencia estable)."""
    mean_val = df[metric].mean()
    std_val = df[metric].std()
    cv = std_val / mean_val if mean_val != 0 else np.inf

    print(f"\n=== VALIDACIÓN DE ESTABILIDAD ===")
    print(f"Media de {metric}: {mean_val:.4f}")
    print(f"Desviación estándar: {std_val:.4f}")
    print(f"Coeficiente de variación (CV): {cv:.4f}")

    if cv < threshold:
        print(f"✅ Estable: CV < {threshold}")
    else:
        print(f"❌ Inestable: CV ≥ {threshold}")

    return cv < threshold

def sensitivity_analysis(param_name, param_values, metric='pct_trapped', steps=30):
    """Analiza la sensibilidad del modelo a cambios en un parámetro."""
    results = []
    base_value = BASE_PARAMS[param_name]

    for value in param_values:
        # Modificar parámetro
        temp_params = BASE_PARAMS.copy()
        temp_params[param_name] = value

        # Ejecutar simulación
        seed = SEEDS[len(results) % len(SEEDS)]
        random.seed(seed)
        np.random.seed(seed)

        # Aplicar parámetro temporal
        globals()[param_name] = value
        model = EconomicModel(n_regions=32)
        model.run(steps=steps)
        model_data, agent_data = model.get_results() # Get both dataframes
        result_metric = model_data[metric].mean() # Use model_data for the metric

        results.append({'param_value': value, 'metric': result_metric})

        # Restaurar parámetro base
        globals()[param_name] = base_value

    # Mostrar resultados
    sens_df = pd.DataFrame(results)
    print(sens_df)

    # Gráfico
    plt.figure(figsize=(10, 6))
    plt.plot(sens_df['param_value'], sens_df['metric'], marker='o', linewidth=2)
    plt.xlabel(param_name)
    plt.ylabel(metric)
    plt.title(f'Sensibilidad: {param_name} vs {metric}')
    plt.grid(True)
    plt.savefig(f"{OUTPUT_DIR}/sensitivity_{param_name}.png")
    plt.show()

    return sens_df

"""Ejecutar solo calibración"""

if __name__ == "__main__":
    print("=== EJECUTANDO CALIBRACIÓN ===")
    all_results, calibrated_runs = search_calibrated_runs(target_min=23, target_max=28)

    if len(calibrated_runs) > 0:
        print("\n=== CORRIDAS CALIBRADAS ENCONTRADAS ===")
        print(calibrated_runs[['run_id', 'seed', 'num_trapped']])
    else:
        print("\nNo se encontraron corridas calibradas.")

"""# =============================================
# Modulo de validación ABM
# =============================================
Módulo avanzado de validación para el modelo económico basado en agentes.
Incluye: Validación de estabilidad, escenarios extremos, convergencia, análisis Sobol y estructura para validación participativa.
'''

Ejecutar solo validación de estabilidad
"""

if __name__ == "__main__":
    print("=== VALIDACIÓN DE ESTABILIDAD ===")
    multi_run_df, _ = run_multiple_simulations(n_runs=5, steps=30)
    check_stability_and_convergence(multi_run_df, metric='pct_trapped', threshold=0.02)

    print("\n=== ANÁLISIS DE SENSIBILIDAD ===")
    sensitivity_analysis('TRAP_ESCAPE_PROBABILITY', [0.01, 0.015, 0.02, 0.025, 0.03], metric='pct_trapped')
    sensitivity_analysis('KNOWLEDGE_SPILLOVER', [0.10, 0.15, 0.18, 0.20, 0.25], metric='pct_trapped')
    sensitivity_analysis('POLICY_SUPPORT_INNOVATION', [0.0, 0.1, 0.2, 0.3], metric='pct_trapped')

"""# =============================================
# 1. ANÁLISIS DE ESCENARIOS EXTREMOS
# =============================================
"""

# === DIRECTORIO DE RESULTADOS ===
OUTPUT_DIR = "calibrated_runs"
os.makedirs(OUTPUT_DIR, exist_ok=True)

def run_extreme_scenario(base_params, modifications, seed=556, n_regions=32, steps=30, scenario_name="scenario"):
    """
    Ejecuta un escenario con modificaciones extremas.
    :param base_params: Diccionario de parámetros base.
    :param modifications: Diccionario de parámetros modificados.
    :param seed: Semilla aleatoria.
    :param n_regions: Número de regiones.
    :param steps: Número de pasos.
    :param scenario_name: Nombre del escenario.
    :return: DataFrame con resultados del modelo.
    """
    # Aplicar modificaciones
    temp_params = base_params.copy()
    temp_params.update(modifications)

    # Aplicar parámetros globales
    for key, value in temp_params.items():
        globals()[key] = value

    # Fijar semilla
    import random
    import numpy as np
    random.seed(seed)
    np.random.seed(seed)

    # Ejecutar modelo (asumiendo que EconomicModel está disponible)
    try:
        from economic_model import EconomicModel  # Ajusta el nombre si es diferente
    except ImportError:
        raise ImportError("No se pudo importar EconomicModel. Asegúrate de tener economic_model.py")

    model = EconomicModel(n_regions=n_regions)
    model.run(steps=steps)
    model_data, agent_data = model.get_results()

    # Guardar resultados
    base_name = f"{OUTPUT_DIR}/{scenario_name}"
    model.export_results(model_data, agent_data, base_name, seed)

    return model_data, agent_data, modifications


def compare_scenarios(base_params, scenario_configs, steps=30):
    """
    Compara múltiples escenarios extremos con el escenario base.
    """
    results = {}

    # Escenario base
    base_data, base_agent, _ = run_extreme_scenario(
        base_params, {}, steps=steps, scenario_name="base_run"
    )
    results["Base"] = {
        "model_data": base_data,
        "agent_data": base_agent,
        "modifications": {}
    }

    # Escenarios extremos
    for name, mods in scenario_configs.items():
        print(f"Ejecutando escenario: {name}")
        try:
            model_data, agent_data, mods_final = run_extreme_scenario(
                base_params, mods, steps=steps, scenario_name=f"scenario_{name}"
            )
            results[name] = {
                "model_data": model_data,
                "agent_data": agent_data,
                "modifications": mods_final
            }
        except Exception as e:
            print(f"Error en escenario {name}: {e}")
            continue

    # Generar gráficos comparativos
    plot_scenario_comparison(results)
    export_scenario_summary(results)

    return results


def plot_scenario_comparison(results):
    """
    Gráficos comparativos entre escenarios.
    """
    metrics = ['avg_tech', 'pct_trapped', 'avg_productivity', 'sector_diversity']
    titles = {
        'avg_tech': 'Capacidad Tecnológica Promedio',
        'pct_trapped': 'Regiones Atrapadas',
        'avg_productivity': 'Productividad Promedio',
        'sector_diversity': 'Diversidad Sectorial'
    }

    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    axes = axes.flatten()

    for i, metric in enumerate(metrics):
        ax = axes[i]
        for name, data in results.items():
            df = data["model_data"]
            ax.plot(df['step'], df[metric], label=name, linewidth=2.5)
        ax.set_title(titles[metric])
        ax.set_xlabel('Paso')
        ax.set_ylabel(metric.replace('_', ' ').title())
        ax.legend()
        ax.grid(True, alpha=0.3)

    plt.suptitle('Comparación de Escenarios Extremos', fontsize=16, fontweight='bold')
    plt.tight_layout(rect=[0, 0, 1, 0.96])
    plt.savefig(f"{OUTPUT_DIR}/comparison_extreme_scenarios.png", dpi=300, bbox_inches='tight')
    plt.show()


def export_scenario_summary(results):
    """
    Exporta resumen de escenarios a CSV.
    """
    summary = []
    for name, data in results.items():
        final_step = data["model_data"].iloc[-1]
        summary.append({
            "Scenario": name,
            "Final_Avg_Tech": final_step['avg_tech'],
            "Final_Pct_Trapped": final_step['pct_trapped'],
            "Final_Productivity": final_step['avg_productivity'],
            "Final_Sector_Diversity": final_step['sector_diversity'],
            "Modifications": str(data["modifications"])
        })

    summary_df = pd.DataFrame(summary)
    summary_df.to_csv(f"{OUTPUT_DIR}/scenario_summary.csv", index=False)
    print(f"\nResumen de escenarios exportado a {OUTPUT_DIR}/scenario_summary.csv")

"""# =============================================
# 2. ANÁLISIS DE CONVERGENCIA
# =============================================
"""

def analyze_convergence(model_data, metric='avg_tech', threshold=0.001, window=5):
    """
    Analiza si una métrica converge tras suficientes pasos.
    """
    series = model_data[metric].rolling(window=window).mean().dropna()
    diffs = np.abs(np.diff(series))
    converged_step = None
    for i, diff in enumerate(diffs):
        if diff < threshold:
            if i + window >= len(series) * 0.8:  # Debe converger en la última parte
                converged_step = i + window
                break

    plt.figure(figsize=(10, 6))
    plt.plot(model_data['step'], model_data[metric], label='Original')
    plt.plot(series.index, series.values, label='Suavizado (rolling)', linewidth=3)
    if converged_step:
        plt.axvline(x=converged_step, color='r', linestyle='--', label=f'Convergencia estimada (step {converged_step})')
    plt.title(f'Convergencia de {metric}')
    plt.xlabel('Paso')
    plt.ylabel(metric.replace('_', ' ').title())
    plt.legend()
    plt.grid(True)
    plt.savefig(f"{OUTPUT_DIR}/convergence_{metric}.png")
    plt.show()

    return converged_step

"""# =============================================
# 3. SOBOL SENSITIVITY ANALYSIS
# =============================================
"""

def sobol_sensitivity_analysis(base_params, steps=30, problem=None):
    """
    Realiza un análisis de sensibilidad global usando el método Sobol.
    """
    if problem is None:
        problem = {
            'num_vars': 5,
            'names': ['INNOVATION_BASE_RATE', 'KNOWLEDGE_SPILLOVER', 'TRAP_ESCAPE_PROBABILITY',
                      'SKILL_GAP_INNOVATION_PENALTY', 'PRIVATE_RD_PROPENSITY'],
            'bounds': [
                [0.010, 0.020],
                [0.10, 0.25],
                [0.01, 0.05],
                [0.40, 0.70],
                [0.05, 0.15]
            ]
        }

    # Muestra de Saltelli
    param_values = saltelli.sample(problem, 64)  # 64 * (2D + 2) muestras

    # Ejecutar simulaciones
    Y = []  # Salida: pct_trapped final
    print(f"Ejecutando {len(param_values)} simulaciones para Sobol...")

    for i, params in enumerate(param_values):
        temp_params = base_params.copy()
        for j, name in enumerate(problem['names']):
            temp_params[name] = params[j]

        try:
            _, agent_data, _ = run_extreme_scenario(
                base_params, temp_params, steps=steps,
                scenario_name=f"sobol_run_{i}"
            )
            pct_trapped = agent_data['trapped'].mean()
        except:
            pct_trapped = np.nan

        Y.append(pct_trapped)
        if (i + 1) % 50 == 0:
            print(f"  Progreso: {i + 1}/{len(param_values)}")

    Y = np.array(Y)
    Y = Y[~np.isnan(Y)]  # Eliminar NaN
    param_values = param_values[~np.isnan(Y)]
    Y = Y[:len(param_values)]  # Asegurar igual longitud

    # Análisis Sobol
    Si = sobol.analyze(problem, Y, print_to_console=False)

    # Graficar
    fig, ax = plt.subplots(figsize=(10, 6))
    indices = ['S1', 'ST']
    names = problem['names']
    x = np.arange(len(names))
    width = 0.35

    for i, idx in enumerate(indices):
        values = Si[idx]
        ax.bar(x + i * width, values, width, label=f'{idx} (Primer/Total)')

    ax.set_xlabel('Parámetro')
    ax.set_ylabel('Índice de Sensibilidad')
    ax.set_title('Análisis de Sensibilidad Sobol')
    ax.set_xticks(x + width / 2)
    ax.set_xticklabels(names, rotation=45)
    ax.legend()
    ax.grid(True, axis='y', alpha=0.3)
    plt.tight_layout()
    plt.savefig(f"{OUTPUT_DIR}/sobol_sensitivity.png", dpi=300, bbox_inches='tight')
    plt.show()

    # Exportar resultados
    sobol_df = pd.DataFrame({
        'Parameter': names,
        'S1': Si['S1'],
        'S1_conf': Si['S1_conf'],
        'ST': Si['ST'],
        'ST_conf': Si['ST_conf']
    })
    sobol_df.to_csv(f"{OUTPUT_DIR}/sobol_results.csv", index=False)
    print(f"Resultados Sobol exportados a {OUTPUT_DIR}/sobol_results.csv")

    return Si, sobol_df

"""# =============================================
# 4. VALIDACIÓN PARTICIPATIVA (Estructura)
# =============================================
"""

def generate_participatory_report(model_data, agent_data, filename="participatory_report.pdf"):
    """
    Genera un informe visual para validación con expertos.
    """
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", "B", 16)
    pdf.cell(0, 10, "Informe para Validación Participativa", ln=True, align="C")
    pdf.set_font("Arial", "", 10)
    pdf.cell(0, 10, f"Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M')}", ln=True, align="C")
    pdf.ln(10)

    # Preguntas clave
    questions = [
        "¿La evolución de la diversidad sectorial parece realista?",
        "¿El número de regiones atrapadas es plausible?",
        "¿La relación entre tecnología y productividad es coherente?",
        "¿Los cambios de sector ocurren en momentos creíbles?",
        "¿La brecha de calificación se comporta como en la realidad?"
    ]

    pdf.set_font("Arial", "B", 14)
    pdf.cell(0, 10, "1. Preguntas para Expertos", ln=True)
    pdf.set_font("Arial", "", 10)
    for q in questions:
        pdf.multi_cell(0, 6, f"• {q}")
    pdf.ln(10)

    # Incluir gráficos clave
    charts = [
        'metrics_by_agglomeration.png',
        'group_comparison_initial_vs_final.png',
        'trapped_distribution_final.png',
        'diversity_vs_productivity.png'
    ]
    for chart in charts:
        if os.path.exists(chart):
            pdf.image(chart, x=10, w=180)
            pdf.ln(5)

    pdf.output(filename)
    print(f"Informe de validación participativa generado: {filename}")

"""# =============================================
# 5. EJECUCIÓN DEL MÓDULO
# =============================================
"""

if __name__ == "__main__":
    print("=== VALIDACIÓN AVANZADA DEL MODELO ===\n")

    # Parámetros base (debe coincidir con el modelo principal)
    BASE_PARAMS = {
        "INITIAL_TECH": 0.12,
        "INNOVATION_BASE_RATE": 0.015,
        "KNOWLEDGE_SPILLOVER": 0.18,
        "TRAP_ESCAPE_PROBABILITY": 0.02,
        "SKILL_GAP_INNOVATION_PENALTY": 0.56,
        "PRIVATE_RD_PROPENSITY": 0.09,
        "ABSORPTION_CAPACITY_FACTOR": 0.15,
        "POLICY_SUPPORT_INNOVATION": 0.1,
        "WORKER_POOL_SIZE": 3200000,
        # ... otros parámetros (ajustar según tu modelo)
    }

    # Configuración de escenarios extremos
    SCENARIO_CONFIGS = {
        "Sin Innovación": {"INNOVATION_BASE_RATE": 0.0},
        "Alto Spillover": {"KNOWLEDGE_SPILLOVER": 0.35},
        "Fácil Escape": {"TRAP_ESCAPE_PROBABILITY": 0.10},
        "Gran Brecha": {"SKILL_GAP_INNOVATION_PENALTY": 0.90},
        "Sin I+D Privado": {"PRIVATE_RD_PROPENSITY": 0.01}
    }

    # 1. Escenarios extremos
    print("1. Ejecutando escenarios extremos...")
    results = compare_scenarios(BASE_PARAMS, SCENARIO_CONFIGS, steps=30)

    # 2. Convergencia (usando el escenario base)
    print("\n2. Analizando convergencia...")
    base_model_data = results["Base"]["model_data"]
    for metric in ['avg_tech', 'pct_trapped', 'sector_diversity']:
        step = analyze_convergence(base_model_data, metric=metric)
        status = "Sí" if step else "No"
        print(f"  {metric}: convergencia estimada en paso {step} → {status}")

    # 3. Sensibilidad Sobol
    print("\n3. Ejecutando análisis Sobol (esto puede tardar varios minutos)...")
    Si, sobol_df = sobol_sensitivity_analysis(BASE_PARAMS, steps=20)

    # 4. Informe participativo
    print("\n4. Generando informe para validación participativa...")
    base_agent_data = results["Base"]["agent_data"]
    generate_participatory_report(base_model_data, base_agent_data)

    print("\n=== VALIDACIÓN AVANZADA COMPLETADA ===")
    print(f"Todos los resultados se guardaron en: {OUTPUT_DIR}")