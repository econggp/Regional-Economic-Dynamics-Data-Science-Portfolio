# -*- coding: utf-8 -*-
"""abm_vf.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WvI7G2HYr-P8prFP2_Zau_pZZa8a1jfk
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import defaultdict
from matplotlib.gridspec import GridSpec

# Configuración inicial
sns.set_style('darkgrid')
sns.set_palette("viridis")
plt.rcParams['figure.figsize'] = [20, 13]

# Implementación del coeficiente Gini
def gini_coefficient(x):
    """Coeficiente de Gini"""
    x = np.abs(x)
    x = np.sort(x)
    n = len(x)
    cumx = np.cumsum(x)
    return (n + 1 - 2 * np.sum(cumx) / cumx[-1]) / n

# Parámetros globales
INITIAL_TECH = 0.09
PROFIT_MARGIN_IMPACT = 0.7
TECH_DEVELOPMENT_COST = 0.12
INITIAL_WORKFORCE_SKILL = 0.3
EDUCATION_INVESTMENT_RATE = 0.03
INNOVATION_BASE_RATE = 0.05
MIN_INNOVATION_THRESHOLD = 0.05
KNOWLEDGE_SPILLOVER = 0.3
INNOVATION_ACCELERATION = 0.02
WORKER_POOL_SIZE = 100000
PRODUCTIVITY_BASE_VARIABILITY = 0.15
LEARNING_RATE = 0.08
TECH_PRODUCTIVITY_IMPACT = 0.55
WORKFORCE_PRODUCTIVITY_IMPACT = 0.6
SECTOR_CHANGE_BASE_RATE = 0.03
KNOWLEDGE_INTENSITY_THRESHOLD = 0.3
SECTOR_RELATEDNESS_THRESHOLD = 0.2
EMPLOYMENT_BASE_VOLATILITY = 0.06
SKILL_MISMATCH_PENALTY = 0.2
TECH_EMPLOYMENT_IMPACT = 0.5
ECONOMIC_CYCLE_LENGTH = 20
DIVERSITY_INNOVATION_BONUS = 0.2
DIVERSITY_SHOCK_RESILIENCE = 0.8
MIN_DIVERSITY_FOR_CHANGE = 0.4
DIVERSITY_DYNAMICS = {
    'base_rate': 0.05,
    'tech_influence': 0.3,
    'mobility_factor': 0.2,
    'min_variation': 0.1
}

# Sectores económicos, detalle y características específicas
SECTORS = {
    1: "Agricultura Tradicional",
    2: "Agricultura Tecnificada",
    3: "Minería Básica",
    4: "Minería Tecnológica",
    5: "Manufactura Básica",
    6: "Manufactura Avanzada",
    7: "Servicios Básicos",
    8: "Servicios Financieros",
    9: "Servicios Tecnológicos",
    10: "Turismo Masivo",
    11: "Turismo Especializado"
}

# Categorización de sectores por tipo y nivel tecnológico
SECTOR_TYPES = {
    'Primario_Bajo': [1, 3],
    'Primario_Alto': [2, 4],
    'Manufactura_Baja': [5],
    'Manufactura_Alta': [6],
    'Servicios_Bajos': [7],
    'Servicios_Intermedios': [8],
    'Servicios_Avanzados': [9],
    'Turismo_Masivo': [10],
    'Turismo_Especializado': [11]
}

# Parámetros detallados por tipo de sector
SECTOR_PARAMS = {
    'Primario_Bajo': {
        'margin_range': (0.25, 0.45),
        'tech_invest': 0.05,
        'volatility': 0.35,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.7, 0.8),
        'training_investment': 0.05,
        'innovation_capacity': 0.1,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.7,
        'productivity': 5,
        'product_range': (3, 7),
        'max_employment': 1
    },
    'Primario_Alto': {
        'margin_range': (0.35, 0.55),
        'tech_invest': 0.25,
        'volatility': 0.25,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.75, 0.85),
        'training_investment': 0.15,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9),
        'max_employment': 1
    },
    'Manufactura_Baja': {
        'margin_range': (0.15, 0.3),
        'tech_invest': 0.2,
        'volatility': 0.2,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.85),
        'training_investment': 0.1,
        'innovation_capacity': 0.25,
        'knowledge_intensity': 0.35,
        'linkages': 0.6,
        'specialization_coeff': 0.5,
        'productivity': 8,
        'product_range': (6, 10),
        'max_employment': 1
    },
    'Manufactura_Alta': {
        'margin_range': (0.25, 0.4),
        'tech_invest': 0.4,
        'volatility': 0.15,
        'skill_requirements': (0.6, 0.8),
        'employment_rate': (0.8, 0.9),
        'training_investment': 0.2,
        'innovation_capacity': 0.5,
        'knowledge_intensity': 0.7,
        'linkages': 0.8,
        'specialization_coeff': 0.4,
        'productivity': 10,
        'product_range': (8, 14),
        'max_employment': 1
    },
    'Servicios_Bajos': {
        'margin_range': (0.2, 0.4),
        'tech_invest': 0.1,
        'volatility': 0.15,
        'skill_requirements': (0.3, 0.5),
        'employment_rate': (0.75, 0.9),
        'training_investment': 0.08,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.3,
        'linkages': 0.4,
        'specialization_coeff': 0.3,
        'productivity': 6,
        'product_range': (4, 8),
        'max_employment': 1
    },
    'Servicios_Intermedios': {
        'margin_range': (0.3, 0.5),
        'tech_invest': 0.25,
        'volatility': 0.1,
        'skill_requirements': (0.5, 0.7),
        'employment_rate': (0.8, 0.95),
        'training_investment': 0.15,
        'innovation_capacity': 0.35,
        'knowledge_intensity': 0.5,
        'linkages': 0.7,
        'specialization_coeff': 0.2,
        'productivity': 9,
        'product_range': (7, 11),
        'max_employment': 1
    },
    'Servicios_Avanzados': {
        'margin_range': (0.4, 0.65),
        'tech_invest': 0.45,
        'volatility': 0.1,
        'skill_requirements': (0.7, 0.9),
        'employment_rate': (0.85, 0.8),
        'training_investment': 0.25,
        'innovation_capacity': 0.7,
        'knowledge_intensity': 0.9,
        'linkages': 0.9,
        'specialization_coeff': 0.1,
        'productivity': 12,
        'product_range': (10, 14),
        'max_employment': 1
    },
    'Turismo_Masivo': {
        'margin_range': (0.2, 0.5),
        'tech_invest': 0.05,
        'volatility': 0.4,
        'skill_requirements': (0.2, 0.4),
        'employment_rate': (0.6, 0.9),
        'training_investment': 0.03,
        'innovation_capacity': 0.15,
        'knowledge_intensity': 0.2,
        'linkages': 0.3,
        'specialization_coeff': 0.8,
        'productivity': 5,
        'product_range': (3, 7),
        'max_employment': 1
    },
    'Turismo_Especializado': {
        'margin_range': (0.3, 0.6),
        'tech_invest': 0.15,
        'volatility': 0.3,
        'skill_requirements': (0.4, 0.6),
        'employment_rate': (0.7, 0.9),
        'training_investment': 0.1,
        'innovation_capacity': 0.3,
        'knowledge_intensity': 0.4,
        'linkages': 0.5,
        'specialization_coeff': 0.6,
        'productivity': 7,
        'product_range': (5, 9),
        'max_employment': 1
    }
}

class Product:
    """Clase para modelar productos/servicios de una región"""
    def __init__(self, sector_type, product_id):
        params = SECTOR_PARAMS[sector_type]
        self.id = product_id
        self.name = f"Product_{sector_type}_{product_id}"
        self.revenue = random.uniform(*params['product_range'])
        self.cost = random.uniform(0.4, 0.8) * self.revenue
        self.production = random.uniform(3, 16)
        self.tech_intensity = random.uniform(0.1, params['knowledge_intensity'])
        self.skill_required = random.uniform(*params['skill_requirements'])

    def calculate_margin(self):
        return (self.revenue - self.cost) / self.revenue

class Worker:
    """Clase para modelar trabajadores individuales con sus habilidades"""
    def __init__(self, sector_type=None):
        if sector_type:
            params = SECTOR_PARAMS[sector_type]
            self.skill = random.uniform(
                max(0.1, params['skill_requirements'][0] - 0.2),
                min(1.0, params['skill_requirements'][1] + 0.1)
            )
            self.specialized_skill = random.uniform(0.5, 1.1) # Habilidad específica para el sector
        else:
            self.skill = random.uniform(0.1, 0.6) # Trabajador no especializado
            self.specialized_skill = 0.0

        self.employed = False
        self.region_id = None
        self.sector_type = sector_type

    def improve_skills(self, training_investment, tech_exposure):
        """Mejora habilidades con más variabilidad"""
        # Efecto no lineal del entrenamiento
        training_effect = 0.5 * (1 - np.exp(-2 * training_investment))

        # Efecto de la tecnología con curva de aprendizaje
        tech_effect = 0.6 * (1 - np.exp(-1.5 * tech_exposure))

        # Variabilidad individual
        individual_factor = random.uniform(0.8, 1.2)

        skill_gain = (training_effect + tech_effect) * individual_factor * 0.2
        self.skill = np.clip(self.skill + skill_gain, 0.1, 1.0)

        if self.sector_type:
           specialized_gain = (training_effect * 1.2 + tech_effect * 0.8) * individual_factor * 0.25
           self.specialized_skill = np.clip(
            self.specialized_skill + specialized_gain,
            0.1, 1.0
           )

class Workforce:
    """Clase para modelar la fuerza laboral con mayor detalle en cualificación"""
    def __init__(self, sector_type, region_id):
        self.params = SECTOR_PARAMS[sector_type]
        params = SECTOR_PARAMS[sector_type]
        self.workers = []
        self.sector_type = sector_type
        self.region_id = region_id
        self.training_investment = params['training_investment']
        self.skill_requirements = random.uniform(*params['skill_requirements'])
        self.min_specialized_skill = 0.6 # Mínimo requerido para trabajadores especializados
        self.update_metrics()

    def update_metrics(self):
        """Actualiza métricas con requisitos dinámicos"""
        # Hacer los requisitos sensibles a la tecnología
        tech_factor = 1 + (self.region.tech_capability if hasattr(self, 'region') else 0)
        volatility = self.params['volatility']
        self.skill_requirements = np.clip(
        random.uniform(*self.params['skill_requirements']) * tech_factor,
        self.params['skill_requirements'][0],
        self.params['skill_requirements'][1] * 1.5
    )

        # Actualizar métricas normales
        if self.workers:
           self.avg_skill = np.mean([w.skill for w in self.workers])
           self.avg_specialized_skill = np.mean([w.specialized_skill for w in self.workers])
           gap = max(0, self.skill_requirements - self.avg_skill)
           self.qualification_gap = gap * (1 + 0.3*random.uniform(-1, 1)*volatility)
        else:
           self.avg_skill = 0
           self.avg_specialized_skill = 0
           self.qualification_gap = self.skill_requirements

    def hire_workers(self, num_workers, worker_pool):
        """Contrata trabajadores del pool de trabajadores disponibles"""
        hired = 0
        available_workers = [w for w in worker_pool if not w.employed]
        # Primero intentar contratar trabajadores con habilidades especializadas
        specialized_workers = [w for w in available_workers if w.sector_type == self.sector_type]
        for worker in specialized_workers[:min(num_workers, len(specialized_workers))]:
            worker.employed = True
            worker.region_id = self.region_id
            self.workers.append(worker)
            hired += 1
        # Luego contratar trabajadores sin habilidades especializadas
        remaining = num_workers - hired
        if remaining > 0:
            general_workers = [w for w in available_workers if w not in specialized_workers]
            for worker in general_workers[:min(remaining, len(general_workers))]:
                worker.employed = True
                worker.region_id = self.region_id
                worker.sector_type = self.sector_type
                self.workers.append(worker)
                hired += 1

        self.update_metrics()
        return hired

    def fire_workers(self, num_workers):
        """Despide trabajadores, comenzando por los menos calificados"""
        if not self.workers:
            return 0

        self.workers.sort(key=lambda x: x.skill + x.specialized_skill)

        fired = 0
        for _ in range(min(num_workers, len(self.workers))):
            worker = self.workers.pop(0)
            worker.employed = False
            worker.region_id = None
            fired += 1

        self.update_metrics()
        return fired

    def adjust_workforce(self, required_workers, worker_pool):
        """Ajusta la fuerza laboral a los trabajadores requeridos"""
        current = len(self.workers)
        if current < required_workers:
            self.hire_workers(required_workers - current, worker_pool)
        elif current > required_workers:
            self.fire_workers(current - required_workers)

    def evaluate_workers(self):
        """Evalúa y posiblemente despide trabajadores que no cumplen los requisitos"""
        to_fire = []
        for worker in self.workers:
            if (worker.skill < self.skill_requirements * 0.7 or
                (worker.specialized_skill < self.min_specialized_skill * 0.7)):
                to_fire.append(worker)

        for worker in to_fire:
            self.workers.remove(worker)
            worker.employed = False
            worker.region_id = None

        self.update_metrics()
        return len(to_fire)

    def train_workers(self, tech_exposure):
        """Entrena y mejora las habilidades de los trabajadores"""
        for worker in self.workers:
            worker.improve_skills(self.training_investment, tech_exposure)
        self.update_metrics()

    def wage_inequality(self):
        """Calcula la desigualdad salarial usando el coeficiente de Gini."""
        if not self.workers:
            return 0  # Sin trabajadores, no hay desigualdad

        # Asumiendo que la habilidad está relacionada con el salario
        wages = [worker.skill for worker in self.workers]
        return gini_coefficient(wages)

class Region:
    """Clase que representa una región con su economía y fuerza laboral"""
    def __init__(self, region_id, worker_pool):
        self.id = region_id
        self.worker_pool = worker_pool
        self.sector_id = random.choice(list(SECTORS.keys()))
        self.sector_type = self.get_sector_type()
        self.sector_name = SECTORS[self.sector_id]
        self.params = SECTOR_PARAMS[self.sector_type]

        # Variables económicas
        self.tech_capability = INITIAL_TECH
        self.profit_margin = random.uniform(*self.params['margin_range'])
        self.productivity = self.params['productivity']
        self.specialization = self.params['specialization_coeff']
        self.diversification = 1 - self.specialization
        self.innovation_rate = 0.0
        self.trapped = False
        self.employment_rate = random.uniform(*self.params['employment_rate'])
        self.steps = 0

        # Productos/servicios
        self.products = [
            Product(self.sector_type, i) for i in range(random.randint(2, 6))
        ]
        self.total_production = sum(p.production for p in self.products)

        # Fuerza laboral
        self.workforce = Workforce(self.sector_type, self.id)
        self.required_workers = max(1, int(self.total_production / self.productivity))
        self.workforce.hire_workers(self.required_workers, self.worker_pool)

        # Historial
        self.specialization_history = [self.specialization]
        self.diversification_history = [self.diversification]
        self.qualification_gap_history = [self.workforce.qualification_gap]

    def get_sector_type(self):
        """Determina el tipo de sector"""
        for sector_type, ids in SECTOR_TYPES.items():
            if self.sector_id in ids:
                return sector_type
        return 'Primario_Bajo'

    def consider_sector_change(self):
        """Evalúa si la región debe cambiar de sector económico"""
        if random.random() < SECTOR_CHANGE_BASE_RATE:
          if self.workforce.qualification_gap > 0.3:
            return
            # Factores que influyen en el cambio
            tech_push = max(0, self.tech_capability - self.params['knowledge_intensity'])
            margin_pull = max(0, self.params['margin_range'][1] - self.profit_margin)
            innovation_push = self.innovation_rate * 2

            change_probability = SECTOR_CHANGE_BASE_RATE * (1 + self.diversification)

            if random.random() < change_probability:
                # Buscar sectores relacionados pero más avanzados
                possible_sectors = [
                    k for k, v in SECTOR_PARAMS.items()
                    if v['knowledge_intensity'] <= self.tech_capability * 1.2
                    and v['margin_range'][1] > self.profit_margin
                ]

                if possible_sectors:
                    new_sector = random.choice(possible_sectors)
                    new_sector_id = random.choice(SECTOR_TYPES[new_sector])
                    self.sector_id = new_sector_id
                    self.sector_type = new_sector
                    self.sector_name = SECTORS[new_sector_id]
                    self.params = SECTOR_PARAMS[new_sector]

                    # Ajustar tecnología al nuevo sector
                    self.tech_capability = max(INITIAL_TECH, self.tech_capability * 0.8)

                    # Reemplazar algunos productos
                    if self.products:
                        num_to_replace = min(2, len(self.products))
                        for _ in range(num_to_replace):
                            self.products.pop(random.randint(0, len(self.products)-1))
                            self.products.append(Product(new_sector, len(self.products)+1))

    def update(self):
        """Actualiza el estado de la región"""
        # Perturbaciones externas
        self.external_shocks()

        # Toma de decisiones estratégicas
        self.make_strategic_decision()

        # Ajustar productos/servicios
        self.adjust_products()

        # Innovación
        self.innovate()

        # Actualizar fuerza laboral
        self.update_workforce()

        # Actualizar métricas de desempeño
        self.update_performance()

        # Verificar trampa de innovación
        self.check_innovation_trap()

        # Considerar cambio de sector
        self.consider_sector_change()

        # Registrar historial
        self.specialization_history.append(self.specialization)
        self.diversification_history.append(self.diversification)
        self.qualification_gap_history.append(self.workforce.qualification_gap)

        # Incrementar contador de pasos
        self.steps += 1
        self.innovation_rate += random.uniform(-0.02, 0.03)
        self.employment_rate = np.clip(self.employment_rate + random.uniform(-0.03, 0.03), 0.5, 1.0)

    def external_shocks(self):
        """Simula perturbaciones externas a la región"""
        # Shock general (economía, demanda)
        shock_factor = random.uniform(0.85, 1.15) ** (1 + self.params['volatility'])
        self.total_production *= shock_factor

        # Shock en márgenes (competencia, costos)
        margin_shock = random.normalvariate(0, 0.09) * self.params['volatility']
        self.profit_margin = np.clip(
             self.profit_margin + margin_shock,
             self.params['margin_range'][0] * 0.8,
             self.params['margin_range'][1] * 1.1
        )

        # Shock en productividad (innovaciones, fallas)
        productivity_shock = random.normalvariate(0, 0.1) * (1 - self.tech_capability/2)
        self.productivity = np.clip(
             self.productivity * (1 + productivity_shock),
             self.params['productivity'] * 0.5,
             self.params['productivity'] * 2.0
        )

        # Eventos raros pero impactantes (crisis, boom tecnológico)
        if random.random() < 0.02:
           big_shock = random.uniform(-0.4, 0.6)
           self.productivity *= (1 + big_shock)

        # Evento sectorial con baja probabilidad (1%)
        if random.random() < 0.01:
           shock_magnitude = random.uniform(-0.4, 0.5)

        # Afectar productividad
        self.productivity *= (1 + productivity_shock/2)

        # Regiones diversificadas son menos afectadas
        if self.diversification > 0.7:
           shock_factor = shock_factor ** 0.8  # Reduce impacto del shock

        self.total_production *= shock_factor

    def make_strategic_decision(self):
        """Toma decisiones sobre inversión en tecnología vs márgenes"""
        if random.random() < self.params['tech_invest'] * (1 - self.profit_margin):
            tech_investment = random.uniform(0.05, 0.15) * (1 + self.diversification)
            self.tech_capability += tech_investment
            self.profit_margin = max(
                self.params['margin_range'][0],
                self.profit_margin - random.uniform(0.03, 0.09)
        )
        else:
            margin_increase = random.uniform(0, 0.05) * self.specialization
            self.profit_margin += margin_increase
            self.tech_capability = max(
                INITIAL_TECH,
                self.tech_capability - random.uniform(0, 0.03)
        )

    def adjust_products(self):
        """Ajusta la cartera de productos/servicios de la región"""
        # 1. Eliminar productos no rentables con cierta probabilidad
        to_remove = []
        for product in self.products:
            if (product.calculate_margin() < self.profit_margin * 0.7 and
                random.random() < 0.3):
                to_remove.append(product)

        # Eliminar productos seleccionados
        for product in to_remove:
            self.products.remove(product)
            self.total_production -= product.production

        # 2. Innovación de productos --- tres tipos posibles
        if random.random() < self.innovation_rate:
            innovation_type = random.choices(
                ['incremental', 'sector_relacionado', 'radical'],
                weights=[0.6, 0.3, 0.1]
        )[0]

            if innovation_type == 'incremental':
                new_product = Product(self.sector_type, len(self.products) + 1)
            elif innovation_type == 'sector_relacionado':
                related_sectors = [
                    k for k, v in SECTOR_PARAMS.items()
                    if abs(v['knowledge_intensity'] - self.params['knowledge_intensity']) < 0.2
                    and k != self.sector_type
        ]
                if related_sectors:
                    new_sector = random.choice(related_sectors)
                    new_product = Product(new_sector, len(self.products) + 1)
                else:
                    new_product = Product(self.sector_type, len(self.products) + 1)
            else:
                random_sector = random.choice(list(SECTOR_PARAMS.keys()))
                new_product = Product(random_sector, len(self.products) + 1)

            self.products.append(new_product)
            self.total_production += new_product.production

        # 3. Ocasionalmente agregar producto aleatorio (diversificación espontánea)
        if random.random() < 0.03:
            random_sector = random.choice(list(SECTOR_PARAMS.keys()))
            new_product = Product(random_sector, len(self.products) + 1)
            self.products.append(new_product)
            self.total_production += new_product.production

        # Actualizar trabajadores requeridos
        self.required_workers = max(1, int(self.total_production / self.productivity))

    def innovate(self):
        """Tasas de innovación"""
        if self.tech_capability > MIN_INNOVATION_THRESHOLD:
           tech_factor = 0.2 + self.tech_capability
           skill_factor = 0.1 + self.workforce.avg_skill
           diversification_factor = 0.2 + self.diversification

           self.innovation_rate = (
               INNOVATION_BASE_RATE +
               (tech_factor * skill_factor * self.params['innovation_capacity']) *
               (1 + np.log1p(self.steps * INNOVATION_ACCELERATION * 2.5))
        )
        if random.random() < 0.02:  # Probabilidad baja de evento radical
           self.innovation_rate += random.uniform(0.05, 0.15)

        # Transferencia tecnológica
        if hasattr(self, 'other_regions'):
            avg_neighbor_tech = np.mean([r.tech_capability for r in self.other_regions])
            if avg_neighbor_tech > self.tech_capability:
                tech_transfer = KNOWLEDGE_SPILLOVER * 1.5 * (avg_neighbor_tech - self.tech_capability)
                self.tech_capability = min(1.0, self.tech_capability + tech_transfer)
                self.innovation_rate = min(0.3, self.innovation_rate * 1.2)  # Bonus por transferencia

        # Evento de innovación
        if random.random() < self.innovation_rate:
            tech_gain = random.uniform(0.02, 0.15) * (1 + self.diversification)
            self.tech_capability = min(1.0, self.tech_capability + tech_gain)

            if random.random() < 0.3:
                new_product = Product(self.sector_type, len(self.products) + 1)
                self.products.append(new_product)
                self.total_production += new_product.production
        else:
             self.innovation_rate = 0

        # Penalizar innovación si la brecha es grande
        innovation_penalty = self.workforce.qualification_gap * 0.5  # Hasta 50% menos innovación

        self.innovation_rate = (
             INNOVATION_BASE_RATE +
             (tech_factor * skill_factor * self.params['innovation_capacity']) *
             (1 - innovation_penalty)
            )

        # Bonus por diversidad sectorial (combinar conocimientos)
        diversity_bonus = self.diversification * 0.2

        self.innovation_rate = (
             INNOVATION_BASE_RATE +
             (tech_factor * skill_factor * self.params['innovation_capacity']) *
             (1 + diversity_bonus)  # ¡Nuevo!
            )

    def update_workforce(self):
        """Actualización de fuerza laboral"""
        # Calcular demanda base de trabajadores
        base_demand = max(1, int(self.total_production / self.productivity))

        # Factores de ajuste
        tech_impact = TECH_EMPLOYMENT_IMPACT * (1 - self.tech_capability)
        skill_gap_impact = SKILL_MISMATCH_PENALTY * self.workforce.qualification_gap
        economic_cycle = self.economic_cycle_effect()

        # Calcular demanda ajustada
        adjusted_demand = base_demand * economic_cycle * (1 - tech_impact - skill_gap_impact)
        self.required_workers = max(1, int(adjusted_demand* random.uniform(0.9, 1.1)))

        # Ajustar fuerza laboral con inercia
        current_workers = len(self.workforce.workers)
        change = self.required_workers - current_workers
        max_change = max(1, int(current_workers * 0.25))

        if abs(change) > max_change:
           change = max_change if change > 0 else -max_change

        # Manejar contrataciones y despidos por separado
        hired = 0
        if change > 0:
           hired = self.workforce.hire_workers(change, self.worker_pool)
           if hired < change:  # Solo aplica si no se pudo contratar suficiente personal
               self.total_production *= (hired / change)
        elif change < 0:
            # En caso de despidos
            self.workforce.fire_workers(-change)

        # Entrenamiento y evaluación
        self.workforce.evaluate_workers()
        self.workforce.train_workers(self.tech_capability)
        self.compete_for_workers()

        # Calcular tasa de empleo
        if self.required_workers > 0:
           actual_workers = len(self.workforce.workers)
           self.employment_rate = actual_workers / self.required_workers

           # Añadir variabilidad realista
           employment_noise = random.uniform(1 - EMPLOYMENT_BASE_VOLATILITY,
                                         1 + EMPLOYMENT_BASE_VOLATILITY)
           self.employment_rate = np.clip(
                                         self.employment_rate * employment_noise,
                                         0.5,
                                         self.params['max_employment']
        )
        else:
            self.employment_rate = 0

        # Costo adicional si la brecha es alta
        if self.workforce.qualification_gap > 0.2:
           self.profit_margin -= 0.01  # 1% menos margen por costos de capacitación

        # Entrenamiento más intensivo si la brecha es grande
        training_intensity = min(
           0.3,
           self.workforce.qualification_gap * 0.5  # Hasta 30% más entrenamiento
           )
        self.workforce.train_workers(self.tech_capability + training_intensity)


    def economic_cycle_effect(self):
        """Efecto de ciclo económico en el empleo"""
        # Posición en el ciclo (0 a 1)
        cycle_pos = (self.steps % ECONOMIC_CYCLE_LENGTH) / ECONOMIC_CYCLE_LENGTH

        # Curva senoidal suavizada para ciclos económicos
        if cycle_pos < 0.25:  # Expansión
           multiplier = 0.9 + 0.1 * (cycle_pos * 4)
        elif cycle_pos < 0.5:  # Pico
           multiplier = 1.05 - 0.1 * ((cycle_pos - 0.25) * 4)
        elif cycle_pos < 0.75:  # Recesión
           multiplier = 0.8 - 0.2 * ((cycle_pos - 0.5) * 4)
        else:  # Recuperación
           multiplier = 0.7 + 0.2 * ((cycle_pos - 0.75) * 4)

        # Sector-specific volatility
        sector_volatility = self.params['volatility']

        # Añadir aleatoriedad basada en volatilidad del sector
        noise = random.uniform(-0.1, 0.1) * sector_volatility * 2

        return multiplier + noise

    def compete_for_workers(self):
        """Competencia por trabajadores calificados con otras regiones"""
        if not hasattr(self, 'other_regions'):
            return

        if self.workforce.qualification_gap > 0.1:
            for region in random.sample(self.other_regions, min(3, len(self.other_regions))):
                if region.id == self.id:
                    continue

                qualified_workers = [
                    w for w in region.workforce.workers
                    if w.skill > self.workforce.avg_skill and
                    w.specialized_skill > self.workforce.avg_specialized_skill
        ]

                if qualified_workers and len(self.workforce.workers) < self.required_workers:
                    num_to_steal = min(len(qualified_workers), max(1, int(self.required_workers * 0.1)))
                    for _ in range(num_to_steal):
                        if len(self.workforce.workers) >= self.required_workers:
                            break
                        worker = random.choice(qualified_workers)
                        region.workforce.workers.remove(worker)
                        region.workforce.update_metrics()
                        self.workforce.workers.append(worker)
                        worker.region_id = self.id
                        self.workforce.update_metrics()

    def update_performance(self):
        """Actualiza métricas de desempeño económico con mayor dinamismo."""
        # Factores que afectan la productividad
        workforce_impact = (
            0.5 * self.workforce.avg_skill *
            (1 + self.workforce.avg_specialized_skill / 2) *
            (1 - 0.3 * self.workforce.qualification_gap)  # ¡Nuevo! Penalización directa por brecha
            )
        tech_impact = 0.6 * self.tech_capability * (1 - 0.2 * self.workforce.qualification_gap)  # La brecha reduce la eficacia de la tecnología

        # Efecto de la diversificación (curva en U invertida)
        diversification_impact = 2.5 * self.diversification * (1 - self.diversification)

        # Efecto de aprendizaje por experiencia
        learning_effect = np.log1p(self.steps) * 0.1

        # Variabilidad aleatoria (innovación, shocks)
        random_effect = random.uniform(-0.1, 0.1) * (1 - self.tech_capability/2)

        # Productividad base del sector
        sector_base = self.params['productivity']

        # Cálculo final de productividad con límites
        min_productivity = sector_base * 0.6
        max_productivity = sector_base * 1.8

        self.productivity = np.clip(
            sector_base * (1 + workforce_impact + tech_impact + diversification_impact +
                          learning_effect + random_effect),
            min_productivity,
            max_productivity
        )

        # Actualizar especialización/diversificación basado en rendimiento
        margin_factor = self.profit_margin / self.params['margin_range'][1]

        if margin_factor > 0.8:
            self.specialization = min(
                0.95,
                self.specialization + random.uniform(0, 0.09) * margin_factor
        )
        else:
            if random.random() < 0.4:
                self.specialization = max(
                    0.05,
                    self.specialization - random.uniform(0, 0.09) * (1 - margin_factor)
        )

        self.diversification = 1 - self.specialization

        # Efecto de la trampa de innovación en productividad
        if self.trapped:
            self.productivity = max(
                min_productivity,
                self.productivity * 0.98
        )
        # Efecto del empleo en la productividad
        employment_impact = 0.4 * (self.employment_rate - 0.8)
        self.productivity *= (1 + employment_impact)

        # Efecto de la tasa de empleo en los márgenes
        if self.employment_rate > 0.95:
           # Escasez de trabajadores -> mayores costos laborales
           self.profit_margin *= 0.98
        elif self.employment_rate < 0.85:
             # Desempleo -> posible reducción de costos
           self.profit_margin *= 1.02

    def check_innovation_trap(self):
        """Determina si la región cae en trampa de innovación"""
        conditions = (
            self.tech_capability < 0.3,
            self.profit_margin > 0.5,
            self.innovation_rate < 0.03,
            self.workforce.qualification_gap > 0.3,
            self.diversification < 0.3,
            len(self.products) <= 3
        )

        self.trapped = sum(conditions) >= 4

        if self.trapped:
            self.profit_margin = min(0.9, self.profit_margin * 1.02)
            self.tech_capability = max(0.1, self.tech_capability * 0.98)
            self.diversification = max(0.05, self.diversification * 0.95)
            self.specialization = 1 - self.diversification

class EconomicModel:
    """Modelo económico completo con todas las regiones."""
    def __init__(self, n_regions=32):
        self.worker_pool = [Worker() for _ in range(WORKER_POOL_SIZE)]
        self.regions = [Region(i, self.worker_pool) for i in range(n_regions)]
        self.sector_diversity_history = []
        self.qualification_gap_history = []

        for region in self.regions:
            region.other_regions = [r for r in self.regions if r.id != region.id]

        self.steps = 0
        self.history = []

    def step(self):
        """Avanza la simulación un paso"""
        for region in random.sample(self.regions, len(self.regions)):
            region.update()

        self.record_state()
        self.steps += 1

    def run(self, steps=40):
        """Ejecuta la simulación para varios pasos"""
        for _ in range(steps):
            self.step()

    def calculate_sector_diversity(self):
        """Calcula la diversidad sectorial con más dinamismo"""
        sector_counts = pd.Series([r.sector_type for r in self.regions]).value_counts()
        total = len(self.regions)

        # Suavizado más agresivo y ponderación por tecnología
        proportions = (sector_counts + 1e-6) / (total + 1e-6 * len(SECTOR_PARAMS))
        shannon = -np.sum(proportions * np.log(proportions))

        mobility = 0
        if len(self.history) > 1:
           prev_sectors = self.history[-1].get('sector_types', [])
           current_sectors = [r.sector_type for r in self.regions]
           mobility = len(set(current_sectors) - set(prev_sectors)) / len(SECTOR_PARAMS)


        tech_by_sector = defaultdict(list)
        for r in self.regions:
            tech_by_sector[r.sector_type].append(r.tech_capability)
        tech_variation = np.std([np.mean(v) for v in tech_by_sector.values()]) / np.mean([np.mean(v) for v in tech_by_sector.values()])


        # Penalizar si un sector domina (>40% de las regiones)
        dominance_penalty = 0
        if sector_counts.max() / total > 0.4:
           dominance_penalty = 0.5 * (sector_counts.max() / total - 0.4)

        return 0.7*shannon + 0.2*tech_variation + 0.1*mobility - dominance_penalty

         # Añadir ruido controlado
        noise = random.uniform(-0.05, 0.05) * (1 - np.mean(tech_weights))
        return np.clip(shannon + noise, 0, np.log(len(SECTOR_PARAMS)))

    def calculate_tech_diversity(self):
        """Calcula la diversidad tecnológica usando el coeficiente de variación."""
        tech_levels = [r.tech_capability for r in self.regions]
        mean_tech = np.mean(tech_levels)

        if mean_tech == 0:
           return 0.0

        std_dev = np.std(tech_levels)
        return std_dev / mean_tech


    def record_state(self):
        """Registra el estado actual del modelo con todas las métricas."""
        current_state = {
            "step": self.steps,
            "sector_types": [r.sector_type for r in self.regions],
            "sector_diversity": self.calculate_sector_diversity(),
            "qualification_gap": np.mean([r.workforce.qualification_gap for r in self.regions]),
            "max_qualification_gap": np.max([r.workforce.qualification_gap for r in self.regions]),
            "sector_volatility": np.std([r.params['volatility'] for r in self.regions]),
            "diversity_product_ratio": self.calculate_sector_diversity() / (len(self.regions)/10),
            "avg_tech": np.mean([r.tech_capability for r in self.regions]),
            "avg_margin": np.mean([r.profit_margin for r in self.regions]),
            "avg_productivity": np.mean([r.productivity for r in self.regions]),
            "avg_innovation": np.mean([r.innovation_rate for r in self.regions]),
            "avg_diversification": np.mean([r.diversification for r in self.regions]),
            "avg_specialization": np.mean([r.specialization for r in self.regions]),
            "sector_diversity": self.calculate_sector_diversity(),
            "tech_diversity": self.calculate_tech_diversity(),
            "pct_trapped": np.mean([1 if r.trapped else 0 for r in self.regions]),
            "employment_rate": np.mean([r.employment_rate for r in self.regions]),
            "tech_inequality": gini_coefficient([r.tech_capability for r in self.regions]),
            "skill_inequality": np.mean([r.workforce.wage_inequality() for r in self.regions]),
            "qualification_gap": np.mean([r.workforce.qualification_gap for r in self.regions])
        }

        # Calcular diversidad de productos
        all_products = []
        for r in self.regions:
            all_products.extend([p.name for p in r.products])
        current_state["unique_products"] = len(set(all_products)) if all_products else 0
        current_state["product_diversity"] = current_state["unique_products"] / len(self.regions) if len(self.regions) > 0 else 0

        # Agregar métricas por sector
        for sector_type in SECTOR_PARAMS.keys():
            sector_regions = [r for r in self.regions if r.sector_type == sector_type]
            if sector_regions:
                current_state[f"tech_{sector_type}"] = np.mean([r.tech_capability for r in sector_regions])
                current_state[f"innov_{sector_type}"] = np.mean([r.innovation_rate for r in sector_regions])

        self.history.append(current_state)

    def get_results(self):
        """Obtiene los resultados asegurando la estructura correcta del DataFrame."""
        # Crear DataFrame del modelo
        model_data = pd.DataFrame(self.history)

        # Datos de los agentes (regiones)
        agent_data = []
        for region in self.regions:
            agent_data.append({
                "id": region.id,
                "sector_type": region.sector_type,
                "sector_name": region.sector_name,
                "tech": region.tech_capability,
                "margin": region.profit_margin,
                "productivity": region.productivity,
                "innovation_rate": region.innovation_rate,
                "diversification": region.diversification,
                "specialization": region.specialization,
                "num_products": len(region.products),
                "qualification_gap": region.workforce.qualification_gap,
                "trapped": region.trapped,
                "employment_rate": region.employment_rate
            })

        return model_data, pd.DataFrame(agent_data)

def visualize_results_individual(model_data, agent_data):
    """Función de visualización que genera gráficas individuales."""
    # 1. Evolución de métricas principales

    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    metrics = ['tech_inequality', 'avg_tech']
    labels = ['Desigualdad Tecnológica (Índice Gini)', 'Nivel Tecnológico Promedio']
    colors = ['#1f77b4', '#ff7f0e']  # Azul y naranja
    for metric, label, color in zip(metrics, labels, colors):
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label=label, color=color)

    ax2 = ax1.twinx()
    if 'avg_innovation' in model_data.columns:
      ax2.plot(model_data['step'], model_data['avg_innovation'], label='Tasa de Innovación', color='black', linestyle='--')

    ax1.set_title('Evolución de Indicadores Tecnológicos y de Innovación')
    ax1.set_xlabel('Pasos de Simulación')
    ax1.set_ylabel('Valor de Métricas Tecnológicas')
    ax1.tick_params(axis='y')
    ax2.set_ylabel('Innovación')
    ax2.tick_params(axis='y')
    ax1.legend(loc='upper left', bbox_to_anchor=(0.01, 0.99), fontsize=10)
    ax2.legend(loc='upper right', bbox_to_anchor=(0.01, 0.94), fontsize=10)

    ax1.grid(True)

    plt.show()

    # 2. Diversidad sectorial y tecnológica
    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    main_metrics = ['tech_diversity']
    for metric in main_metrics:
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label='Diversidad Tecnológica')
    ax2 = ax1.twinx()
    if 'sector_diversity' in model_data.columns:
      ax2.plot(model_data['step'], model_data['sector_diversity'], label='Diversidad Sectorial', color='black', linestyle='--')

    ax1.set_title('Diversidad Sectorial y Tecnológica')
    ax1.set_xlabel('Pasos de Simulación')
    ax1.set_ylabel('Diversidad Tecnológica')
    ax2.set_ylabel('Diversidad Sectorial')

    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')

    ax1.grid(True)

    plt.show()

    # 3. Productos por sector
    if all(col in agent_data.columns for col in ['sector_type', 'num_products']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='num_products')
        plt.title('Productos por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 4. Innovación por sector
    if all(col in agent_data.columns for col in ['sector_type', 'innovation_rate']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='innovation_rate')
        plt.title('Innovación por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 5. Tecnología por sector
    if all(col in agent_data.columns for col in ['sector_type', 'tech']):
        plt.figure(figsize=(18, 12))
        sns.boxplot(data=agent_data, x='sector_type', y='tech')
        plt.title('Tecnología por Sector')
        plt.xticks(rotation=45)
        plt.grid(True)
        plt.show()

    # 6. Correlaciones entre variables del modelo
    numeric_cols = [col for col in model_data.columns
               if col != 'step'
               and pd.api.types.is_numeric_dtype(model_data[col])
               and col not in ['sector_volatility', 'skill_inequality']]  # Exclusión de columnas

    if len(numeric_cols) > 1:
       plt.figure(figsize=(20, 13))
       sns.heatmap(model_data[numeric_cols].corr(), annot=True, cmap='coolwarm', fmt='.2f')
       plt.title('Correlaciones entre Variables del Modelo')
       plt.xticks(rotation=45)
       plt.yticks(rotation=0)
       plt.tight_layout()
       plt.show()

    # 7. Correlaciones entre variables de agentes
    agent_numeric = agent_data.select_dtypes(include=np.number).columns.tolist()
    if len(agent_numeric) > 1:
        plt.figure(figsize=(18, 12))
        sns.heatmap(agent_data[agent_numeric].corr(), annot=True, cmap='viridis')
        plt.title('Correlaciones entre Variables de Regiones')
        plt.show()

    # 8. Regiones atrapadas vs no atrapadas
    if 'trapped' in agent_data.columns:
        trapped_vars = ['tech', 'innovation_rate', 'diversification', 'productivity', 'specialization', 'qualification_gap', 'employment_rate']
        trapped_vars = [var for var in trapped_vars if var in agent_data.columns]
        if trapped_vars:
            plt.figure(figsize=(18, 12))
            trapped_stats = agent_data.groupby('trapped')[trapped_vars].mean().T
            trapped_stats.plot(kind='bar')
            plt.title('Comparación Regiones Atrapadas vs No Atrapadas')
            plt.grid(True)
            plt.show()

    # 9. Evolución de productividad vs MBI
    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    main_metrics = ['avg_productivity']
    for metric in main_metrics:
        if metric in model_data.columns:
           ax1.plot(model_data['step'], model_data[metric], label='Promedio Productividad')
    ax2 = ax1.twinx()
    if 'avg_margin' in model_data.columns:
      ax2.plot(model_data['step'], model_data['avg_margin'], label='MBI promedio', color='black', linestyle='--')

    ax1.set_title('Productividad vs. MBI (Promedios)')
    ax1.set_xlabel('Step')
    ax1.set_ylabel('Productividad')
    ax2.set_ylabel('MBI')

    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')

    ax1.grid(True)

    plt.show()

    # 10. Porcentaje de regiones atrapadas
    if 'pct_trapped' in model_data.columns:
        plt.figure(figsize=(18, 12))
        plt.plot(model_data['step'], model_data['pct_trapped'])
        plt.title('Porcentaje de Regiones Atrapadas')
        plt.grid(True)
        plt.show()

    # 11. Distribución de sectores a lo largo del tiempo (simplificada)
    if 'sector_type' in agent_data.columns and 'step' in model_data.columns:
        sector_counts = agent_data.groupby('sector_type').size().reset_index(name='count')
        plt.figure(figsize=(20, 13))
        plt.pie(sector_counts['count'], labels=sector_counts['sector_type'], autopct='%1.1f%%')
        plt.title('Distribución Sectorial')
        plt.show()

    # 12. Evolución de la brecha de calificación por sector
    if 'qualification_gap' in agent_data.columns:
        plt.figure(figsize=(18, 12))
        sns.lineplot(
            data=agent_data,
            x=model_data['step'],
            y='qualification_gap',
            hue='sector_type',
            errorbar=None
           )
        plt.title("Brecha de calificación por sector a lo largo del tiempo")
        plt.show()

    # 13. Diversidad vs Productividad
    plt.figure(figsize=(18, 12))
    ax1 = plt.gca()
    ax1.plot(model_data['step'], model_data['sector_diversity'], label='Diversidad Sectorial', color='blue')
    ax2 = ax1.twinx()
    ax2.plot(model_data['step'], model_data['avg_productivity'], label='Productividad', color='red', linestyle='--')
    ax1.set_xlabel('Pasos')
    ax1.set_ylabel('Diversidad (Índice de Shannon)')
    ax2.set_ylabel('Productividad')
    plt.title('Relación entre Diversidad Sectorial y Productividad')
    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')
    plt.show()

    # Análisis estadístico detallado
    print("\n=== Estadísticas del Modelo ===")
    print(model_data.describe().round(3))

    print("\n=== Estadísticas por Sector ===")
    if 'sector_type' in agent_data.columns:
        sector_stats = agent_data.groupby('sector_type').agg({
            'tech': ['mean', 'std'],
            'innovation_rate': ['mean', 'std'],
            'num_products': ['mean', 'std'],
            'diversification': ['mean', 'std'],
            'productivity': ['mean', 'std']
        })
        print(sector_stats.round(3))

    print("\n=== Comparación Regiones Atrapadas ===")
    if 'trapped' in agent_data.columns:
        trapped_comparison = agent_data.groupby('trapped').agg({
            'tech': 'mean',
            'innovation_rate': 'mean',
            'diversification': 'mean',
            'num_products': 'mean',
            'productivity': 'mean'
        })
        print(trapped_comparison.round(3))

# Ejecución del modelo con visualización individual
model = EconomicModel(n_regions=32)
model.run(steps=30)
model_data, agent_data = model.get_results()

# Visualización de resultados individuales
visualize_results_individual(model_data, agent_data)