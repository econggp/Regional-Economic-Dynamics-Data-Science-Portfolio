# -*- coding: utf-8 -*-
"""captecmex.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WEAk7Ie0F7XbxNT4GQtWOc3gPndLrtIf
"""

import random
import matplotlib.pyplot as plt

class Trabajador:
    def __init__(self, calificacion):
        self.calificacion = calificacion

class Empresa:
    def __init__(self, unique_id):
        self.unique_id = unique_id
        self.capacidad_tecnologica = 1
        self.ingresos = 100
        self.costos = 50
        self.productividad = 5
        self.produccion = 50
        self.precio = 10
        self.trabajadores = []
        self.margen_minimo = 0.3
        self.calificacion_minima_requerida = 2
        self.productos = [{"nombre": f"Producto_{i}", "ingresos": 10, "costos": 5, "produccion": 5} for i in range(3)]

    def calcular_margen(self):
        return (self.ingresos - self.costos) / self.ingresos

    def contratar_trabajador(self, calificacion=1):
        self.trabajadores.append(Trabajador(calificacion))

    def despedir_trabajador(self, trabajador=None):
        if trabajador:
            self.trabajadores.remove(trabajador)
        else:
            if self.trabajadores:
                self.trabajadores.pop()

    def ajustar_empleo(self):
        trabajadores_necesarios = max(0, int(self.produccion / self.productividad))
        while len(self.trabajadores) < trabajadores_necesarios:
            self.contratar_trabajador(calificacion=self.calificacion_minima_requerida)
        while len(self.trabajadores) > trabajadores_necesarios:
            self.despedir_trabajador()

    def evaluar_calificacion(self):
        for trabajador in self.trabajadores[:]:
            if trabajador.calificacion < self.calificacion_minima_requerida:
                self.despedir_trabajador(trabajador)

    def ajustar_especializacion(self):
        nuevos_productos = []
        for producto in self.productos:
            margen_producto = (producto["ingresos"] - producto["costos"]) / producto["ingresos"]
            if margen_producto >= self.margen_minimo:
                nuevos_productos.append(producto)
            else:
                self.produccion -= producto["produccion"]
                self.ajustar_empleo()
        self.productos = nuevos_productos

    def simular_perturbaciones_externas(self):
        self.produccion *= random.uniform(0.9, 1.1)
        self.costos *= random.uniform(0.95, 1.05)
        self.ingresos *= random.uniform(0.9, 1.1)

    def competir_por_trabajadores_calificados(self, otras_empresas):
        for otra_empresa in otras_empresas:
            if otra_empresa is not self and len(otra_empresa.trabajadores) > 0:
                trabajador = random.choice(otra_empresa.trabajadores)
                if trabajador.calificacion >= self.calificacion_minima_requerida:
                    self.trabajadores.append(trabajador)
                    otra_empresa.trabajadores.remove(trabajador)

    def innovar_tecnologicamente(self):
        if random.random() < 0.1:
            self.productividad += 0.1
            self.capacidad_tecnologica += 0.1
            self.calificacion_minima_requerida += 1

    def step(self):
        self.simular_perturbaciones_externas()
        self.ajustar_empleo()
        self.evaluar_calificacion()
        self.ajustar_especializacion()
        self.innovar_tecnologicamente()

class ModeloProductivo:
    def __init__(self, N):
        self.num_empresas = N
        self.empresas = [Empresa(i) for i in range(N)]
        self.empleo_total_historia = []
        self.calificacion_promedio_historia = []

    def calcular_empleo_total(self):
        return sum(len(empresa.trabajadores) for empresa in self.empresas)

    def calcular_calificacion_promedio(self):
        total_trabajadores = sum(len(empresa.trabajadores) for empresa in self.empresas)
        total_calificacion = sum(
            sum(trabajador.calificacion for trabajador in empresa.trabajadores)
            for empresa in self.empresas
        )
        return total_calificacion / total_trabajadores if total_trabajadores > 0 else 0

    def step(self):
        random.shuffle(self.empresas)
        for empresa in self.empresas:
            empresa.step()
            empresa.competir_por_trabajadores_calificados(self.empresas)

        empleo_total = self.calcular_empleo_total()
        calificacion_promedio = self.calcular_calificacion_promedio()
        self.empleo_total_historia.append(empleo_total)
        self.calificacion_promedio_historia.append(calificacion_promedio)
        print(f"Empleo total: {empleo_total}, Calificación promedio: {calificacion_promedio}")

    def graficar_resultados(self):
        plt.figure(figsize=(12, 6))
        plt.subplot(1, 2, 1)
        plt.plot(self.empleo_total_historia, label="Empleo Total")
        plt.title("Empleo Total a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Empleo Total")
        plt.legend()

        plt.subplot(1, 2, 2)
        plt.plot(self.calificacion_promedio_historia, label="Calificación Promedio", color="orange")
        plt.title("Calificación Promedio a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Calificación Promedio")
        plt.legend()

        plt.tight_layout()
        plt.show()

# Ejecutar el modelo
model = ModeloProductivo(N=10)
for i in range(50):  # Simular 50 pasos
    model.step()

# Graficar resultados
model.graficar_resultados()

import random
import matplotlib.pyplot as plt

class Trabajador:
    def __init__(self, calificacion):
        self.calificacion = calificacion

class Empresa:
    def __init__(self, unique_id):
        self.unique_id = unique_id
        self.capacidad_tecnologica = 1
        self.ingresos = 1000
        self.costos = 50
        self.productividad = 5
        self.produccion = 50
        self.precio = 10
        self.trabajadores = []
        self.margen_minimo = 0.1
        self.calificacion_minima_requerida = 1
        self.productos = [{"nombre": f"Producto_{i}", "ingresos": 10, "costos": 5, "produccion": 5} for i in range(3)]

    def calcular_margen(self):
        return (self.ingresos - self.costos) / self.ingresos

    def contratar_trabajador(self, calificacion=1):
        self.trabajadores.append(Trabajador(calificacion))

    def despedir_trabajador(self, trabajador=None):
        if trabajador:
            self.trabajadores.remove(trabajador)
        else:
            if self.trabajadores:
                self.trabajadores.pop()

    def ajustar_empleo(self):
        trabajadores_necesarios = max(0, int(self.produccion / self.productividad))
        while len(self.trabajadores) < trabajadores_necesarios:
            self.contratar_trabajador(calificacion=self.calificacion_minima_requerida)
        while len(self.trabajadores) > trabajadores_necesarios:
            self.despedir_trabajador()

    def evaluar_calificacion(self):
        for trabajador in self.trabajadores[:]:
            if trabajador.calificacion < self.calificacion_minima_requerida:
                self.despedir_trabajador(trabajador)


    def simular_perturbaciones_externas(self):
        self.produccion *= random.uniform(0.9, 1.1)
        self.costos *= random.uniform(0.95, 1.05)
        self.ingresos *= random.uniform(0.9, 1.1)

    def competir_por_trabajadores_calificados(self, otras_empresas):
        for otra_empresa in otras_empresas:
            if otra_empresa is not self and len(otra_empresa.trabajadores) > 0:
                trabajador = random.choice(otra_empresa.trabajadores)
                if trabajador.calificacion >= self.calificacion_minima_requerida:
                    self.trabajadores.append(trabajador)
                    otra_empresa.trabajadores.remove(trabajador)

    def ajustar_especializacion(self):
        nuevos_productos = []
        for producto in self.productos:
            margen_producto = (producto["ingresos"] - producto["costos"]) / producto["ingresos"]
            if margen_producto >= self.margen_minimo or random.random() < 0.1:  # Probabilidad del 20% de mantener productos
                nuevos_productos.append(producto)
            else:
                self.produccion -= producto["produccion"]
                self.ajustar_empleo()
        self.productos = nuevos_productos

    def innovar_productos(self):
        if random.random() < 0.05:  # Probabilidad del 5% de innovar un nuevo producto
            nuevo_producto = {
                "nombre": f"Producto_Nuevo_{len(self.productos) + 1}",
                "ingresos": random.uniform(5, 15),
                "costos": random.uniform(3, 10),
                "produccion": random.uniform(5, 10)
            }
            self.productos.append(nuevo_producto)
            self.produccion += nuevo_producto["produccion"]

    def innovar_tecnologicamente(self): # Added the missing method to the Empresa class
        if random.random() < 0.1:
            self.productividad += 0.09
            self.capacidad_tecnologica += 0.09
            self.calificacion_minima_requerida += 1


    def step(self):
        self.simular_perturbaciones_externas()
        self.ajustar_empleo()
        self.evaluar_calificacion()
        self.ajustar_especializacion()
        self.innovar_tecnologicamente()
        self.innovar_productos()

class ModeloProductivo:
    def __init__(self, N):
        self.num_empresas = N
        self.empresas = [Empresa(i) for i in range(N)]
        self.empleo_total_historia = []
        self.tasa_desempleo_historia = []
        self.calificacion_promedio_historia = []
        self.brecha_cualificacion_historia = []
        self.diversidad_productiva_historia = []
        self.especializacion_historia = []
        self.capacidades_tecnologicas_historia = []

    def calcular_empleo_total(self):
        return sum(len(empresa.trabajadores) for empresa in self.empresas)

    def calcular_tasa_desempleo(self):
        empleo_total = self.calcular_empleo_total()
        trabajadores_disponibles = 10000  # Ejemplo: pool de trabajadores disponibles
        return 1 - (empleo_total / trabajadores_disponibles)

    def calcular_calificacion_promedio(self):
        total_trabajadores = sum(len(empresa.trabajadores) for empresa in self.empresas)
        total_calificacion = sum(
            sum(trabajador.calificacion for trabajador in empresa.trabajadores)
            for empresa in self.empresas
        )
        return total_calificacion / total_trabajadores if total_trabajadores > 0 else 0

    def calcular_brecha_cualificacion(self):
        total_brecha = sum(
            max(0, empresa.calificacion_minima_requerida - self.calcular_calificacion_promedio())
            for empresa in self.empresas
        )
        return total_brecha / len(self.empresas)

    def calcular_diversidad_productiva(self):
        productos_totales = set(producto["nombre"] for empresa in self.empresas for producto in empresa.productos)
        return len(productos_totales)

    def calcular_especializacion(self):
        especializacion = sum(
            len(empresa.trabajadores) / len(empresa.productos) if empresa.productos else 0
            for empresa in self.empresas
        )
        return especializacion / len(self.empresas)

    def calcular_capacidades_tecnologicas_promedio(self):
        return sum(empresa.capacidad_tecnologica for empresa in self.empresas) / len(self.empresas)

    def step(self):
        random.shuffle(self.empresas)
        for empresa in self.empresas:
            empresa.step()
            empresa.competir_por_trabajadores_calificados(self.empresas)

        empleo_total = self.calcular_empleo_total()
        tasa_desempleo = self.calcular_tasa_desempleo()
        calificacion_promedio = self.calcular_calificacion_promedio()
        brecha_cualificacion = self.calcular_brecha_cualificacion()
        diversidad_productiva = self.calcular_diversidad_productiva()
        especializacion = self.calcular_especializacion()
        capacidades_tecnologicas = self.calcular_capacidades_tecnologicas_promedio()

        self.empleo_total_historia.append(empleo_total)
        self.tasa_desempleo_historia.append(tasa_desempleo)
        self.calificacion_promedio_historia.append(calificacion_promedio)
        self.brecha_cualificacion_historia.append(brecha_cualificacion)
        self.diversidad_productiva_historia.append(diversidad_productiva)
        self.especializacion_historia.append(especializacion)
        self.capacidades_tecnologicas_historia.append(capacidades_tecnologicas)

    def graficar_resultados(self):
        pasos = range(len(self.empleo_total_historia))
        plt.figure(figsize=(18, 12))

        # Empleo Total
        plt.subplot(3, 3, 1)
        plt.plot(pasos, self.empleo_total_historia, label="Empleo Total", color="blue")
        plt.title("Empleo Total a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Empleo Total")
        plt.legend()

        # Tasa de Desempleo
        plt.subplot(3, 3, 2)
        plt.plot(pasos, self.tasa_desempleo_historia, label="Tasa de Desempleo", color="red")
        plt.title("Tasa de Desempleo a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Tasa de Desempleo")
        plt.legend()

        # Calificación Promedio
        plt.subplot(3, 3, 3)
        plt.plot(pasos, self.calificacion_promedio_historia, label="Calificación Promedio", color="green")
        plt.title("Calificación Promedio a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Calificación Promedio")
        plt.legend()

        # Brecha de Cualificación
        plt.subplot(3, 3, 4)
        plt.plot(pasos, self.brecha_cualificacion_historia, label="Brecha de Cualificación", color="orange")
        plt.title("Brecha de Cualificación a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Brecha de Cualificación")
        plt.legend()

        # Diversidad Productiva
        plt.subplot(3, 3, 5)
        plt.plot(pasos, self.diversidad_productiva_historia, label="Diversidad Productiva", color="purple")
        plt.title("Diversidad Productiva a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Diversidad Productiva")
        plt.legend()

        # Especialización
        plt.subplot(3, 3, 6)
        plt.plot(pasos, self.especializacion_historia, label="Especialización", color="brown")
        plt.title("Especialización a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Especialización")
        plt.legend()

        # Capacidades Tecnológicas Promedio
        plt.subplot(3, 3, 7)
        plt.plot(pasos, self.capacidades_tecnologicas_historia, label="Capacidades Tecnológicas", color="teal")
        plt.title("Capacidades Tecnológicas Promedio a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Capacidades Tecnológicas Promedio")
        plt.legend()

        plt.tight_layout()
        plt.show()

# Ejecutar el modelo
model = ModeloProductivo(N=10)
for i in range(100):  # Simular 100 pasos
    model.step()

# Graficar resultados
model.graficar_resultados()

class Empresa:
    def __init__(self, unique_id):
        self.unique_id = unique_id
        self.capacidad_tecnologica = 1
        self.ingresos = 1000
        self.costos = 50
        self.productividad = 5
        self.produccion = 50
        self.precio = 10
        self.trabajadores = []
        self.margen_minimo = 0.3
        self.calificacion_minima_requerida = 1
        self.productos = [{"nombre": f"Producto_{i}", "ingresos": 10, "costos": 5, "produccion": 5} for i in range(3)]

    def calcular_margen(self):
        return (self.ingresos - self.costos) / self.ingresos

    def contratar_trabajador(self, calificacion=1):
        self.trabajadores.append(Trabajador(calificacion))

    def despedir_trabajador(self, trabajador=None):
        if trabajador:
            self.trabajadores.remove(trabajador)
        else:
            if self.trabajadores:
                self.trabajadores.pop()

    def ajustar_empleo(self):
        trabajadores_necesarios = max(0, int(self.produccion / self.productividad))
        while len(self.trabajadores) < trabajadores_necesarios:
            self.contratar_trabajador(calificacion=self.calificacion_minima_requerida)
        while len(self.trabajadores) > trabajadores_necesarios:
            self.despedir_trabajador()

    def evaluar_calificacion(self):
        for trabajador in self.trabajadores[:]:
            if trabajador.calificacion < self.calificacion_minima_requerida:
                self.despedir_trabajador(trabajador)

    def simular_perturbaciones_externas(self):
        self.produccion *= random.uniform(0.3, 1.3)
        self.costos *= random.uniform(0.65, 1.5)
        self.ingresos *= random.uniform(0.5, 1.1)

    def competir_por_trabajadores_calificados(self, otras_empresas):
        for otra_empresa in otras_empresas:
            if otra_empresa is not self and len(otra_empresa.trabajadores) > 1:
                trabajador = random.choice(otra_empresa.trabajadores)
                if trabajador.calificacion >= self.calificacion_minima_requerida:
                    self.trabajadores.append(trabajador)
                    otra_empresa.trabajadores.remove(trabajador)

    def ajustar_especializacion(self):
        nuevos_productos = []
        for producto in self.productos:
            margen_producto = (producto["ingresos"] - producto["costos"]) / producto["ingresos"]
            if margen_producto >= self.margen_minimo or random.random() < 0.3:  # Probabilidad del 20% de mantener productos
                nuevos_productos.append(producto)
            else:
                self.produccion -= producto["produccion"]
                self.ajustar_empleo()
        self.productos = nuevos_productos

    def innovar_productos(self):
        if random.random() < 0.03:  # Probabilidad del 3% de innovar un nuevo producto
            nuevo_producto = {
                "nombre": f"Producto_Nuevo_{len(self.productos) + 1}",
                "ingresos": random.uniform(5, 15),
                "costos": random.uniform(3, 10),
                "produccion": random.uniform(5, 10)
            }
            self.productos.append(nuevo_producto)
            self.produccion += nuevo_producto["produccion"]

    def innovar_tecnologicamente(self):
        # Calcular diversidad y especialización para esta empresa
        productos_totales = set(producto["nombre"] for producto in self.productos)
        diversidad = len(productos_totales)
        especializacion = len(self.trabajadores) / len(self.productos) if self.productos else 0

        # Se innova cuando la diversidad es mayor que la especialización
        if diversidad > especializacion:
            if random.random() < 0.03:  # Probabilidad del 3% de innovar
                self.productividad += 0.05
                self.capacidad_tecnologica += 0.09
                self.calificacion_minima_requerida += 1

    def step(self):
        self.simular_perturbaciones_externas()
        self.ajustar_empleo()
        self.evaluar_calificacion()
        self.ajustar_especializacion()
        self.innovar_tecnologicamente()
        self.innovar_productos()


class ModeloProductivo:
    def __init__(self, N):
        self.num_empresas = N
        self.empresas = [Empresa(i) for i in range(N)]
        self.empleo_total_historia = []
        self.tasa_desempleo_historia = []
        self.calificacion_promedio_historia = []
        self.brecha_cualificacion_historia = []
        self.diversidad_productiva_historia = []
        self.especializacion_historia = []
        self.capacidades_tecnologicas_historia = []

    def calcular_empleo_total(self):
        return sum(len(empresa.trabajadores) for empresa in self.empresas)

    def calcular_tasa_desempleo(self):
        empleo_total = self.calcular_empleo_total()
        trabajadores_disponibles = 10000  # Ejemplo: pool de trabajadores disponibles
        return 1 - (empleo_total / trabajadores_disponibles)

    def calcular_calificacion_promedio(self):
        total_trabajadores = sum(len(empresa.trabajadores) for empresa in self.empresas)
        total_calificacion = sum(
            sum(trabajador.calificacion for trabajador in empresa.trabajadores)
            for empresa in self.empresas
        )
        return total_calificacion / total_trabajadores if total_trabajadores > 0 else 0

    def calcular_brecha_cualificacion(self):
        total_brecha = sum(
            max(0, empresa.calificacion_minima_requerida - self.calcular_calificacion_promedio())
            for empresa in self.empresas
        )
        return total_brecha / len(self.empresas)

    def calcular_diversidad_productiva(self):
        productos_totales = set(producto["nombre"] for empresa in self.empresas for producto in empresa.productos)
        return len(productos_totales)

    def calcular_especializacion(self):
        especializacion = sum(
            len(empresa.trabajadores) / len(empresa.productos) if empresa.productos else 0
            for empresa in self.empresas
        )
        return especializacion / len(self.empresas)

    def calcular_capacidades_tecnologicas_promedio(self):
        return sum(empresa.capacidad_tecnologica for empresa in self.empresas) / len(self.empresas)

    def step(self):
        random.shuffle(self.empresas)
        for empresa in self.empresas:
            empresa.step()
            empresa.competir_por_trabajadores_calificados(self.empresas)

        empleo_total = self.calcular_empleo_total()
        tasa_desempleo = self.calcular_tasa_desempleo()
        calificacion_promedio = self.calcular_calificacion_promedio()
        brecha_cualificacion = self.calcular_brecha_cualificacion()
        diversidad_productiva = self.calcular_diversidad_productiva()
        especializacion = self.calcular_especializacion()
        capacidades_tecnologicas = self.calcular_capacidades_tecnologicas_promedio()

        self.empleo_total_historia.append(empleo_total)
        self.tasa_desempleo_historia.append(tasa_desempleo)
        self.calificacion_promedio_historia.append(calificacion_promedio)
        self.brecha_cualificacion_historia.append(brecha_cualificacion)
        self.diversidad_productiva_historia.append(diversidad_productiva)
        self.especializacion_historia.append(especializacion)
        self.capacidades_tecnologicas_historia.append(capacidades_tecnologicas)

    def graficar_resultados(self):
        pasos = range(len(self.empleo_total_historia))
        plt.figure(figsize=(18, 12))

        # Empleo Total
        plt.subplot(3, 3, 1)
        plt.plot(pasos, self.empleo_total_historia, label="Empleo Total", color="blue")
        plt.title("Empleo Total a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Empleo Total")
        plt.legend()

        # Tasa de Desempleo
        plt.subplot(3, 3, 2)
        plt.plot(pasos, self.tasa_desempleo_historia, label="Tasa de Desempleo", color="red")
        plt.title("Tasa de Desempleo a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Tasa de Desempleo")
        plt.legend()

        # Calificación Promedio
        plt.subplot(3, 3, 3)
        plt.plot(pasos, self.calificacion_promedio_historia, label="Calificación Promedio", color="green")
        plt.title("Calificación Promedio a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Calificación Promedio")
        plt.legend()

        # Brecha de Cualificación
        plt.subplot(3, 3, 4)
        plt.plot(pasos, self.brecha_cualificacion_historia, label="Brecha de Cualificación", color="orange")
        plt.title("Brecha de Cualificación a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Brecha de Cualificación")
        plt.legend()

        # Diversidad Productiva
        plt.subplot(3, 3, 5)
        plt.plot(pasos, self.diversidad_productiva_historia, label="Diversidad Productiva", color="purple")
        plt.title("Diversidad Productiva a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Diversidad Productiva")
        plt.legend()

        # Especialización
        plt.subplot(3, 3, 6)
        plt.plot(pasos, self.especializacion_historia, label="Especialización", color="brown")
        plt.title("Especialización a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Especialización")
        plt.legend()

        # Capacidades Tecnológicas Promedio
        plt.subplot(3, 3, 7)
        plt.plot(pasos, self.capacidades_tecnologicas_historia, label="Capacidades Tecnológicas", color="teal")
        plt.title("Capacidades Tecnológicas Promedio a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Capacidades Tecnológicas Promedio")
        plt.legend()

        plt.tight_layout()
        plt.show()


# Ejecutar el modelo
model = ModeloProductivo(N=10)
for i in range(100):  # Simular 100 pasos
    model.step()

# Graficar resultados
model.graficar_resultados()

import random
import matplotlib.pyplot as plt

# Clase Trabajador con tipo
class Trabajador:
    def __init__(self, calificacion, tipo):
        self.calificacion = calificacion  # Nivel de habilidad
        self.tipo = tipo  # "produccion_ventas" o "administrativo"

# Clase Empresa con sector
class Empresa:
    def __init__(self, unique_id, sector):
        self.unique_id = unique_id
        self.sector = sector  # "agricultura", "manufactura", "servicios", "turismo"
        self.capacidad_tecnologica = 1
        self.ingresos = 1000
        self.costos = 750
        self.productividad = 5
        self.produccion = 50
        self.precio = 10
        self.trabajadores = {"produccion_ventas": [], "administrativo": []}  # Diccionario para tipos de trabajadores
        self.margen_minimo = 0.3
        self.calificacion_minima_requerida = 1
        self.productos = [{"nombre": f"Producto_{i}", "ingresos": 10, "costos": 5, "produccion": 5} for i in range(3)]

    def calcular_margen(self):
        return (self.ingresos - self.costos) / self.ingresos

    def contratar_trabajador(self, calificacion=1, tipo="produccion_ventas"):
        self.trabajadores[tipo].append(Trabajador(calificacion, tipo))

    def despedir_trabajador(self, tipo, trabajador=None):
        if trabajador:
            self.trabajadores[tipo].remove(trabajador)
        else:
            if self.trabajadores[tipo]:
                self.trabajadores[tipo].pop()

    def ajustar_empleo(self): # Calcula trabajadores necesarios basados en la producción
        trabajadores_necesarios = max(0, int(self.produccion / self.productividad))
        tipos = ["produccion_ventas", "administrativo"]

        for tipo in tipos:
            while len(self.trabajadores[tipo]) < trabajadores_necesarios // 2:  # Dividir entre tipos
                self.contratar_trabajador(calificacion=self.calificacion_minima_requerida, tipo=tipo)
            while len(self.trabajadores[tipo]) > trabajadores_necesarios // 2:
                self.despedir_trabajador(tipo)

    def evaluar_calificacion(self):
        tipos = ["produccion_ventas", "administrativo"]
        for tipo in tipos:
            for trabajador in self.trabajadores[tipo][:]:
                if trabajador.calificacion < self.calificacion_minima_requerida:
                    self.despedir_trabajador(tipo, trabajador)

    def simular_perturbaciones_externas(self):
        self.produccion *= random.uniform(0.7, 1.2)
        self.costos *= random.uniform(0.7, 1.08)
        self.ingresos *= random.uniform(0.7, 1.2)

    def competir_por_trabajadores_calificados(self, otras_empresas):
        tipos = ["produccion_ventas", "administrativo"]
        for otra_empresa in otras_empresas:
            if otra_empresa is not self and len(otra_empresa.trabajadores["produccion_ventas"]) > 3:
                for tipo in tipos:
                    if otra_empresa.trabajadores[tipo]:
                        trabajador = random.choice(otra_empresa.trabajadores[tipo])
                        if trabajador.calificacion >= self.calificacion_minima_requerida:
                            self.trabajadores[tipo].append(trabajador)
                            otra_empresa.trabajadores[tipo].remove(trabajador)

    def ajustar_especializacion(self):
        nuevos_productos = []
        for producto in self.productos:
            margen_producto = (producto["ingresos"] - producto["costos"]) / producto["ingresos"]
            if margen_producto >= self.margen_minimo or random.random() < 0.3:
                nuevos_productos.append(producto)
            else:
                self.produccion -= producto["produccion"]
                self.ajustar_empleo()
        self.productos = nuevos_productos

    def innovar_productos(self):
        if random.random() < 0.03:
            nuevo_producto = {
                "nombre": f"Producto_Nuevo_{len(self.productos) + 1}",
                "ingresos": random.uniform(5, 15),
                "costos": random.uniform(3, 10),
                "produccion": random.uniform(5, 10)
            }
            self.productos.append(nuevo_producto)
            self.produccion += nuevo_producto["produccion"]

    def innovar_tecnologicamente(self):
        productos_totales = set(producto["nombre"] for producto in self.productos)
        diversidad = len(productos_totales)
        especializacion = sum(len(self.trabajadores[tipo]) for tipo in self.trabajadores) / len(self.productos) if self.productos else 0
        margen_actual = self.calcular_margen()
        nueva_capacidad_tecnologica = self.capacidad_tecnologica + 0.05
        nueva_productividad = self.productividad + 0.05
        nueva_produccion = self.produccion * 1.05
        nuevo_costo = self.costos * 0.95  # Reducción esperada de costos
        nuevo_ingreso = self.ingresos * 1.02  # Aumento esperado de ingresos
        margen_potencial = (nuevo_ingreso - nuevo_costo) / nuevo_ingreso if nuevo_ingreso > 0 else 0

        if diversidad >= especializacion:
            if random.random() < 8:
                self.productividad += 0.05
                self.capacidad_tecnologica += 0.05
                self.calificacion_minima_requerida += 3
        if margen_potencial > margen_actual:
            self.capacidad_tecnologica = nueva_capacidad_tecnologica
            self.productividad = nueva_productividad
            self.produccion = nueva_produccion
            self.costos = nuevo_costo
            self.ingresos = nuevo_ingreso

    def ajustar_precios(self):
        margen_actual = self.calcular_margen()
        nuevo_precio = self.precio * 1.05  # Incremento del precio
        nuevo_ingreso = self.ingresos * 0.95  # Reducción esperada de ingresos debido al menor volumen
        nuevo_costo = self.costos

        margen_potencial = (nuevo_ingreso - nuevo_costo) / nuevo_ingreso if nuevo_ingreso > 0 else 0

        if margen_potencial > margen_actual:
            self.precio = nuevo_precio
            self.ingresos = nuevo_ingreso

    def colaborar_con_otras_empresas(self, otras_empresas):
        # Colaborar solo si ambas empresas mantienen márgenes mínimos
        for otra_empresa in otras_empresas:
            if otra_empresa is not self:
                margen_propio = self.calcular_margen()
                margen_otra = otra_empresa.calcular_margen()

                if margen_propio >= self.margen_minimo and margen_otra >= otra_empresa.margen_minimo:
                    # Proyecto conjunto que beneficia a ambas empresas
                    self.ingresos += 50
                    otra_empresa.ingresos += 50
                    self.capacidad_tecnologica += 0.02
                    otra_empresa.capacidad_tecnologica += 0.02


    def step(self):
        self.simular_perturbaciones_externas()
        self.ajustar_empleo()
        self.evaluar_calificacion()
        self.ajustar_especializacion()
        self.innovar_tecnologicamente()
        self.innovar_productos()
        self.ajustar_precios()
        self.colaborar_con_otras_empresas([])

# Modelo Productivo con Sectores
class ModeloProductivo:
    def __init__(self, N):
        self.num_empresas = N
        sectores = ["agricultura", "manufactura", "servicios", "turismo"]
        self.empresas = [Empresa(i, sector=sectores[i % len(sectores)]) for i in range(N)]
        self.empleo_total_historia = []
        self.tasa_desempleo_historia = []
        self.calificacion_promedio_historia = []
        self.brecha_cualificacion_historia = []
        self.diversidad_productiva_historia = []
        self.especializacion_historia = []
        self.capacidades_tecnologicas_historia = []
        self.margenes_promedio_historia = []
        self.tasa_innovacion_historia = []
        self.desigualdad_capacidades_historia = []

    def calcular_empleo_total(self):
        return sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)

    def calcular_tasa_desempleo(self):
        empleo_total = self.calcular_empleo_total()
        trabajadores_disponibles = 10000
        return 1 - (empleo_total / trabajadores_disponibles)

    def calcular_calificacion_promedio(self):
        total_trabajadores = sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)
        total_calificacion = sum(
            sum(trabajador.calificacion for trabajador in empresa.trabajadores[tipo])
            for empresa in self.empresas for tipo in empresa.trabajadores
        )
        return total_calificacion / total_trabajadores if total_trabajadores > 1 else 0

    def calcular_brecha_cualificacion(self):
        total_brecha = sum(
            max(0, empresa.calificacion_minima_requerida - self.calcular_calificacion_promedio())
            for empresa in self.empresas
        )
        return total_brecha / len(self.empresas)

    def calcular_diversidad_productiva(self):
        productos_totales = set(producto["nombre"] for empresa in self.empresas for producto in empresa.productos)
        return len(productos_totales)

    def calcular_especializacion(self):
        especializacion = sum(
            len(empresa.trabajadores[tipo]) / len(empresa.productos) if empresa.productos else 0
            for empresa in self.empresas for tipo in empresa.trabajadores
        )
        return especializacion / len(self.empresas)

    def calcular_capacidades_tecnologicas_promedio(self):
        return sum(empresa.capacidad_tecnologica for empresa in self.empresas) / len(self.empresas)

    def calcular_margenes_promedio(self):
        margenes = [empresa.calcular_margen() for empresa in self.empresas]
        return sum(margenes) / len(margenes) if margenes else 0

    def calcular_tasa_innovacion(self):
        innovadoras = sum(1 for empresa in self.empresas if empresa.capacidad_tecnologica > 0.01)
        return innovadoras / len(self.empresas)

    def calcular_desigualdad_capacidades(self):
        capacidades = [empresa.capacidad_tecnologica for empresa in self.empresas]
        promedio = sum(capacidades) / len(capacidades)
        varianza = sum((c - promedio) ** 2 for c in capacidades) / len(capacidades)
        return varianza

    def step(self):
        random.shuffle(self.empresas)
        for empresa in self.empresas:
            empresa.step()
            empresa.competir_por_trabajadores_calificados(self.empresas)

        empleo_total = self.calcular_empleo_total()
        tasa_desempleo = self.calcular_tasa_desempleo()
        calificacion_promedio = self.calcular_calificacion_promedio()
        brecha_cualificacion = self.calcular_brecha_cualificacion()
        diversidad_productiva = self.calcular_diversidad_productiva()
        especializacion = self.calcular_especializacion()
        capacidades_tecnologicas = self.calcular_capacidades_tecnologicas_promedio()
        margenes_promedio = self.calcular_margenes_promedio()
        tasa_innovacion = self.calcular_tasa_innovacion()
        desigualdad_capacidades = self.calcular_desigualdad_capacidades()


        self.empleo_total_historia.append(empleo_total)
        self.tasa_desempleo_historia.append(tasa_desempleo)
        self.calificacion_promedio_historia.append(calificacion_promedio)
        self.brecha_cualificacion_historia.append(brecha_cualificacion)
        self.diversidad_productiva_historia.append(diversidad_productiva)
        self.especializacion_historia.append(especializacion)
        self.capacidades_tecnologicas_historia.append(capacidades_tecnologicas)
        self.margenes_promedio_historia.append(margenes_promedio)
        self.tasa_innovacion_historia.append(tasa_innovacion)
        self.desigualdad_capacidades_historia.append(desigualdad_capacidades)



    def graficar_resultados(self):
        pasos = range(len(self.empleo_total_historia))

        # Empleo Total
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.empleo_total_historia, label="Empleo Total", color="blue")
        plt.title("Empleo Total a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Empleo Total")
        plt.legend()

        # Tasa de Desempleo
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.tasa_desempleo_historia, label="Tasa de Desempleo", color="red")
        plt.title("Tasa de Desempleo a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Tasa de Desempleo")
        plt.legend()

        # Calificación Promedio
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.calificacion_promedio_historia, label="Calificación Promedio", color="green")
        plt.title("Calificación Promedio a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Calificación Promedio")
        plt.legend()

        # Brecha de Cualificación
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.brecha_cualificacion_historia, label="Brecha de Cualificación", color="orange")
        plt.title("Brecha de Cualificación a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Brecha de Cualificación")
        plt.legend()

        # Diversidad Productiva
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.diversidad_productiva_historia, label="Diversidad Productiva", color="purple")
        plt.title("Diversidad Productiva a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Diversidad Productiva")
        plt.legend()

        # Especialización
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.especializacion_historia, label="Especialización", color="brown")
        plt.title("Especialización a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Especialización")
        plt.legend()

        # Capacidades Tecnológicas Promedio
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.capacidades_tecnologicas_historia, label="Capacidades Tecnológicas", color="teal")
        plt.title("Capacidades Tecnológicas Promedio a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Capacidades Tecnológicas Promedio")
        plt.legend()

        # Gráfica Margenes Promedio
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.margenes_promedio_historia, label="Márgenes Promedio", color="blue")
        plt.title("Márgenes Promedio a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Márgenes Promedio")
        plt.legend()
        plt.show()

        # Gráfica Tasa de Innovación
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.tasa_innovacion_historia, label="Tasa de Innovación", color="green")
        plt.title("Tasa de Innovación a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Tasa de Innovación")
        plt.legend()
        plt.show()

        # Gráfica Desigualdad en Capacidades Tecnológicas
        plt.figure(figsize=(8, 4))
        plt.plot(pasos, self.desigualdad_capacidades_historia, label="Desigualdad en Capacidades", color="red")
        plt.title("Desigualdad en Capacidades Tecnológicas a lo Largo del Tiempo")
        plt.xlabel("Pasos")
        plt.ylabel("Desigualdad en Capacidades")
        plt.legend()
        plt.show()

# Ejecutar el modelo
model = ModeloProductivo(N=10)
for i in range(100):  # Simular 100 pasos
    model.step()

# Graficar resultados
model.graficar_resultados()

import random
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

# Clase Trabajador con tipo
class Trabajador:
    def __init__(self, calificacion, tipo):
        self.calificacion = calificacion  # Nivel de habilidad (1-10)
        self.tipo = tipo  # "produccion_ventas" o "administrativo"
        self.experiencia = 1  # Años de experiencia
        self.productividad_personal = random.uniform(0.8, 1.2)  # Factor de productividad individual

    def aumentar_experiencia(self):
        self.experiencia *= 1.05
        # Aumento de calificación basado en experiencia con cierta probabilidad
        if random.random() < 0.1:
            self.calificacion = min(10, self.calificacion + 0.1)

# Clase Empresa con sector
class Empresa:
    def __init__(self, unique_id, sector):
        self.unique_id = unique_id
        self.sector = sector  # "agricultura", "manufactura", "servicios", "turismo"
        self.capacidad_tecnologica = 1  # Base inicial
        self.ingresos = 1000
        self.costos = 750
        self.productividad = 5
        self.produccion = 50
        self.precio = 10
        self.trabajadores = {"produccion_ventas": [], "administrativo": []}
        self.margen_minimo = 0.3
        self.calificacion_minima_requerida = 1
        self.productos = [{"nombre": f"Producto_{i}", "ingresos": 10, "costos": 5, "produccion": 5} for i in range(3)]
        self.inversion_iyd = 0.05  # Inversión en I+D como % de ingresos
        self.estado_financiero = "estable"  # estable, expansion, recesion
        self.antiguedad = 0
        self.historial_innovacion = []

        # Factores sectoriales iniciales
        self.factores_sectoriales = {
            "agricultura": {"innovacion": 0.8, "riesgo": 0.6, "productividad": 0.9},
            "manufactura": {"innovacion": 1.2, "riesgo": 0.8, "productividad": 1.1},
            "servicios": {"innovacion": 1.0, "riesgo": 0.7, "productividad": 1.0},
            "turismo": {"innovacion": 0.7, "riesgo": 0.9, "productividad": 0.8}
        }[sector]

    def calcular_margen(self):
        return (self.ingresos - self.costos) / self.ingresos if self.ingresos > 0 else 0

    def contratar_trabajador(self, calificacion=1, tipo="produccion_ventas"):
        # La calificación de nuevos trabajadores depende del nivel tecnológico
        calif_base = max(1, min(10, self.calificacion_minima_requerida * random.uniform(0.8, 1.2)))
        self.trabajadores[tipo].append(Trabajador(calif_base, tipo))

    def despedir_trabajador(self, tipo, trabajador=None):
        if trabajador:
            self.trabajadores[tipo].remove(trabajador)
        else:
            if self.trabajadores[tipo]:
                # Despedir al menos productivo primero
                menos_productivo = min(self.trabajadores[tipo], key=lambda t: t.productividad_personal)
                self.trabajadores[tipo].remove(menos_productivo)

    def ajustar_empleo(self):
        trabajadores_necesarios = max(1, int(self.produccion / self.productividad))
        tipos = ["produccion_ventas", "administrativo"]

        for tipo in tipos:
            # Ajuste más gradual con consideración del estado financiero
            ratio_ajuste = {
                "expansion": 1.1,
                "estable": 1.0,
                "recesion": 0.9
            }[self.estado_financiero]

            objetivo = max(1, int(trabajadores_necesarios * ratio_ajuste // 2))

            while len(self.trabajadores[tipo]) < objetivo:
                self.contratar_trabajador(calificacion=self.calificacion_minima_requerida, tipo=tipo)

            while len(self.trabajadores[tipo]) > objetivo * 1.2:  # Umbral más flexible
                self.despedir_trabajador(tipo)

    def evaluar_calificacion(self):
        tipos = ["produccion_ventas", "administrativo"]
        for tipo in tipos:
            for trabajador in self.trabajadores[tipo][:]:
                # Evaluación más flexible que considera experiencia
                umbral_despido = self.calificacion_minima_requerida * 0.8
                if trabajador.calificacion < umbral_despido and random.random() < 0.7:
                    self.despedir_trabajador(tipo, trabajador)
                else:
                    trabajador.aumentar_experiencia()

    def simular_perturbaciones_externas(self, ciclo_economico):
        # Efecto del ciclo económico (1.0 = neutral, >1.0 = expansión, <1.0 = recesión)
        factor_ciclo = random.uniform(0.9, 1.1) * ciclo_economico

        # Perturbaciones sectoriales específicas
        perturbacion_sectorial = random.uniform(
            0.9 * self.factores_sectoriales["riesgo"],
            1.1 * self.factores_sectoriales["riesgo"]
        )

        self.produccion *= random.uniform(0.7, 1.3) * factor_ciclo * perturbacion_sectorial
        self.costos *= random.uniform(0.8, 1.15) * (1/factor_ciclo if random.random() < 0.5 else 1)
        self.ingresos *= random.uniform(0.7, 1.25) * factor_ciclo

        # Actualizar estado financiero
        margen = self.calcular_margen()
        if margen > self.margen_minimo * 1.2:
            self.estado_financiero = "expansion"
        elif margen < self.margen_minimo * 0.8:
            self.estado_financiero = "recesion"
        else:
            self.estado_financiero = "estable"

    def competir_por_trabajadores_calificados(self, otras_empresas):
        if self.estado_financiero == "recesion":
            return  # No contratar en recesión

        tipos = ["produccion_ventas", "administrativo"]
        for otra_empresa in otras_empresas:
            if otra_empresa is not self and len(otra_empresa.trabajadores["produccion_ventas"]) > 2:
                for tipo in tipos:
                    if otra_empresa.trabajadores[tipo]:
                        # Probabilidad de atraer trabajadores basada en capacidad tecnológica y estado financiero
                        prob_atraer = 0.1 * (self.capacidad_tecnologica - otra_empresa.capacidad_tecnologica)
                        prob_atraer += 0.1 if self.estado_financiero == "expansion" else 0

                        if random.random() < max(0, prob_atraer):
                            trabajador = random.choice(otra_empresa.trabajadores[tipo])
                            if trabajador.calificacion >= self.calificacion_minima_requerida * 0.9:
                                self.trabajadores[tipo].append(trabajador)
                                otra_empresa.trabajadores[tipo].remove(trabajador)

    def ajustar_especializacion(self):
        nuevos_productos = []
        for producto in self.productos:
            margen_producto = (producto["ingresos"] - producto["costos"]) / producto["ingresos"] if producto["ingresos"] > 0 else 0

            # Decisión basada en margen, capacidad tecnológica y ciclo económico
            umbral_abandono = self.margen_minimo * {
                "expansion": 0.9,
                "estable": 1.0,
                "recesion": 1.1
            }[self.estado_financiero]

            if margen_producto >= umbral_abandono or random.random() < 0.2 * self.capacidad_tecnologica:
                nuevos_productos.append(producto)
            else:
                self.produccion -= producto["produccion"]
                self.ajustar_empleo()

        self.productos = nuevos_productos

    def innovar_productos(self):
        # Probabilidad de innovación depende de inversión en I+D, capacidad tecnológica y sector
        prob_innovacion = 0.03 * self.inversion_iyd * 20  # Normalizar a rango 0-1
        prob_innovacion *= self.factores_sectoriales["innovacion"]

        if random.random() < prob_innovacion:
            # Calidad del nuevo producto depende de capacidad tecnológica
            calidad = random.uniform(0.8, 1.2) * self.capacidad_tecnologica

            nuevo_producto = {
                "nombre": f"Producto_Nuevo_{len(self.productos) + 1}",
                "ingresos": random.uniform(5, 15) * calidad,
                "costos": random.uniform(3, 10) / calidad,  # Mejor tecnología reduce costos
                "produccion": random.uniform(5, 10),
                "tecnologia": self.capacidad_tecnologica  # Registra el nivel tecnológico al crearse
            }
            self.productos.append(nuevo_producto)
            self.produccion += nuevo_producto["produccion"]
            self.historial_innovacion.append(self.antiguedad)

    def innovar_tecnologicamente(self):
        # Factores que influyen en la innovación tecnológica
        diversidad = len(set(producto["nombre"] for producto in self.productos))
        trabajadores_calificados = sum(t.calificacion * t.experiencia for t in
                                     self.trabajadores["produccion_ventas"] + self.trabajadores["administrativo"])
        num_trabajadores = sum(len(self.trabajadores[t]) for t in self.trabajadores)
        calificacion_promedio = trabajadores_calificados / num_trabajadores if num_trabajadores > 0 else 0

        # Probabilidad base de innovación ajustada por múltiples factores
        prob_base = 0.03 * self.factores_sectoriales["innovacion"]
        prob_ajustada = prob_base * (1 + calificacion_promedio/10) * (1 + diversidad/5) * (1 + self.inversion_iyd*10)

        # Efecto de rendimientos decrecientes
        factor_rendimientos = max(0.3, 2 - self.capacidad_tecnologica/5)

        if random.random() < prob_ajustada * factor_rendimientos:
            # Innovación exitosa - efecto no lineal
            incremento = random.uniform(0.01, 0.15) * (1 + calificacion_promedio/5)
            incremento *= self.factores_sectoriales["innovacion"]
            self.capacidad_tecnologica += incremento

            # Efecto en productividad con variabilidad
            self.productividad += random.uniform(0.01, 0.2) * self.factores_sectoriales["productividad"]

            # Ajuste de calificación requerida basado en capacidad tecnológica
            self.calificacion_minima_requerida = max(1, self.capacidad_tecnologica * 1.5)

            # Posible efecto negativo (fracaso innovación)
            if random.random() < 0.1:  # 10% chance de fracaso
                self.capacidad_tecnologica *= 0.95
                self.productividad *= 0.98

        # Aprendizaje acumulativo - mejora gradual por experiencia
        self.capacidad_tecnologica += 0.001 * self.antiguedad * self.factores_sectoriales["innovacion"]

    def ajustar_precios(self):
        margen_actual = self.calcular_margen()

        # Estrategia de precios según estado financiero y capacidad tecnológica
        if self.estado_financiero == "expansion":
            factor_precio = random.uniform(1.0, 1.1)
        elif self.estado_financiero == "recesion":
            factor_precio = random.uniform(0.95, 1.0)
        else:
            factor_precio = random.uniform(0.98, 1.03)

        # Empresas más tecnológicas pueden cobrar precios premium
        factor_precio *= 1 + (self.capacidad_tecnologica - 1) * 0.05

        nuevo_precio = self.precio * factor_precio
        nuevo_ingreso = self.ingresos * (2 - factor_precio)  # Efecto elasticidad precio-demanda

        margen_potencial = (nuevo_ingreso - self.costos) / nuevo_ingreso if nuevo_ingreso > 0 else 0

        if margen_potencial > margen_actual or (self.estado_financiero == "recesion" and random.random() < 0.3):
            self.precio = nuevo_precio
            self.ingresos = nuevo_ingreso

    def colaborar_con_otras_empresas(self, otras_empresas):
        # Probabilidad de colaborar aumenta con capacidad tecnológica y en expansión
        prob_colaborar = 0.1 * self.capacidad_tecnologica
        prob_colaborar += 0.1 if self.estado_financiero == "expansion" else 0

        if random.random() < prob_colaborar:
            for otra_empresa in otras_empresas:
                if otra_empresa is not self and otra_empresa.sector == self.sector:
                    margen_propio = self.calcular_margen()
                    margen_otra = otra_empresa.calcular_margen()

                    if margen_propio >= self.margen_minimo and margen_otra >= otra_empresa.margen_minimo:
                        # Beneficios sinérgicos de la colaboración
                        sinergia = random.uniform(0.8, 1.2)
                        self.ingresos += 50 * sinergia
                        otra_empresa.ingresos += 50 * sinergia
                        self.capacidad_tecnologica += 0.03 * sinergia
                        otra_empresa.capacidad_tecnologica += 0.03 * sinergia

    def step(self, ciclo_economico):
        self.antiguedad += 1
        self.simular_perturbaciones_externas(ciclo_economico)
        self.ajustar_empleo()
        self.evaluar_calificacion()

        # Decisiones estratégicas que afectan innovación
        if random.random() < 0.2:  # 20% de chance de revaluar estrategia
            self.ajustar_especializacion()

        # Ajustar inversión en I+D según estado financiero
        self.inversion_iyd = {
            "expansion": random.uniform(0.06, 0.1),
            "estable": random.uniform(0.04, 0.07),
            "recesion": random.uniform(0.02, 0.05)
        }[self.estado_financiero] * self.factores_sectoriales["innovacion"]

        self.innovar_tecnologicamente()
        self.innovar_productos()
        self.ajustar_precios()
        self.colaborar_con_otras_empresas([])

# Modelo Productivo con Sectores y Ciclos Económicos
class ModeloProductivo:
    def __init__(self, N):
        self.num_empresas = N
        sectores = ["agricultura", "manufactura", "servicios", "turismo"]
        self.empresas = [Empresa(i, sector=sectores[i % len(sectores)]) for i in range(N)]

        # Historial de variables
        self.empleo_total_historia = []
        self.tasa_desempleo_historia = []
        self.calificacion_promedio_historia = []
        self.brecha_cualificacion_historia = []
        self.diversidad_productiva_historia = []
        self.especializacion_historia = []
        self.capacidades_tecnologicas_historia = []
        self.margenes_promedio_historia = []
        self.tasa_innovacion_historia = []
        self.desigualdad_capacidades_historia = []
        self.ciclo_economico_historia = []

        # Variables para ciclo económico
        self.ciclo_economico = 1.0
        self.fase_ciclo = "neutro"  # expansion, recesion, neutro
        self.duracion_fase = 0
        self.amplitud_ciclo = 0.2  # Intensidad de las fluctuaciones

    def generar_ciclo_economico(self):
        # Cambiar fase según duración actual
        if self.duracion_fase <= 0:
            if self.fase_ciclo == "expansion":
                self.fase_ciclo = random.choice(["recesion", "neutro"])
            elif self.fase_ciclo == "recesion":
                self.fase_ciclo = random.choice(["expansion", "neutro"])
            else:
                self.fase_ciclo = random.choice(["expansion", "recesion", "neutro"])
            self.duracion_fase = random.randint(5, 15)
        else:
            self.duracion_fase -= 1

        # Actualizar valor del ciclo según fase
        if self.fase_ciclo == "expansion":
            self.ciclo_economico = 1.0 + self.amplitud_ciclo * random.uniform(0.5, 1.0)
        elif self.fase_ciclo == "recesion":
            self.ciclo_economico = 1.0 - self.amplitud_ciclo * random.uniform(0.5, 1.0)
        else:
            self.ciclo_economico = 1.0 + self.amplitud_ciclo * random.uniform(-0.3, 0.3)

        # Ajustar amplitud ocasionalmente para mayor realismo
        if random.random() < 0.05:
            self.amplitud_ciclo = random.uniform(0.1, 0.3)

        self.ciclo_economico_historia.append(self.ciclo_economico)
        return self.ciclo_economico

    def calcular_empleo_total(self):
        return sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)

    def calcular_tasa_desempleo(self):
        empleo_total = self.calcular_empleo_total()
        trabajadores_disponibles = 10000  # Población laboral fija para simplificar
        return max(0, 1 - (empleo_total / trabajadores_disponibles))

    def calcular_calificacion_promedio(self):
        total_trabajadores = sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)
        if total_trabajadores == 0:
            return 0

        total_calificacion = sum(
            sum(trabajador.calificacion * trabajador.experiencia for trabajador in empresa.trabajadores[tipo])
            for empresa in self.empresas for tipo in empresa.trabajadores
        )
        return total_calificacion / total_trabajadores

    def calcular_brecha_cualificacion(self):
        calificacion_promedio = self.calcular_calificacion_promedio()
        if calificacion_promedio == 0:
            return 0

        total_brecha = sum(
            max(0, empresa.calificacion_minima_requerida - calificacion_promedio)
            for empresa in self.empresas
        )
        return total_brecha / len(self.empresas)

    def calcular_diversidad_productiva(self):
        productos_totales = set(producto["nombre"] for empresa in self.empresas for producto in empresa.productos)
        return len(productos_totales)

    def calcular_especializacion(self):
        especializacion_total = 0
        empresas_con_productos = 0

        for empresa in self.empresas:
            if empresa.productos:
                especializacion_empresa = sum(
                    len(empresa.trabajadores[tipo]) / len(empresa.productos)
                    for tipo in empresa.trabajadores
                )
                especializacion_total += especializacion_empresa
                empresas_con_productos += 1

        return especializacion_total / empresas_con_productos if empresas_con_productos > 0 else 0

    def calcular_capacidades_tecnologicas_promedio(self):
        return sum(empresa.capacidad_tecnologica for empresa in self.empresas) / len(self.empresas)

    def calcular_margenes_promedio(self):
        margenes = [empresa.calcular_margen() for empresa in self.empresas]
        return sum(margenes) / len(margenes) if margenes else 0

    def calcular_tasa_innovacion(self):
        innovadoras = 0
        for empresa in self.empresas:
            # Considerar no solo si innovan, sino cuánto innovan
            if empresa.capacidad_tecnologica > 1.5:  # Alta innovación
                innovadoras += 2
            elif empresa.capacidad_tecnologica > 1.2:  # Media innovación
                innovadoras += 1
            elif empresa.capacidad_tecnologica > 1.0 and random.random() < 0.5:  # Baja innovación
                innovadoras += 0.5

        # Normalizar considerando el máximo posible (2 por empresa)
        return innovadoras / (2 * len(self.empresas))

    def calcular_desigualdad_capacidades(self):
        capacidades = [empresa.capacidad_tecnologica for empresa in self.empresas]
        promedio = sum(capacidades) / len(capacidades)
        varianza = sum((c - promedio) ** 2 for c in capacidades) / len(capacidades)
        return varianza

    def step(self):
        # Actualizar ciclo económico
        ciclo_actual = self.generar_ciclo_economico()

        # Ejecutar paso para cada empresa
        random.shuffle(self.empresas)
        for empresa in self.empresas:
            empresa.step(ciclo_actual)
            empresa.competir_por_trabajadores_calificados(self.empresas)

        # Calcular y almacenar métricas
        self.empleo_total_historia.append(self.calcular_empleo_total())
        self.tasa_desempleo_historia.append(self.calcular_tasa_desempleo())
        self.calificacion_promedio_historia.append(self.calcular_calificacion_promedio())
        self.brecha_cualificacion_historia.append(self.calcular_brecha_cualificacion())
        self.diversidad_productiva_historia.append(self.calcular_diversidad_productiva())
        self.especializacion_historia.append(self.calcular_especializacion())
        self.capacidades_tecnologicas_historia.append(self.calcular_capacidades_tecnologicas_promedio())
        self.margenes_promedio_historia.append(self.calcular_margenes_promedio())
        self.tasa_innovacion_historia.append(self.calcular_tasa_innovacion())
        self.desigualdad_capacidades_historia.append(self.calcular_desigualdad_capacidades())

    def graficar_resultados(self):
        pasos = range(len(self.empleo_total_historia))

        # Configuración de estilo
        sns.set_style('darkgrid')
        plt.rcParams['figure.figsize'] = [10, 6]

        # Gráfica 1: Capacidades Tecnológicas y Tasa de Innovación
        fig, ax1 = plt.subplots()

        color = 'tab:blue'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Capacidades Tecnológicas', color=color)
        ax1.plot(pasos, self.capacidades_tecnologicas_historia, color=color, label='Cap. Tecnológicas')
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:red'
        ax2.set_ylabel('Tasa de Innovación', color=color)
        ax2.plot(pasos, self.tasa_innovacion_historia, color=color, linestyle='--', label='Tasa Innovación')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Evolución de Capacidades Tecnológicas y Tasa de Innovación')
        fig.tight_layout()
        plt.show()

        # Gráfica 2: Ciclo Económico y Empleo
        fig, ax1 = plt.subplots()

        color = 'tab:green'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Ciclo Económico', color=color)
        ax1.plot(pasos, self.ciclo_economico_historia, color=color, label='Ciclo Económico')
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:purple'
        ax2.set_ylabel('Empleo Total', color=color)
        ax2.plot(pasos, self.empleo_total_historia, color=color, linestyle='--', label='Empleo Total')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Ciclo Económico y su Impacto en el Empleo')
        fig.tight_layout()
        plt.show()

        # Gráfica 3: Diversidad Productiva y Especialización
        plt.figure()
        plt.plot(pasos, self.diversidad_productiva_historia, label='Diversidad Productiva')
        plt.plot(pasos, self.especializacion_historia, label='Especialización')
        plt.xlabel('Pasos')
        plt.ylabel('Valor')
        plt.title('Diversidad Productiva vs Especialización')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()

        # Gráfica 4: Margenes y Desigualdad
        fig, ax1 = plt.subplots()

        color = 'tab:blue'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Margenes Promedio', color=color)
        ax1.plot(pasos, self.margenes_promedio_historia, color=color, label='Margenes')
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:red'
        ax2.set_ylabel('Desigualdad Capacidades', color=color)
        ax2.plot(pasos, self.desigualdad_capacidades_historia, color=color, linestyle='--', label='Desigualdad')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Margenes de Beneficio y Desigualdad Tecnológica')
        fig.tight_layout()
        plt.show()

# Ejecutar el modelo mejorado
model = ModeloProductivo(N=20)  # Más empresas para mayor variabilidad
for i in range(150):  # Simular más pasos
    model.step()

# Graficar resultados
model.graficar_resultados()

import random
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

# Clase Trabajador con tipo
class Trabajador:
    def __init__(self, calificacion, tipo):
        self.calificacion = calificacion  # Nivel de habilidad (1-10)
        self.tipo = tipo  # "produccion_ventas" o "administrativo"
        self.experiencia = 1  # Años de experiencia
        self.productividad_personal = random.uniform(0.8, 1.2)  # Factor de productividad individual

    def aumentar_experiencia(self):
        self.experiencia *= 1.05
        # Aumento de calificación basado en experiencia con cierta probabilidad
        if random.random() < 0.1:
            self.calificacion = min(10, self.calificacion + 0.1)

# Clase Empresa con sector
class Empresa:
    def __init__(self, unique_id, sector):
        self.unique_id = unique_id
        self.sector = sector  # "agricultura", "manufactura", "servicios", "turismo"
        self.capacidad_tecnologica = 1  # Base inicial
        self.ingresos = 1000
        self.costos = 750
        self.productividad = 5
        self.produccion = 50
        self.precio = 10
        self.trabajadores = {"produccion_ventas": [], "administrativo": []}
        self.margen_minimo = 0.3
        self.calificacion_minima_requerida = 1
        self.productos = [{"nombre": f"Producto_{i}", "ingresos": 10, "costos": 5, "produccion": 5} for i in range(3)]
        self.inversion_iyd = 0.05  # Inversión en I+D como % de ingresos
        self.estado_financiero = "estable"  # estable, expansion, recesion
        self.antiguedad = 0
        self.historial_innovacion = []
        self.prioridad_margen = 0.7  # Nuevo parámetro: 0-1 donde 1 es máxima prioridad a márgenes

        # Factores sectoriales iniciales
        self.factores_sectoriales = {
            "agricultura": {"innovacion": 0.8, "riesgo": 0.6, "productividad": 0.9},
            "manufactura": {"innovacion": 1.2, "riesgo": 0.8, "productividad": 1.1},
            "servicios": {"innovacion": 1.0, "riesgo": 0.7, "productividad": 1.0},
            "turismo": {"innovacion": 0.7, "riesgo": 0.9, "productividad": 0.8}
        }[sector]

    def calcular_margen(self):
        return (self.ingresos - self.costos) / self.ingresos if self.ingresos > 0 else 0

    def contratar_trabajador(self, calificacion=1, tipo="produccion_ventas"):
        # La calificación de nuevos trabajadores depende del nivel tecnológico
        calif_base = max(1, min(10, self.calificacion_minima_requerida * random.uniform(0.8, 1.2)))
        self.trabajadores[tipo].append(Trabajador(calif_base, tipo))

    def despedir_trabajador(self, tipo, trabajador=None):
        if trabajador:
            self.trabajadores[tipo].remove(trabajador)
        else:
            if self.trabajadores[tipo]:
                # Despedir al menos productivo primero
                menos_productivo = min(self.trabajadores[tipo], key=lambda t: t.productividad_personal)
                self.trabajadores[tipo].remove(menos_productivo)

    def ajustar_empleo(self):
        trabajadores_necesarios = max(1, int(self.produccion / self.productividad))
        tipos = ["produccion_ventas", "administrativo"]

        for tipo in tipos:
            # Ajuste más gradual con consideración del estado financiero
            ratio_ajuste = {
                "expansion": 1.1,
                "estable": 1.0,
                "recesion": 0.9
            }[self.estado_financiero]

            objetivo = max(1, int(trabajadores_necesarios * ratio_ajuste // 2))

            while len(self.trabajadores[tipo]) < objetivo:
                self.contratar_trabajador(calificacion=self.calificacion_minima_requerida, tipo=tipo)

            while len(self.trabajadores[tipo]) > objetivo * 1.2:  # Umbral más flexible
                self.despedir_trabajador(tipo)

    def evaluar_calificacion(self):
        tipos = ["produccion_ventas", "administrativo"]
        for tipo in tipos:
            for trabajador in self.trabajadores[tipo][:]:
                # Evaluación más flexible que considera experiencia
                umbral_despido = self.calificacion_minima_requerida * 0.8
                if trabajador.calificacion < umbral_despido and random.random() < 0.7:
                    self.despedir_trabajador(tipo, trabajador)
                else:
                    trabajador.aumentar_experiencia()

    def simular_perturbaciones_externas(self, ciclo_economico):
        # Efecto del ciclo económico (1.0 = neutral, >1.0 = expansión, <1.0 = recesión)
        factor_ciclo = random.uniform(0.9, 1.1) * ciclo_economico

        # Perturbaciones sectoriales específicas
        perturbacion_sectorial = random.uniform(
            0.9 * self.factores_sectoriales["riesgo"],
            1.1 * self.factores_sectoriales["riesgo"]
        )

        self.produccion *= random.uniform(0.7, 1.3) * factor_ciclo * perturbacion_sectorial
        self.costos *= random.uniform(0.8, 1.15) * (1/factor_ciclo if random.random() < 0.5 else 1)
        self.ingresos *= random.uniform(0.7, 1.25) * factor_ciclo

        # Actualizar estado financiero
        margen = self.calcular_margen()
        if margen > self.margen_minimo * 1.2:
            self.estado_financiero = "expansion"
        elif margen < self.margen_minimo * 0.8:
            self.estado_financiero = "recesion"
        else:
            self.estado_financiero = "estable"

    def competir_por_trabajadores_calificados(self, otras_empresas):
        if self.estado_financiero == "recesion":
            return  # No contratar en recesión

        tipos = ["produccion_ventas", "administrativo"]
        for otra_empresa in otras_empresas:
            if otra_empresa is not self and len(otra_empresa.trabajadores["produccion_ventas"]) > 2:
                for tipo in tipos:
                    if otra_empresa.trabajadores[tipo]:
                        # Probabilidad de atraer trabajadores basada en capacidad tecnológica y estado financiero
                        prob_atraer = 0.1 * (self.capacidad_tecnologica - otra_empresa.capacidad_tecnologica)
                        prob_atraer += 0.1 if self.estado_financiero == "expansion" else 0

                        if random.random() < max(0, prob_atraer):
                            trabajador = random.choice(otra_empresa.trabajadores[tipo])
                            if trabajador.calificacion >= self.calificacion_minima_requerida * 0.9:
                                self.trabajadores[tipo].append(trabajador)
                                otra_empresa.trabajadores[tipo].remove(trabajador)

    def ajustar_especializacion(self):
        nuevos_productos = []
        for producto in self.productos:
            margen_producto = (producto["ingresos"] - producto["costos"]) / producto["ingresos"] if producto["ingresos"] > 0 else 0

            # Decisión basada en margen, capacidad tecnológica y ciclo económico
            umbral_abandono = self.margen_minimo * {
                "expansion": 0.9,
                "estable": 1.0,
                "recesion": 1.1
            }[self.estado_financiero]

            if margen_producto >= umbral_abandono or random.random() < 0.2 * self.capacidad_tecnologica:
                nuevos_productos.append(producto)
            else:
                self.produccion -= producto["produccion"]
                self.ajustar_empleo()

        self.productos = nuevos_productos

    def innovar_productos(self):
        # Probabilidad de innovación depende de inversión en I+D, capacidad tecnológica y sector
        prob_innovacion = 0.03 * self.inversion_iyd * 20  # Normalizar a rango 0-1
        prob_innovacion *= self.factores_sectoriales["innovacion"]

        # Ajustar probabilidad según prioridad de márgenes
        prob_innovacion *= (1 - self.prioridad_margen * 0.5)  # Reduce innovación si prioriza márgenes

        if random.random() < prob_innovacion:
            # Calidad del nuevo producto depende de capacidad tecnológica
            calidad = random.uniform(0.8, 1.2) * self.capacidad_tecnologica

            nuevo_producto = {
                "nombre": f"Producto_Nuevo_{len(self.productos) + 1}",
                "ingresos": random.uniform(5, 15) * calidad,
                "costos": random.uniform(3, 10) / calidad,  # Mejor tecnología reduce costos
                "produccion": random.uniform(5, 10),
                "tecnologia": self.capacidad_tecnologica  # Registra el nivel tecnológico al crearse
            }
            self.productos.append(nuevo_producto)
            self.produccion += nuevo_producto["produccion"]
            self.historial_innovacion.append(self.antiguedad)

    def innovar_tecnologicamente(self):
        margen_actual = self.calcular_margen()

        # Si el margen está por debajo del mínimo, reducir inversión en innovación
        if margen_actual < self.margen_minimo:
            factor_margen = 0.5  # Reduce fuertemente la innovación
        elif margen_actual < self.margen_minimo * 1.2:
            factor_margen = 0.8  # Reduce moderadamente
        else:
            factor_margen = 1.0  # No reduce

        # Aplicar prioridad de márgenes
        factor_margen *= (1 - self.prioridad_margen * 0.3)  # Reduce adicionalmente según prioridad

        # Factores que influyen en la innovación tecnológica
        diversidad = len(set(producto["nombre"] for producto in self.productos))
        trabajadores_calificados = sum(t.calificacion * t.experiencia for t in
                                     self.trabajadores["produccion_ventas"] + self.trabajadores["administrativo"])
        num_trabajadores = sum(len(self.trabajadores[t]) for t in self.trabajadores)
        calificacion_promedio = trabajadores_calificados / num_trabajadores if num_trabajadores > 0 else 0

        # Probabilidad base de innovación ajustada por múltiples factores
        prob_base = 0.03 * self.factores_sectoriales["innovacion"] * factor_margen
        prob_ajustada = prob_base * (1 + calificacion_promedio/10) * (1 + diversidad/5) * (1 + self.inversion_iyd*10)

        # Efecto de rendimientos decrecientes
        factor_rendimientos = max(0.3, 2 - self.capacidad_tecnologica/5)

        if random.random() < prob_ajustada * factor_rendimientos:
            # Innovación exitosa - efecto no lineal
            incremento = random.uniform(0.01, 0.15) * (1 + calificacion_promedio/5)
            incremento *= self.factores_sectoriales["innovacion"]

            # Reducir incremento si se prioriza márgenes
            incremento *= (1 - self.prioridad_margen * 0.2)

            self.capacidad_tecnologica += incremento

            # Efecto en productividad con variabilidad
            self.productividad += random.uniform(0.01, 0.2) * self.factores_sectoriales["productividad"]

            # Ajuste de calificación requerida basado en capacidad tecnológica
            self.calificacion_minima_requerida = max(1, self.capacidad_tecnologica * 1.5)

            # Posible efecto negativo (fracaso innovación)
            if random.random() < 0.1:  # 10% chance de fracaso
                self.capacidad_tecnologica *= 0.95
                self.productividad *= 0.98

        # Aprendizaje acumulativo - mejora gradual por experiencia
        self.capacidad_tecnologica += 0.001 * self.antiguedad * self.factores_sectoriales["innovacion"]

    def ajustar_precios(self):
        margen_actual = self.calcular_margen()

        # Estrategia de precios más agresiva para mantener márgenes
        if margen_actual < self.margen_minimo:
            # Aumentar precios más agresivamente si los márgenes están bajos
            factor_precio = random.uniform(1.05, 1.15)
        else:
            # Comportamiento normal
            if self.estado_financiero == "expansion":
                factor_precio = random.uniform(1.0, 1.1)
            elif self.estado_financiero == "recesion":
                factor_precio = random.uniform(0.95, 1.0)
            else:
                factor_precio = random.uniform(0.98, 1.03)

        # Ajustar según prioridad de márgenes
        if self.prioridad_margen > 0.5:
            factor_precio *= 1 + (self.prioridad_margen - 0.5) * 0.1

        nuevo_precio = self.precio * factor_precio
        nuevo_ingreso = self.ingresos * (2 - factor_precio)  # Efecto elasticidad precio-demanda

        margen_potencial = (nuevo_ingreso - self.costos) / nuevo_ingreso if nuevo_ingreso > 0 else 0

        if margen_potencial > margen_actual or (self.estado_financiero == "recesion" and random.random() < 0.3):
            self.precio = nuevo_precio
            self.ingresos = nuevo_ingreso

    def colaborar_con_otras_empresas(self, otras_empresas):
        # Probabilidad de colaborar aumenta con capacidad tecnológica y en expansión
        prob_colaborar = 0.1 * self.capacidad_tecnologica
        prob_colaborar += 0.1 if self.estado_financiero == "expansion" else 0

        # Reducir colaboración si se priorizan márgenes (menos riesgo)
        prob_colaborar *= (1 - self.prioridad_margen * 0.3)

        if random.random() < prob_colaborar:
            for otra_empresa in otras_empresas:
                if otra_empresa is not self and otra_empresa.sector == self.sector:
                    margen_propio = self.calcular_margen()
                    margen_otra = otra_empresa.calcular_margen()

                    if margen_propio >= self.margen_minimo and margen_otra >= otra_empresa.margen_minimo:
                        # Beneficios sinérgicos de la colaboración
                        sinergia = random.uniform(0.8, 1.2)
                        self.ingresos += 50 * sinergia
                        otra_empresa.ingresos += 50 * sinergia
                        self.capacidad_tecnologica += 0.03 * sinergia
                        otra_empresa.capacidad_tecnologica += 0.03 * sinergia

    def step(self, ciclo_economico):
        self.antiguedad += 1
        self.simular_perturbaciones_externas(ciclo_economico)
        self.ajustar_empleo()
        self.evaluar_calificacion()

        # Decisiones estratégicas que afectan innovación
        if random.random() < 0.2:  # 20% de chance de revaluar estrategia
            self.ajustar_especializacion()

        # Ajustar inversión en I+D según estado financiero y prioridad de márgenes
        base_inversion = {
            "expansion": random.uniform(0.06, 0.1),
            "estable": random.uniform(0.04, 0.07),
            "recesion": random.uniform(0.02, 0.05)
        }[self.estado_financiero]

        # Reducir inversión si se priorizan márgenes
        self.inversion_iyd = base_inversion * self.factores_sectoriales["innovacion"] * (1 - self.prioridad_margen * 0.4)

        self.innovar_tecnologicamente()
        self.innovar_productos()
        self.ajustar_precios()
        self.colaborar_con_otras_empresas([])

# Modelo Productivo con Sectores y Ciclos Económicos
class ModeloProductivo:
    def __init__(self, N):
        self.num_empresas = N
        sectores = ["agricultura", "manufactura", "servicios", "turismo"]
        self.empresas = [Empresa(i, sector=sectores[i % len(sectores)]) for i in range(N)]

        # Historial de variables
        self.empleo_total_historia = []
        self.tasa_desempleo_historia = []
        self.calificacion_promedio_historia = []
        self.brecha_cualificacion_historia = []
        self.diversidad_productiva_historia = []
        self.especializacion_historia = []
        self.capacidades_tecnologicas_historia = []
        self.margenes_promedio_historia = []
        self.tasa_innovacion_historia = []
        self.desigualdad_capacidades_historia = []
        self.ciclo_economico_historia = []
        self.productividad_promedio_historia = []  # Nueva métrica

        # Variables para ciclo económico
        self.ciclo_economico = 1.0
        self.fase_ciclo = "neutro"  # expansion, recesion, neutro
        self.duracion_fase = 0
        self.amplitud_ciclo = 0.2  # Intensidad de las fluctuaciones

    def generar_ciclo_economico(self):
        # Cambiar fase según duración actual
        if self.duracion_fase <= 0:
            if self.fase_ciclo == "expansion":
                self.fase_ciclo = random.choice(["recesion", "neutro"])
            elif self.fase_ciclo == "recesion":
                self.fase_ciclo = random.choice(["expansion", "neutro"])
            else:
                self.fase_ciclo = random.choice(["expansion", "recesion", "neutro"])
            self.duracion_fase = random.randint(5, 15)
        else:
            self.duracion_fase -= 1

        # Actualizar valor del ciclo según fase
        if self.fase_ciclo == "expansion":
            self.ciclo_economico = 1.0 + self.amplitud_ciclo * random.uniform(0.5, 1.0)
        elif self.fase_ciclo == "recesion":
            self.ciclo_economico = 1.0 - self.amplitud_ciclo * random.uniform(0.5, 1.0)
        else:
            self.ciclo_economico = 1.0 + self.amplitud_ciclo * random.uniform(-0.3, 0.3)

        # Ajustar amplitud ocasionalmente para mayor realismo
        if random.random() < 0.05:
            self.amplitud_ciclo = random.uniform(0.1, 0.3)

        self.ciclo_economico_historia.append(self.ciclo_economico)
        return self.ciclo_economico

    def calcular_empleo_total(self):
        return sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)

    def calcular_tasa_desempleo(self):
        empleo_total = self.calcular_empleo_total()
        trabajadores_disponibles = 10000  # Población laboral fija para simplificar
        return max(0, 1 - (empleo_total / trabajadores_disponibles))

    def calcular_calificacion_promedio(self):
        total_trabajadores = sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)
        if total_trabajadores == 0:
            return 0

        total_calificacion = sum(
            sum(trabajador.calificacion * trabajador.experiencia for trabajador in empresa.trabajadores[tipo])
            for empresa in self.empresas for tipo in empresa.trabajadores
        )
        return total_calificacion / total_trabajadores

    def calcular_brecha_cualificacion(self):
        calificacion_promedio = self.calcular_calificacion_promedio()
        if calificacion_promedio == 0:
            return 0

        total_brecha = sum(
            max(0, empresa.calificacion_minima_requerida - calificacion_promedio)
            for empresa in self.empresas
        )
        return total_brecha / len(self.empresas)

    def calcular_diversidad_productiva(self):
        productos_totales = set(producto["nombre"] for empresa in self.empresas for producto in empresa.productos)
        return len(productos_totales)

    def calcular_especializacion(self):
        especializacion_total = 0
        empresas_con_productos = 0

        for empresa in self.empresas:
            if empresa.productos:
                especializacion_empresa = sum(
                    len(empresa.trabajadores[tipo]) / len(empresa.productos)
                    for tipo in empresa.trabajadores
                )
                especializacion_total += especializacion_empresa
                empresas_con_productos += 1

        return especializacion_total / empresas_con_productos if empresas_con_productos > 0 else 0

    def calcular_capacidades_tecnologicas_promedio(self):
        return sum(empresa.capacidad_tecnologica for empresa in self.empresas) / len(self.empresas)

    def calcular_margenes_promedio(self):
        margenes = [empresa.calcular_margen() for empresa in self.empresas]
        return sum(margenes) / len(margenes) if margenes else 0

    def calcular_tasa_innovacion(self):
        innovadoras = 0
        for empresa in self.empresas:
            # Considerar no solo si innovan, sino cuánto innovan
            if empresa.capacidad_tecnologica > 1.5:  # Alta innovación
                innovadoras += 2
            elif empresa.capacidad_tecnologica > 1.2:  # Media innovación
                innovadoras += 1
            elif empresa.capacidad_tecnologica > 1.0 and random.random() < 0.5:  # Baja innovación
                innovadoras += 0.5

        # Normalizar considerando el máximo posible (2 por empresa)
        return innovadoras / (2 * len(self.empresas))

    def calcular_desigualdad_capacidades(self):
        capacidades = [empresa.capacidad_tecnologica for empresa in self.empresas]
        promedio = sum(capacidades) / len(capacidades)
        varianza = sum((c - promedio) ** 2 for c in capacidades) / len(capacidades)
        return varianza

    def calcular_productividad_promedio(self):
        productividades = [empresa.productividad for empresa in self.empresas]
        return sum(productividades) / len(productividades) if productividades else 0

    def step(self):
        # Actualizar ciclo económico
        ciclo_actual = self.generar_ciclo_economico()

        # Ejecutar paso para cada empresa
        random.shuffle(self.empresas)
        for empresa in self.empresas:
            empresa.step(ciclo_actual)
            empresa.competir_por_trabajadores_calificados(self.empresas)

        # Calcular y almacenar métricas
        self.empleo_total_historia.append(self.calcular_empleo_total())
        self.tasa_desempleo_historia.append(self.calcular_tasa_desempleo())
        self.calificacion_promedio_historia.append(self.calcular_calificacion_promedio())
        self.brecha_cualificacion_historia.append(self.calcular_brecha_cualificacion())
        self.diversidad_productiva_historia.append(self.calcular_diversidad_productiva())
        self.especializacion_historia.append(self.calcular_especializacion())
        self.capacidades_tecnologicas_historia.append(self.calcular_capacidades_tecnologicas_promedio())
        self.margenes_promedio_historia.append(self.calcular_margenes_promedio())
        self.tasa_innovacion_historia.append(self.calcular_tasa_innovacion())
        self.desigualdad_capacidades_historia.append(self.calcular_desigualdad_capacidades())
        self.productividad_promedio_historia.append(self.calcular_productividad_promedio())

    def graficar_resultados(self):
        pasos = range(len(self.empleo_total_historia))

        # Configuración de estilo
        sns.set_style('darkgrid')
        plt.rcParams['figure.figsize'] = [10, 6]

        # Gráfica 1: Márgenes vs Productividad
        fig, ax1 = plt.subplots()

        color = 'tab:blue'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Margenes Promedio', color=color)
        ax1.plot(pasos, self.margenes_promedio_historia, color=color, label='Margenes')
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:red'
        ax2.set_ylabel('Productividad Promedio', color=color)
        ax2.plot(pasos, self.productividad_promedio_historia, color=color, linestyle='--', label='Productividad')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Evolución de Márgenes vs Productividad')
        fig.tight_layout()
        plt.show()

        # Gráfica 2: Capacidades Tecnológicas y Tasa de Innovación
        fig, ax1 = plt.subplots()

        color = 'tab:blue'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Capacidades Tecnológicas', color=color)
        ax1.plot(pasos, self.capacidades_tecnologicas_historia, color=color, label='Cap. Tecnológicas')
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:red'
        ax2.set_ylabel('Tasa de Innovación', color=color)
        ax2.plot(pasos, self.tasa_innovacion_historia, color=color, linestyle='--', label='Tasa Innovación')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Evolución de Capacidades Tecnológicas y Tasa de Innovación')
        fig.tight_layout()
        plt.show()

        # Gráfica 3: Ciclo Económico y Empleo
        fig, ax1 = plt.subplots()

        color = 'tab:green'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Ciclo Económico', color=color)
        ax1.plot(pasos, self.ciclo_economico_historia, color=color, label='Ciclo Económico')
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:purple'
        ax2.set_ylabel('Empleo Total', color=color)
        ax2.plot(pasos, self.empleo_total_historia, color=color, linestyle='--', label='Empleo Total')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Ciclo Económico y su Impacto en el Empleo')
        fig.tight_layout()
        plt.show()

        # Gráfica 4: Diversidad Productiva y Especialización
        plt.figure()
        plt.plot(pasos, self.diversidad_productiva_historia, label='Diversidad Productiva')
        plt.plot(pasos, self.especializacion_historia, label='Especialización')
        plt.xlabel('Pasos')
        plt.ylabel('Valor')
        plt.title('Diversidad Productiva vs Especialización')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()

# Ejecutar el modelo mejorado
model = ModeloProductivo(N=20)  # Más empresas para mayor variabilidad
for i in range(150):  # Simular más pasos
    model.step()

# Graficar resultados
model.graficar_resultados()

import random
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

# Clase Trabajador
class Trabajador:
    def __init__(self, calificacion, tipo):
        self.calificacion = calificacion
        self.tipo = tipo
        self.experiencia = 1
        self.productividad_personal = random.uniform(0.8, 1.2)

    def aumentar_experiencia(self):
        self.experiencia *= 1.05
        if random.random() < 0.1:
            self.calificacion = min(10, self.calificacion + 0.1)

# Clase Empresa
class Empresa:
    def __init__(self, unique_id, sector):
        self.unique_id = unique_id
        self.sector = sector
        self.diversidad = 1.0
        self.especializacion = 1.0
        self.capacidad_tecnologica = self.calcular_capacidad_tecnologica()

        self.ingresos = 1000
        self.costos = 750
        self.productividad = 5
        self.produccion = 50
        self.precio = 10
        self.trabajadores = {"produccion_ventas": [], "administrativo": []}
        self.margen_minimo = 0.3
        self.calificacion_minima_requerida = 1
        self.productos = [{"nombre": f"Producto_{i}", "ingresos": 10, "costos": 5, "produccion": 5} for i in range(3)]
        self.inversion_iyd = 0.05
        self.estado_financiero = "estable"
        self.antiguedad = 0
        self.historial_innovacion = []
        self.prioridad_margen = 0.7

        self.factores_sectoriales = {
            "agricultura": {"innovacion": 0.8, "riesgo": 0.6, "productividad": 0.9},
            "manufactura": {"innovacion": 1.2, "riesgo": 0.8, "productividad": 1.1},
            "servicios": {"innovacion": 1.0, "riesgo": 0.7, "productividad": 1.0},
            "turismo": {"innovacion": 0.7, "riesgo": 0.9, "productividad": 0.8}
        }[sector]

    def calcular_margen(self):
        return (self.ingresos - self.costos) / self.ingresos if self.ingresos > 0 else 0

    def calcular_capacidad_tecnologica(self):
        base = min(self.diversidad, self.especializacion)
        diferencia = max(0, self.diversidad - self.especializacion) * 0.5
        return base + diferencia

    def actualizar_capacidades(self):
        self.diversidad = 1 + len(set(p["nombre"] for p in self.productos)) * 0.2

        if self.productos:
            trabajadores_totales = sum(len(self.trabajadores[t]) for t in self.trabajadores)
            self.especializacion = 1 + (trabajadores_totales / len(self.productos)) * 0.1

        self.capacidad_tecnologica = self.calcular_capacidad_tecnologica()
        self.calificacion_minima_requerida = max(1, self.capacidad_tecnologica * 1.5)

    def contratar_trabajador(self, calificacion=1, tipo="produccion_ventas"):
        calif_base = max(1, min(10, self.calificacion_minima_requerida * random.uniform(0.8, 1.2)))
        self.trabajadores[tipo].append(Trabajador(calif_base, tipo))
        self.actualizar_capacidades()

    def despedir_trabajador(self, tipo, trabajador=None):
        if trabajador:
            self.trabajadores[tipo].remove(trabajador)
        else:
            if self.trabajadores[tipo]:
                menos_productivo = min(self.trabajadores[tipo], key=lambda t: t.productividad_personal)
                self.trabajadores[tipo].remove(menos_productivo)
        self.actualizar_capacidades()

    def ajustar_empleo(self):
        trabajadores_necesarios = max(1, int(self.produccion / self.productividad))
        tipos = ["produccion_ventas", "administrativo"]

        for tipo in tipos:
            ratio_ajuste = {
                "expansion": 1.1,
                "estable": 1.0,
                "recesion": 0.9
            }[self.estado_financiero]

            objetivo = max(1, int(trabajadores_necesarios * ratio_ajuste // 2))

            while len(self.trabajadores[tipo]) < objetivo:
                self.contratar_trabajador(calificacion=self.calificacion_minima_requerida, tipo=tipo)

            while len(self.trabajadores[tipo]) > objetivo * 1.2:
                self.despedir_trabajador(tipo)

    def evaluar_calificacion(self):
        tipos = ["produccion_ventas", "administrativo"]
        for tipo in tipos:
            for trabajador in self.trabajadores[tipo][:]:
                umbral_despido = self.calificacion_minima_requerida * 0.8
                if trabajador.calificacion < umbral_despido and random.random() < 0.7:
                    self.despedir_trabajador(tipo, trabajador)
                else:
                    trabajador.aumentar_experiencia()

    def simular_perturbaciones_externas(self, ciclo_economico):
        factor_ciclo = random.uniform(0.9, 1.1) * ciclo_economico

        perturbacion_sectorial = random.uniform(
            0.9 * self.factores_sectoriales["riesgo"],
            1.1 * self.factores_sectoriales["riesgo"]
        )

        self.produccion *= random.uniform(0.7, 1.3) * factor_ciclo * perturbacion_sectorial
        self.costos *= random.uniform(0.8, 1.15) * (1/factor_ciclo if random.random() < 0.5 else 1)
        self.ingresos *= random.uniform(0.7, 1.25) * factor_ciclo

        margen = self.calcular_margen()
        if margen > self.margen_minimo * 1.2:
            self.estado_financiero = "expansion"
        elif margen < self.margen_minimo * 0.8:
            self.estado_financiero = "recesion"
        else:
            self.estado_financiero = "estable"

    def competir_por_trabajadores_calificados(self, otras_empresas):
        if self.estado_financiero == "recesion":
            return

        tipos = ["produccion_ventas", "administrativo"]
        for otra_empresa in otras_empresas:
            if otra_empresa is not self and len(otra_empresa.trabajadores["produccion_ventas"]) > 2:
                for tipo in tipos:
                    if otra_empresa.trabajadores[tipo]:
                        prob_atraer = 0.1 * (self.capacidad_tecnologica - otra_empresa.capacidad_tecnologica)
                        prob_atraer += 0.1 if self.estado_financiero == "expansion" else 0

                        if random.random() < max(0, prob_atraer):
                            trabajador = random.choice(otra_empresa.trabajadores[tipo])
                            if trabajador.calificacion >= self.calificacion_minima_requerida * 0.9:
                                self.trabajadores[tipo].append(trabajador)
                                otra_empresa.trabajadores[tipo].remove(trabajador)
                                self.actualizar_capacidades()
                                otra_empresa.actualizar_capacidades()

    def ajustar_especializacion(self):
        nuevos_productos = []
        for producto in self.productos:
            margen_producto = (producto["ingresos"] - producto["costos"]) / producto["ingresos"] if producto["ingresos"] > 0 else 0

            umbral_abandono = self.margen_minimo * {
                "expansion": 0.9,
                "estable": 1.0,
                "recesion": 1.1
            }[self.estado_financiero]

            if margen_producto >= umbral_abandono or random.random() < 0.2 * self.capacidad_tecnologica:
                nuevos_productos.append(producto)
            else:
                self.produccion -= producto["produccion"]
                self.ajustar_empleo()

        self.productos = nuevos_productos
        self.actualizar_capacidades()

    def innovar_tecnologicamente(self):
        margen_actual = self.calcular_margen()

        if self.diversidad <= self.especializacion:
            return

        prob_base = 0.03 * self.factores_sectoriales["innovacion"]
        prob_ajustada = prob_base * (1 + (self.diversidad - self.especializacion))

        if margen_actual < self.margen_minimo:
            prob_ajustada *= 0.5

        if random.random() < prob_ajustada:
            incremento_diversidad = random.uniform(0.01, 0.05)
            incremento_especializacion = random.uniform(0.01, 0.03)

            self.diversidad += incremento_diversidad
            self.especializacion += incremento_especializacion

            self.productividad += random.uniform(0.01, 0.1) * self.especializacion

            self.actualizar_capacidades()

            if random.random() < 0.1:
                self.diversidad *= 0.95
                self.especializacion *= 0.97
                self.actualizar_capacidades()

    def innovar_productos(self):
        if self.diversidad <= self.especializacion:
            return

        prob_innovacion = 0.03 * self.inversion_iyd * 20
        prob_innovacion *= self.factores_sectoriales["innovacion"]
        prob_innovacion *= (self.diversidad - self.especializacion + 1)

        if random.random() < prob_innovacion:
            nuevo_producto = {
                "nombre": f"Producto_Nuevo_{len(self.productos) + 1}",
                "ingresos": random.uniform(5, 15) * self.capacidad_tecnologica,
                "costos": random.uniform(3, 10) / self.capacidad_tecnologica,
                "produccion": random.uniform(5, 10),
                "tecnologia": self.capacidad_tecnologica
            }
            self.productos.append(nuevo_producto)
            self.produccion += nuevo_producto["produccion"]
            self.historial_innovacion.append(self.antiguedad)
            self.actualizar_capacidades()

    def ajustar_precios(self):
        margen_actual = self.calcular_margen()

        if margen_actual < self.margen_minimo:
            factor_precio = random.uniform(1.05, 1.15)
        else:
            if self.estado_financiero == "expansion":
                factor_precio = random.uniform(1.0, 1.1)
            elif self.estado_financiero == "recesion":
                factor_precio = random.uniform(0.95, 1.0)
            else:
                factor_precio = random.uniform(0.98, 1.03)

        if self.prioridad_margen > 0.5:
            factor_precio *= 1 + (self.prioridad_margen - 0.5) * 0.1

        nuevo_precio = self.precio * factor_precio
        nuevo_ingreso = self.ingresos * (2 - factor_precio)

        margen_potencial = (nuevo_ingreso - self.costos) / nuevo_ingreso if nuevo_ingreso > 0 else 0

        if margen_potencial > margen_actual or (self.estado_financiero == "recesion" and random.random() < 0.3):
            self.precio = nuevo_precio
            self.ingresos = nuevo_ingreso

    def colaborar_con_otras_empresas(self, otras_empresas):
        prob_colaborar = 0.1 * self.capacidad_tecnologica
        prob_colaborar += 0.1 if self.estado_financiero == "expansion" else 0
        prob_colaborar *= (1 - self.prioridad_margen * 0.3)

        if random.random() < prob_colaborar:
            for otra_empresa in otras_empresas:
                if otra_empresa is not self and otra_empresa.sector == self.sector:
                    margen_propio = self.calcular_margen()
                    margen_otra = otra_empresa.calcular_margen()

                    if margen_propio >= self.margen_minimo and margen_otra >= otra_empresa.margen_minimo:
                        sinergia = random.uniform(0.8, 1.2)
                        self.ingresos += 50 * sinergia
                        otra_empresa.ingresos += 50 * sinergia
                        self.diversidad += 0.02 * sinergia
                        otra_empresa.diversidad += 0.02 * sinergia
                        self.actualizar_capacidades()
                        otra_empresa.actualizar_capacidades()

    def step(self, ciclo_economico):
        self.antiguedad += 1
        self.simular_perturbaciones_externas(ciclo_economico)
        self.ajustar_empleo()
        self.evaluar_calificacion()

        if random.random() < 0.2:
            self.ajustar_especializacion()

        self.actualizar_capacidades()

        self.inversion_iyd = {
            "expansion": random.uniform(0.06, 0.1),
            "estable": random.uniform(0.04, 0.07),
            "recesion": random.uniform(0.02, 0.05)
        }[self.estado_financiero] * self.factores_sectoriales["innovacion"]

        self.innovar_tecnologicamente()
        self.innovar_productos()
        self.ajustar_precios()
        self.colaborar_con_otras_empresas([])

# Modelo Productivo completo
class ModeloProductivo:
    def __init__(self, N):
        self.num_empresas = N
        sectores = ["agricultura", "manufactura", "servicios", "turismo"]
        self.empresas = [Empresa(i, sector=sectores[i % len(sectores)]) for i in range(N)]

        self.empleo_total_historia = []
        self.diversidad_promedio_historia = []
        self.especializacion_promedio_historia = []
        self.ratio_diversidad_especializacion_historia = []
        self.capacidades_tecnologicas_historia = []
        self.margenes_promedio_historia = []
        self.tasa_innovacion_historia = []
        self.productividad_promedio_historia = []
        self.ciclo_economico_historia = []

        self.ciclo_economico = 1.0
        self.fase_ciclo = "neutro"
        self.duracion_fase = 0
        self.amplitud_ciclo = 0.2

    def generar_ciclo_economico(self):
        if self.duracion_fase <= 0:
            if self.fase_ciclo == "expansion":
                self.fase_ciclo = random.choice(["recesion", "neutro"])
            elif self.fase_ciclo == "recesion":
                self.fase_ciclo = random.choice(["expansion", "neutro"])
            else:
                self.fase_ciclo = random.choice(["expansion", "recesion", "neutro"])
            self.duracion_fase = random.randint(5, 15)
        else:
            self.duracion_fase -= 1

        if self.fase_ciclo == "expansion":
            self.ciclo_economico = 1.0 + self.amplitud_ciclo * random.uniform(0.5, 1.0)
        elif self.fase_ciclo == "recesion":
            self.ciclo_economico = 1.0 - self.amplitud_ciclo * random.uniform(0.5, 1.0)
        else:
            self.ciclo_economico = 1.0 + self.amplitud_ciclo * random.uniform(-0.3, 0.3)

        if random.random() < 0.05:
            self.amplitud_ciclo = random.uniform(0.1, 0.3)

        self.ciclo_economico_historia.append(self.ciclo_economico)
        return self.ciclo_economico

    def calcular_empleo_total(self):
        return sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)

    def calcular_tasa_desempleo(self):
        empleo_total = self.calcular_empleo_total()
        trabajadores_disponibles = 10000
        return max(0, 1 - (empleo_total / trabajadores_disponibles))

    def calcular_calificacion_promedio(self):
        total_trabajadores = sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)
        if total_trabajadores == 0:
            return 0

        total_calificacion = sum(
            sum(trabajador.calificacion * trabajador.experiencia for trabajador in empresa.trabajadores[tipo])
            for empresa in self.empresas for tipo in empresa.trabajadores
        )
        return total_calificacion / total_trabajadores

    def calcular_brecha_cualificacion(self):
        calificacion_promedio = self.calcular_calificacion_promedio()
        if calificacion_promedio == 0:
            return 0

        total_brecha = sum(
            max(0, empresa.calificacion_minima_requerida - calificacion_promedio)
            for empresa in self.empresas
        )
        return total_brecha / len(self.empresas)

    def calcular_diversidad_promedio(self):
        diversidades = [empresa.diversidad for empresa in self.empresas]
        return sum(diversidades) / len(diversidades) if diversidades else 0

    def calcular_especializacion_promedio(self):
        especializaciones = [empresa.especializacion for empresa in self.empresas]
        return sum(especializaciones) / len(especializaciones) if especializaciones else 0

    def calcular_ratio_diversidad_especializacion(self):
        ratios = []
        for empresa in self.empresas:
            if empresa.especializacion > 0:
                ratios.append(empresa.diversidad / empresa.especializacion)
        return sum(ratios) / len(ratios) if ratios else 0

    def calcular_capacidades_tecnologicas_promedio(self):
        return sum(empresa.capacidad_tecnologica for empresa in self.empresas) / len(self.empresas)

    def calcular_margenes_promedio(self):
        margenes = [empresa.calcular_margen() for empresa in self.empresas]
        return sum(margenes) / len(margenes) if margenes else 0

    def calcular_tasa_innovacion(self):
        innovadoras = 0
        for empresa in self.empresas:
            if empresa.capacidad_tecnologica > 1.5:
                innovadoras += 2
            elif empresa.capacidad_tecnologica > 1.2:
                innovadoras += 1
            elif empresa.capacidad_tecnologica > 1.0 and random.random() < 0.5:
                innovadoras += 0.5

        return innovadoras / (2 * len(self.empresas))

    def calcular_desigualdad_capacidades(self):
        capacidades = [empresa.capacidad_tecnologica for empresa in self.empresas]
        promedio = sum(capacidades) / len(capacidades)
        varianza = sum((c - promedio) ** 2 for c in capacidades) / len(capacidades)
        return varianza

    def calcular_productividad_promedio(self):
        productividades = [empresa.productividad for empresa in self.empresas]
        return sum(productividades) / len(productividades) if productividades else 0

    def step(self):
        ciclo_actual = self.generar_ciclo_economico()

        random.shuffle(self.empresas)
        for empresa in self.empresas:
            empresa.step(ciclo_actual)
            empresa.competir_por_trabajadores_calificados(self.empresas)

        self.empleo_total_historia.append(self.calcular_empleo_total())
        self.diversidad_promedio_historia.append(self.calcular_diversidad_promedio())
        self.especializacion_promedio_historia.append(self.calcular_especializacion_promedio())
        self.ratio_diversidad_especializacion_historia.append(self.calcular_ratio_diversidad_especializacion())
        self.capacidades_tecnologicas_historia.append(self.calcular_capacidades_tecnologicas_promedio())
        self.margenes_promedio_historia.append(self.calcular_margenes_promedio())
        self.tasa_innovacion_historia.append(self.calcular_tasa_innovacion())
        self.productividad_promedio_historia.append(self.calcular_productividad_promedio())

    def graficar_resultados(self):
        pasos = range(len(self.empleo_total_historia))

        sns.set_style('darkgrid')
        plt.rcParams['figure.figsize'] = [10, 6]

        # Gráfica 1: Diversidad vs Especialización
        plt.figure()
        plt.plot(pasos, self.diversidad_promedio_historia, label='Diversidad (ideas)')
        plt.plot(pasos, self.especializacion_promedio_historia, label='Especialización (implementación)')
        plt.axhline(y=1, color='r', linestyle='--', label='Umbral de innovación')
        plt.xlabel('Pasos')
        plt.ylabel('Nivel')
        plt.title('Evolución de Diversidad y Especialización')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()

        # Gráfica 2: Ratio D/E vs Innovación
        fig, ax1 = plt.subplots()

        color = 'tab:blue'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Ratio Diversidad/Especialización', color=color)
        ax1.plot(pasos, self.ratio_diversidad_especializacion_historia, color=color)
        ax1.axhline(y=1, color=color, linestyle='--', label='Umbral innovación')
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:red'
        ax2.set_ylabel('Tasa de Innovación', color=color)
        ax2.plot(pasos, self.tasa_innovacion_historia, color=color, linestyle='--')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Relación entre Ratio D/E y Tasa de Innovación')
        fig.tight_layout()
        plt.show()

        # Gráfica 3: Capacidades tecnológicas y productividad
        fig, ax1 = plt.subplots()

        color = 'tab:green'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Capacidad Tecnológica', color=color)
        ax1.plot(pasos, self.capacidades_tecnologicas_historia, color=color)
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:purple'
        ax2.set_ylabel('Productividad Promedio', color=color)
        ax2.plot(pasos, self.productividad_promedio_historia, color=color, linestyle='--')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Evolución de Capacidades Tecnológicas y Productividad')
        fig.tight_layout()
        plt.show()

# Ejecutar el modelo
model = ModeloProductivo(N=20)
for i in range(150):
    model.step()

model.graficar_resultados()

import random
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

# Configuración de estilo
sns.set_style('darkgrid')
plt.rcParams['figure.figsize'] = [12, 6]

class Trabajador:
    def __init__(self, calificacion, tipo):
        self.calificacion = calificacion  # 1-10
        self.tipo = tipo  # "produccion_ventas" o "administrativo"
        self.experiencia = 1
        self.productividad_personal = random.uniform(0.8, 1.2)

    def aumentar_experiencia(self):
        self.experiencia *= 1.05
        if random.random() < 0.1:
            self.calificacion = min(10, self.calificacion + 0.1)

class Empresa:
    def __init__(self, unique_id, sector):
        self.unique_id = unique_id
        self.sector = sector
        # Capacidades base
        self.diversidad = 1.0  # Capacidad de generar ideas
        self.especializacion = 1.0  # Capacidad de implementación
        self.capacidad_tecnologica = self.calcular_capacidad_tecnologica()

        # Variables económicas
        self.ingresos = 1000 + random.uniform(-200, 200)
        self.costos = 750 + random.uniform(-150, 150)
        self.productividad = 5
        self.produccion = 50
        self.precio = 10
        self.trabajadores = {"produccion_ventas": [], "administrativo": []}
        self.margen_minimo = 0.3
        self.calificacion_minima_requerida = 6
        self.productos = [{"nombre": f"Producto_{i}", "ingresos": 10, "costos": 5, "produccion": 5} for i in range(3)]
        self.inversion_iyd = 0.05
        self.estado_financiero = "estable"
        self.antiguedad = 0
        self.historial_innovacion = []
        self.prioridad_margen = random.uniform(0.3, 0.9)  # Grado de preferencia por márgenes (0-1)

        # Factores sectoriales
        self.factores_sectoriales = {
            "agricultura": {"innovacion": 0.8, "riesgo": 0.6, "productividad": 0.9},
            "manufactura": {"innovacion": 1.2, "riesgo": 0.8, "productividad": 1.1},
            "servicios": {"innovacion": 1.0, "riesgo": 0.7, "productividad": 1.0},
            "turismo": {"innovacion": 0.7, "riesgo": 0.9, "productividad": 0.8}
        }[sector]

    def calcular_capacidad_tecnologica(self):
        """Combina diversidad y especialización con rendimientos decrecientes"""
        base = min(self.diversidad, self.especializacion)
        exceso = max(0, self.diversidad - self.especializacion) * 0.5
        return base + exceso

    def actualizar_capacidades(self):
        """Actualiza todas las capacidades derivadas"""
        # Diversidad basada en productos únicos
        self.diversidad = 1 + len(set(p["nombre"] for p in self.productos)) * 0.2

        # Especialización basada en concentración de recursos
        if self.productos:
            trabajadores_totales = sum(len(self.trabajadores[t]) for t in self.trabajadores)
            self.especializacion = 1 + (trabajadores_totales / len(self.productos)) * 0.1

        # Actualizar capacidad tecnológica y requerimientos
        self.capacidad_tecnologica = self.calcular_capacidad_tecnologica()
        self.calificacion_minima_requerida = max(3, self.capacidad_tecnologica * 1.5)

    def calcular_margen(self):
        return (self.ingresos - self.costos) / self.ingresos if self.ingresos > 0 else 0

    def contratar_trabajador(self, calificacion=1, tipo="produccion_ventas"):
        calif_base = max(1, min(10, self.calificacion_minima_requerida * random.uniform(0.8, 1.2)))
        self.trabajadores[tipo].append(Trabajador(calif_base, tipo))
        self.actualizar_capacidades()

    def despedir_trabajador(self, tipo, trabajador=None):
        if trabajador:
            self.trabajadores[tipo].remove(trabajador)
        elif self.trabajadores[tipo]:
            menos_productivo = min(self.trabajadores[tipo], key=lambda t: t.productividad_personal)
            self.trabajadores[tipo].remove(menos_productivo)
        self.actualizar_capacidades()

    def ajustar_empleo(self):
        trabajadores_necesarios = max(1, int(self.produccion / self.productividad))
        tipos = ["produccion_ventas", "administrativo"]

        for tipo in tipos:
            ratio_ajuste = {
                "expansion": 1.1,
                "estable": 1.0,
                "recesion": 0.9
            }[self.estado_financiero]

            objetivo = max(1, int(trabajadores_necesarios * ratio_ajuste // 2))

            while len(self.trabajadores[tipo]) < objetivo:
                self.contratar_trabajador(calificacion=self.calificacion_minima_requerida, tipo=tipo)

            while len(self.trabajadores[tipo]) > objetivo * 1.2:
                self.despedir_trabajador(tipo)

    def evaluar_calificacion(self):
        tipos = ["produccion_ventas", "administrativo"]
        for tipo in tipos:
            for trabajador in self.trabajadores[tipo][:]:
                umbral_despido = self.calificacion_minima_requerida * 0.8
                if trabajador.calificacion < umbral_despido and random.random() < 0.7:
                    self.despedir_trabajador(tipo, trabajador)
                else:
                    trabajador.aumentar_experiencia()

    def simular_perturbaciones_externas(self, ciclo_economico):
        factor_ciclo = random.uniform(0.9, 1.1) * ciclo_economico

        perturbacion_sectorial = random.uniform(
            0.9 * self.factores_sectoriales["riesgo"],
            1.1 * self.factores_sectoriales["riesgo"]
        )

        self.produccion *= random.uniform(0.7, 1.3) * factor_ciclo * perturbacion_sectorial
        self.costos *= random.uniform(0.8, 1.15) * (1/factor_ciclo if random.random() < 0.5 else 1)
        self.ingresos *= random.uniform(0.7, 1.25) * factor_ciclo

        margen = self.calcular_margen()
        if margen > self.margen_minimo * 1.2:
            self.estado_financiero = "expansion"
        elif margen < self.margen_minimo * 0.8:
            self.estado_financiero = "recesion"
        else:
            self.estado_financiero = "estable"

    def competir_por_trabajadores_calificados(self, otras_empresas):
        if self.estado_financiero == "recesion":
            return

        tipos = ["produccion_ventas", "administrativo"]
        for otra_empresa in otras_empresas:
            if otra_empresa is not self and len(otra_empresa.trabajadores["produccion_ventas"]) > 2:
                for tipo in tipos:
                    if otra_empresa.trabajadores[tipo]:
                        prob_atraer = 0.1 * (self.capacidad_tecnologica - otra_empresa.capacidad_tecnologica)
                        prob_atraer += 0.1 if self.estado_financiero == "expansion" else 0

                        if random.random() < max(0, prob_atraer):
                            trabajador = random.choice(otra_empresa.trabajadores[tipo])
                            if trabajador.calificacion >= self.calificacion_minima_requerida * 0.9:
                                self.trabajadores[tipo].append(trabajador)
                                otra_empresa.trabajadores[tipo].remove(trabajador)
                                self.actualizar_capacidades()
                                otra_empresa.actualizar_capacidades()

    def ajustar_especializacion(self):
        nuevos_productos = []
        for producto in self.productos:
            margen_producto = (producto["ingresos"] - producto["costos"]) / producto["ingresos"] if producto["ingresos"] > 0 else 0

            umbral_abandono = self.margen_minimo * {
                "expansion": 0.9,
                "estable": 1.0,
                "recesion": 1.1
            }[self.estado_financiero]

            if margen_producto >= umbral_abandono or random.random() < 0.2 * self.capacidad_tecnologica:
                nuevos_productos.append(producto)
            else:
                self.produccion -= producto["produccion"]
                self.ajustar_empleo()

        self.productos = nuevos_productos
        self.actualizar_capacidades()

    def innovar_tecnologicamente(self):
        margen_actual = self.calcular_margen()

        # Condición 1: Margen suficiente considerando prioridad
        umbral_margen = self.margen_minimo * (1 - self.prioridad_margen * 0.3)
        if margen_actual < umbral_margen:
            return

        # Condición 2: Diversidad > Especialización
        if self.diversidad > self.especializacion:
            return

        # Probabilidad combinada
        factor_margen = min(1, margen_actual / self.margen_minimo)
        factor_diversidad = (self.diversidad - self.especializacion) / self.diversidad if self.diversidad > 0 else 0

        prob_base = 0.03 * self.factores_sectoriales["innovacion"]
        prob_ajustada = prob_base * factor_margen * (1 + factor_diversidad)

        if random.random() < prob_ajustada:
            # Éxito en innovación
            incremento_diversidad = random.uniform(0.01, 0.04) * (1 - self.prioridad_margen * 0.5)
            incremento_especializacion = random.uniform(0.01, 0.03) * (1 - self.prioridad_margen * 0.3)

            self.diversidad += incremento_diversidad
            self.especializacion += incremento_especializacion

            self.productividad += random.uniform(0.01, 0.1) * self.especializacion * (1 - self.prioridad_margen * 0.2)

            self.actualizar_capacidades()

            # Riesgo de fracaso
            if random.random() < (0.1 + self.prioridad_margen * 0.1):
                self.diversidad *= 0.95
                self.especializacion *= 0.97
                self.actualizar_capacidades()

    def innovar_productos(self):
        margen_actual = self.calcular_margen()

        # Condición 1: Margen suficiente
        umbral_margen = self.margen_minimo * (1 - self.prioridad_margen * 0.2)
        if margen_actual < umbral_margen:
            return

        # Condición 2: Diversidad suficiente
        if self.diversidad <= self.especializacion:
            return

        # Probabilidad combinada
        prob_base = 0.03 * self.inversion_iyd * 20 * self.factores_sectoriales["innovacion"]
        factor_margen = min(1, (margen_actual - umbral_margen) / (self.margen_minimo - umbral_margen)) if self.margen_minimo > umbral_margen else 1
        factor_diversidad = (self.diversidad - self.especializacion) / (self.diversidad + 1)

        prob_innovacion = prob_base * factor_margen * (1 + factor_diversidad)

        if random.random() < prob_innovacion:
            # Crear nuevo producto
            calidad = self.capacidad_tecnologica * (1 + (self.diversidad - self.especializacion) * 0.2)

            nuevo_producto = {
                "nombre": f"Producto_Nuevo_{len(self.productos) + 1}",
                "ingresos": random.uniform(5, 15) * calidad,
                "costos": random.uniform(3, 10) / (calidad * (1 + self.prioridad_margen * 0.3)),
                "produccion": random.uniform(5, 10),
                "tecnologia": self.capacidad_tecnologica
            }
            self.productos.append(nuevo_producto)
            self.produccion += nuevo_producto["produccion"]
            self.historial_innovacion.append(self.antiguedad)
            self.actualizar_capacidades()

    def ajustar_precios(self):
        margen_actual = self.calcular_margen()

        if margen_actual < self.margen_minimo:
            factor_precio = random.uniform(1.05, 1.15)
        else:
            if self.estado_financiero == "expansion":
                factor_precio = random.uniform(1.0, 1.1)
            elif self.estado_financiero == "recesion":
                factor_precio = random.uniform(0.95, 1.0)
            else:
                factor_precio = random.uniform(0.98, 1.03)

        if self.prioridad_margen > 0.5:
            factor_precio *= 1 + (self.prioridad_margen - 0.5) * 0.1

        nuevo_precio = self.precio * factor_precio
        nuevo_ingreso = self.ingresos * (2 - factor_precio)

        margen_potencial = (nuevo_ingreso - self.costos) / nuevo_ingreso if nuevo_ingreso > 0 else 0

        if margen_potencial > margen_actual or (self.estado_financiero == "recesion" and random.random() < 0.3):
            self.precio = nuevo_precio
            self.ingresos = nuevo_ingreso

    def colaborar_con_otras_empresas(self, otras_empresas):
        prob_colaborar = 0.1 * self.capacidad_tecnologica
        prob_colaborar += 0.1 if self.estado_financiero == "expansion" else 0
        prob_colaborar *= (1 - self.prioridad_margen * 0.3)

        if random.random() < prob_colaborar:
            for otra_empresa in otras_empresas:
                if otra_empresa is not self and otra_empresa.sector == self.sector:
                    margen_propio = self.calcular_margen()
                    margen_otra = otra_empresa.calcular_margen()

                    if margen_propio >= self.margen_minimo and margen_otra >= otra_empresa.margen_minimo:
                        sinergia = random.uniform(0.8, 1.2)
                        self.ingresos += 50 * sinergia
                        otra_empresa.ingresos += 50 * sinergia
                        self.diversidad += 0.02 * sinergia
                        otra_empresa.diversidad += 0.02 * sinergia
                        self.actualizar_capacidades()
                        otra_empresa.actualizar_capacidades()

    def step(self, ciclo_economico):
        self.antiguedad += 1
        self.simular_perturbaciones_externas(ciclo_economico)
        self.ajustar_empleo()
        self.evaluar_calificacion()

        if random.random() < 0.2:
            self.ajustar_especializacion()

        self.actualizar_capacidades()

        # Ajustar inversión en I+D considerando prioridad por márgenes
        base_inversion = {
            "expansion": random.uniform(0.06, 0.1),
            "estable": random.uniform(0.04, 0.07),
            "recesion": random.uniform(0.02, 0.05)
        }[self.estado_financiero]

        self.inversion_iyd = base_inversion * self.factores_sectoriales["innovacion"] * (1 - self.prioridad_margen * 0.4)

        self.innovar_tecnologicamente()
        self.innovar_productos()
        self.ajustar_precios()
        self.colaborar_con_otras_empresas([])

class ModeloProductivo:
    def __init__(self, N):
        self.num_empresas = N
        sectores = ["agricultura", "manufactura", "servicios", "turismo"]
        self.empresas = [Empresa(i, sector=sectores[i % len(sectores)]) for i in range(N)]

        # Historial de métricas
        self.empleo_total_historia = []
        self.diversidad_promedio_historia = []
        self.especializacion_promedio_historia = []
        self.ratio_diversidad_especializacion_historia = []
        self.capacidades_tecnologicas_historia = []
        self.margenes_promedio_historia = []
        self.tasa_innovacion_historia = []
        self.productividad_promedio_historia = []
        self.ciclo_economico_historia = []
        self.prioridad_margen_promedio_historia = []

        # Variables del ciclo económico
        self.ciclo_economico = 1.0
        self.fase_ciclo = "neutro"
        self.duracion_fase = 0
        self.amplitud_ciclo = 0.2

    def generar_ciclo_economico(self):
        if self.duracion_fase <= 0:
            if self.fase_ciclo == "expansion":
                self.fase_ciclo = random.choice(["recesion", "neutro"])
            elif self.fase_ciclo == "recesion":
                self.fase_ciclo = random.choice(["expansion", "neutro"])
            else:
                self.fase_ciclo = random.choice(["expansion", "recesion", "neutro"])
            self.duracion_fase = random.randint(5, 15)
        else:
            self.duracion_fase -= 1

        if self.fase_ciclo == "expansion":
            self.ciclo_economico = 1.0 + self.amplitud_ciclo * random.uniform(0.5, 1.0)
        elif self.fase_ciclo == "recesion":
            self.ciclo_economico = 1.0 - self.amplitud_ciclo * random.uniform(0.5, 1.0)
        else:
            self.ciclo_economico = 1.0 + self.amplitud_ciclo * random.uniform(-0.3, 0.3)

        if random.random() < 0.05:
            self.amplitud_ciclo = random.uniform(0.1, 0.3)

        self.ciclo_economico_historia.append(self.ciclo_economico)
        return self.ciclo_economico

    def calcular_empleo_total(self):
        return sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)

    def calcular_tasa_desempleo(self):
        empleo_total = self.calcular_empleo_total()
        trabajadores_disponibles = 10000
        return max(0, 1 - (empleo_total / trabajadores_disponibles))

    def calcular_calificacion_promedio(self):
        total_trabajadores = sum(len(empresa.trabajadores[tipo]) for empresa in self.empresas for tipo in empresa.trabajadores)
        if total_trabajadores == 0:
            return 0

        total_calificacion = sum(
            sum(t.calificacion * t.experiencia for t in empresa.trabajadores[tipo])
            for empresa in self.empresas for tipo in empresa.trabajadores
        )
        return total_calificacion / total_trabajadores

    def calcular_brecha_cualificacion(self):
        calificacion_promedio = self.calcular_calificacion_promedio()
        if calificacion_promedio == 0:
            return 0

        total_brecha = sum(
            max(0, empresa.calificacion_minima_requerida - calificacion_promedio)
            for empresa in self.empresas
        )
        return total_brecha / len(self.empresas)

    def calcular_diversidad_promedio(self):
        diversidades = [empresa.diversidad for empresa in self.empresas]
        return sum(diversidades) / len(diversidades) if diversidades else 0

    def calcular_especializacion_promedio(self):
        especializaciones = [empresa.especializacion for empresa in self.empresas]
        return sum(especializaciones) / len(especializaciones) if especializaciones else 0

    def calcular_ratio_diversidad_especializacion(self):
        ratios = []
        for empresa in self.empresas:
            if empresa.especializacion > 0:
                ratios.append(empresa.diversidad / empresa.especializacion)
        return sum(ratios) / len(ratios) if ratios else 0

    def calcular_capacidades_tecnologicas_promedio(self):
        return sum(empresa.capacidad_tecnologica for empresa in self.empresas) / len(self.empresas)

    def calcular_margenes_promedio(self):
        margenes = [empresa.calcular_margen() for empresa in self.empresas]
        return sum(margenes) / len(margenes) if margenes else 0

    def calcular_tasa_innovacion(self):
        innovadoras = 0
        for empresa in self.empresas:
            if empresa.capacidad_tecnologica > 1.5:
                innovadoras += 2
            elif empresa.capacidad_tecnologica > 1.2:
                innovadoras += 1
            elif empresa.capacidad_tecnologica > 1.0 and random.random() < 0.5:
                innovadoras += 0.5

        return innovadoras / (2 * len(self.empresas))

    def calcular_desigualdad_capacidades(self):
        capacidades = [empresa.capacidad_tecnologica for empresa in self.empresas]
        promedio = sum(capacidades) / len(capacidades)
        varianza = sum((c - promedio) ** 2 for c in capacidades) / len(capacidades)
        return varianza

    def calcular_productividad_promedio(self):
        productividades = [empresa.productividad for empresa in self.empresas]
        return sum(productividades) / len(productividades) if productividades else 0

    def calcular_prioridad_margen_promedio(self):
        prioridades = [empresa.prioridad_margen for empresa in self.empresas]
        return sum(prioridades) / len(prioridades) if prioridades else 0

    def step(self):
        ciclo_actual = self.generar_ciclo_economico()

        random.shuffle(self.empresas)
        for empresa in self.empresas:
            empresa.step(ciclo_actual)
            empresa.competir_por_trabajadores_calificados(self.empresas)

        # Registrar métricas
        self.empleo_total_historia.append(self.calcular_empleo_total())
        self.diversidad_promedio_historia.append(self.calcular_diversidad_promedio())
        self.especializacion_promedio_historia.append(self.calcular_especializacion_promedio())
        self.ratio_diversidad_especializacion_historia.append(self.calcular_ratio_diversidad_especializacion())
        self.capacidades_tecnologicas_historia.append(self.calcular_capacidades_tecnologicas_promedio())
        self.margenes_promedio_historia.append(self.calcular_margenes_promedio())
        self.tasa_innovacion_historia.append(self.calcular_tasa_innovacion())
        self.productividad_promedio_historia.append(self.calcular_productividad_promedio())
        self.prioridad_margen_promedio_historia.append(self.calcular_prioridad_margen_promedio())

    def graficar_resultados(self):
        pasos = range(len(self.empleo_total_historia))

        # Gráfica 1: Dinámica central
        fig, ax1 = plt.subplots(figsize=(14, 7))

        # Ratio D/E y umbral de innovación
        color = 'tab:blue'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Ratio Diversidad/Especialización', color=color)
        ax1.plot(pasos, self.ratio_diversidad_especializacion_historia, color=color, label='D/E')
        ax1.axhline(y=1, color=color, linestyle='--', alpha=0.5)
        ax1.tick_params(axis='y', labelcolor=color)

        # Tasa de innovación
        ax2 = ax1.twinx()
        color = 'tab:green'
        ax2.set_ylabel('Tasa de Innovación', color=color)
        ax2.plot(pasos, self.tasa_innovacion_historia, color=color, linestyle='-.', label='Innovación')
        ax2.tick_params(axis='y', labelcolor=color)

        # Margenes promedio
        ax3 = ax1.twinx()
        color = 'tab:red'
        ax3.spines['right'].set_position(('outward', 60))
        ax3.set_ylabel('Margen Promedio', color=color)
        ax3.plot(pasos, self.margenes_promedio_historia, color=color, linestyle=':', label='Margen')
        ax3.tick_params(axis='y', labelcolor=color)

        plt.title('Dinámica Completa: Relación D/E, Innovación y Márgenes')
        fig.tight_layout()
        plt.show()

        # Gráfica 2: Capacidades y productividad
        fig, ax1 = plt.subplots(figsize=(12, 6))

        color = 'tab:purple'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Capacidad Tecnológica Promedio', color=color)
        ax1.plot(pasos, self.capacidades_tecnologicas_historia, color=color)
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:orange'
        ax2.set_ylabel('Productividad Promedio', color=color)
        ax2.plot(pasos, self.productividad_promedio_historia, color=color, linestyle='--')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Evolución de Capacidades Tecnológicas y Productividad')
        fig.tight_layout()
        plt.show()

        # Gráfica 3: Prioridad por márgenes vs innovación
        fig, ax1 = plt.subplots(figsize=(12, 6))

        color = 'tab:brown'
        ax1.set_xlabel('Pasos')
        ax1.set_ylabel('Prioridad por Márgenes (Promedio)', color=color)
        ax1.plot(pasos, self.prioridad_margen_promedio_historia, color=color)
        ax1.tick_params(axis='y', labelcolor=color)

        ax2 = ax1.twinx()
        color = 'tab:cyan'
        ax2.set_ylabel('Tasa de Innovación', color=color)
        ax2.plot(pasos, self.tasa_innovacion_historia, color=color, linestyle='--')
        ax2.tick_params(axis='y', labelcolor=color)

        plt.title('Relación entre Prioridad por Márgenes y Tasa de Innovación')
        fig.tight_layout()
        plt.show()

# Ejecución del modelo
modelo = ModeloProductivo(N=30)
for _ in range(200):
    modelo.step()

modelo.graficar_resultados()